/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@colors/colors/lib/colors.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/colors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*

The MIT License (MIT)

Original Library
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var util = __webpack_require__(/*! util */ "util");
var ansiStyles = colors.styles = __webpack_require__(/*! ./styles */ "../../node_modules/@colors/colors/lib/styles.js");
var defineProps = Object.defineProperties;
var newLineRegex = new RegExp(/[\r\n]+/g);

colors.supportsColor = (__webpack_require__(/*! ./system/supports-colors */ "../../node_modules/@colors/colors/lib/system/supports-colors.js").supportsColor);

if (typeof colors.enabled === 'undefined') {
  colors.enabled = colors.supportsColor() !== false;
}

colors.enable = function() {
  colors.enabled = true;
};

colors.disable = function() {
  colors.enabled = false;
};

colors.stripColors = colors.strip = function(str) {
  return ('' + str).replace(/\x1B\[\d+m/g, '');
};

// eslint-disable-next-line no-unused-vars
var stylize = colors.stylize = function stylize(str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  var styleMap = ansiStyles[style];

  // Stylize should work for non-ANSI styles, too
  if (!styleMap && style in colors) {
    // Style maps like trap operate as functions on strings;
    // they don't have properties like open or close.
    return colors[style](str);
  }

  return styleMap.open + str + styleMap.close;
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe, '\\$&');
};

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function() {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function(key) {
    ansiStyles[key].closeRe =
      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function() {
        return build(this._styles.concat(key));
      },
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = Array.prototype.slice.call(arguments);

  var str = args.map(function(arg) {
    // Use weak equality check so we can colorize null/undefined in safe mode
    if (arg != null && arg.constructor === String) {
      return arg;
    } else {
      return util.inspect(arg);
    }
  }).join(' ');

  if (!colors.enabled || !str) {
    return str;
  }

  var newLinesPresent = str.indexOf('\n') != -1;

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
    if (newLinesPresent) {
      str = str.replace(newLineRegex, function(match) {
        return code.close + match + code.open;
      });
    }
  }

  return str;
}

colors.setTheme = function(theme) {
  if (typeof theme === 'string') {
    console.log('colors.setTheme now only accepts an object, not a string.  ' +
      'If you are trying to set a theme from a file, it is now your (the ' +
      'caller\'s) responsibility to require the file.  The old syntax ' +
      'looked like colors.setTheme(__dirname + ' +
      '\'/../themes/generic-logging.js\'); The new syntax looks like '+
      'colors.setTheme(require(__dirname + ' +
      '\'/../themes/generic-logging.js\'));');
    return;
  }
  for (var style in theme) {
    (function(style) {
      colors[style] = function(str) {
        if (typeof theme[style] === 'object') {
          var out = str;
          for (var i in theme[style]) {
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function(name) {
    ret[name] = {
      get: function() {
        return build([name]);
      },
    };
  });
  return ret;
}

var sequencer = function sequencer(map, str) {
  var exploded = str.split('');
  exploded = exploded.map(map);
  return exploded.join('');
};

// custom formatter methods
colors.trap = __webpack_require__(/*! ./custom/trap */ "../../node_modules/@colors/colors/lib/custom/trap.js");
colors.zalgo = __webpack_require__(/*! ./custom/zalgo */ "../../node_modules/@colors/colors/lib/custom/zalgo.js");

// maps
colors.maps = {};
colors.maps.america = __webpack_require__(/*! ./maps/america */ "../../node_modules/@colors/colors/lib/maps/america.js")(colors);
colors.maps.zebra = __webpack_require__(/*! ./maps/zebra */ "../../node_modules/@colors/colors/lib/maps/zebra.js")(colors);
colors.maps.rainbow = __webpack_require__(/*! ./maps/rainbow */ "../../node_modules/@colors/colors/lib/maps/rainbow.js")(colors);
colors.maps.random = __webpack_require__(/*! ./maps/random */ "../../node_modules/@colors/colors/lib/maps/random.js")(colors);

for (var map in colors.maps) {
  (function(map) {
    colors[map] = function(str) {
      return sequencer(colors.maps[map], str);
    };
  })(map);
}

defineProps(colors, init());


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/custom/trap.js":
/*!************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/custom/trap.js ***!
  \************************************************************/
/***/ ((module) => {

module['exports'] = function runTheTrap(text, options) {
  var result = '';
  text = text || 'Run the trap, drop the bass';
  text = text.split('');
  var trap = {
    a: ['\u0040', '\u0104', '\u023a', '\u0245', '\u0394', '\u039b', '\u0414'],
    b: ['\u00df', '\u0181', '\u0243', '\u026e', '\u03b2', '\u0e3f'],
    c: ['\u00a9', '\u023b', '\u03fe'],
    d: ['\u00d0', '\u018a', '\u0500', '\u0501', '\u0502', '\u0503'],
    e: ['\u00cb', '\u0115', '\u018e', '\u0258', '\u03a3', '\u03be', '\u04bc',
      '\u0a6c'],
    f: ['\u04fa'],
    g: ['\u0262'],
    h: ['\u0126', '\u0195', '\u04a2', '\u04ba', '\u04c7', '\u050a'],
    i: ['\u0f0f'],
    j: ['\u0134'],
    k: ['\u0138', '\u04a0', '\u04c3', '\u051e'],
    l: ['\u0139'],
    m: ['\u028d', '\u04cd', '\u04ce', '\u0520', '\u0521', '\u0d69'],
    n: ['\u00d1', '\u014b', '\u019d', '\u0376', '\u03a0', '\u048a'],
    o: ['\u00d8', '\u00f5', '\u00f8', '\u01fe', '\u0298', '\u047a', '\u05dd',
      '\u06dd', '\u0e4f'],
    p: ['\u01f7', '\u048e'],
    q: ['\u09cd'],
    r: ['\u00ae', '\u01a6', '\u0210', '\u024c', '\u0280', '\u042f'],
    s: ['\u00a7', '\u03de', '\u03df', '\u03e8'],
    t: ['\u0141', '\u0166', '\u0373'],
    u: ['\u01b1', '\u054d'],
    v: ['\u05d8'],
    w: ['\u0428', '\u0460', '\u047c', '\u0d70'],
    x: ['\u04b2', '\u04fe', '\u04fc', '\u04fd'],
    y: ['\u00a5', '\u04b0', '\u04cb'],
    z: ['\u01b5', '\u0240'],
  };
  text.forEach(function(c) {
    c = c.toLowerCase();
    var chars = trap[c] || [' '];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== 'undefined') {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;
};


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/custom/zalgo.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/custom/zalgo.js ***!
  \*************************************************************/
/***/ ((module) => {

// please no
module['exports'] = function zalgo(text, options) {
  text = text || '   he is here   ';
  var soul = {
    'up': [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚',
    ],
    'down': [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣',
    ],
    'mid': [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉',
    ],
  };
  var all = [].concat(soul.up, soul.down, soul.mid);

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function isChar(character) {
    var bool = false;
    all.filter(function(i) {
      bool = (i === character);
    });
    return bool;
  }


  function heComes(text, options) {
    var result = '';
    var counts;
    var l;
    options = options || {};
    options['up'] =
      typeof options['up'] !== 'undefined' ? options['up'] : true;
    options['mid'] =
      typeof options['mid'] !== 'undefined' ? options['mid'] : true;
    options['down'] =
      typeof options['down'] !== 'undefined' ? options['down'] : true;
    options['size'] =
      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';
    text = text.split('');
    for (l in text) {
      if (isChar(l)) {
        continue;
      }
      result = result + text[l];
      counts = {'up': 0, 'down': 0, 'mid': 0};
      switch (options.size) {
        case 'mini':
          counts.up = randomNumber(8);
          counts.mid = randomNumber(2);
          counts.down = randomNumber(8);
          break;
        case 'maxi':
          counts.up = randomNumber(16) + 3;
          counts.mid = randomNumber(4) + 1;
          counts.down = randomNumber(64) + 3;
          break;
        default:
          counts.up = randomNumber(8) + 1;
          counts.mid = randomNumber(6) / 2;
          counts.down = randomNumber(8) + 1;
          break;
      }

      var arr = ['up', 'mid', 'down'];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
};



/***/ }),

/***/ "../../node_modules/@colors/colors/lib/maps/america.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/maps/america.js ***!
  \*************************************************************/
/***/ ((module) => {

module['exports'] = function(colors) {
  return function(letter, i, exploded) {
    if (letter === ' ') return letter;
    switch (i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter);
      case 2: return colors.blue(letter);
    }
  };
};


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/maps/rainbow.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/maps/rainbow.js ***!
  \*************************************************************/
/***/ ((module) => {

module['exports'] = function(colors) {
  // RoY G BiV
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
  return function(letter, i, exploded) {
    if (letter === ' ') {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
};



/***/ }),

/***/ "../../node_modules/@colors/colors/lib/maps/random.js":
/*!************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/maps/random.js ***!
  \************************************************************/
/***/ ((module) => {

module['exports'] = function(colors) {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',
    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',
    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];
  return function(letter, i, exploded) {
    return letter === ' ' ? letter :
      colors[
          available[Math.round(Math.random() * (available.length - 2))]
      ](letter);
  };
};


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/maps/zebra.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/maps/zebra.js ***!
  \***********************************************************/
/***/ ((module) => {

module['exports'] = function(colors) {
  return function(letter, i, exploded) {
    return i % 2 === 0 ? letter : colors.inverse(letter);
  };
};


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/styles.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/styles.js ***!
  \*******************************************************/
/***/ ((module) => {

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  brightRed: [91, 39],
  brightGreen: [92, 39],
  brightYellow: [93, 39],
  brightBlue: [94, 39],
  brightMagenta: [95, 39],
  brightCyan: [96, 39],
  brightWhite: [97, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgGray: [100, 49],
  bgGrey: [100, 49],

  bgBrightRed: [101, 49],
  bgBrightGreen: [102, 49],
  bgBrightYellow: [103, 49],
  bgBrightBlue: [104, 49],
  bgBrightMagenta: [105, 49],
  bgBrightCyan: [106, 49],
  bgBrightWhite: [107, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49],

};

Object.keys(codes).forEach(function(key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/system/has-flag.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/system/has-flag.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



module.exports = function(flag, argv) {
  argv = argv || process.argv || [];

  var terminatorPos = argv.indexOf('--');
  var prefix = /^-{1,2}/.test(flag) ? '' : '--';
  var pos = argv.indexOf(prefix + flag);

  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ "../../node_modules/@colors/colors/lib/system/supports-colors.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@colors/colors/lib/system/supports-colors.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/



var os = __webpack_require__(/*! os */ "os");
var hasFlag = __webpack_require__(/*! ./has-flag.js */ "../../node_modules/@colors/colors/lib/system/has-flag.js");

var env = process.env;

var forceColor = void 0;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
  forceColor = false;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')
           || hasFlag('color=always')) {
  forceColor = true;
}
if ('FORCE_COLOR' in env) {
  forceColor = env.FORCE_COLOR.length === 0
    || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
  if (level === 0) {
    return false;
  }

  return {
    level: level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}

function supportsColor(stream) {
  if (forceColor === false) {
    return 0;
  }

  if (hasFlag('color=16m') || hasFlag('color=full')
      || hasFlag('color=truecolor')) {
    return 3;
  }

  if (hasFlag('color=256')) {
    return 2;
  }

  if (stream && !stream.isTTY && forceColor !== true) {
    return 0;
  }

  var min = forceColor ? 1 : 0;

  if (process.platform === 'win32') {
    // Node.js 7.5.0 is the first version of Node.js to include a patch to
    // libuv that enables 256 color output on Windows. Anything earlier and it
    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
    // release, and Node.js 7 is not. Windows 10 build 10586 is the first
    // Windows release that supports 256 colors. Windows 10 build 14931 is the
    // first release that supports 16m/TrueColor.
    var osRelease = os.release().split('.');
    if (Number(process.versions.node.split('.')[0]) >= 8
        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }

    return 1;
  }

  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
      return sign in env;
    }) || env.CI_NAME === 'codeship') {
      return 1;
    }

    return min;
  }

  if ('TEAMCITY_VERSION' in env) {
    return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
    );
  }

  if ('TERM_PROGRAM' in env) {
    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Hyper':
        return 3;
      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }

  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }

  if ('COLORTERM' in env) {
    return 1;
  }

  if (env.TERM === 'dumb') {
    return min;
  }

  return min;
}

function getSupportLevel(stream) {
  var level = supportsColor(stream);
  return translateLevel(level);
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr),
};


/***/ }),

/***/ "../../node_modules/@colors/colors/safe.js":
/*!*************************************************!*\
  !*** ../../node_modules/@colors/colors/safe.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// Remark: Requiring this file will use the "safe" colors API,
// which will not touch String.prototype.
//
//   var colors = require('colors/safe');
//   colors.red("foo")
//
//
var colors = __webpack_require__(/*! ./lib/colors */ "../../node_modules/@colors/colors/lib/colors.js");
module['exports'] = colors;


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/adapters/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/adapters/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var enabled = __webpack_require__(/*! enabled */ "../../node_modules/enabled/index.js");

/**
 * Creates a new Adapter.
 *
 * @param {Function} fn Function that returns the value.
 * @returns {Function} The adapter logic.
 * @public
 */
module.exports = function create(fn) {
  return function adapter(namespace) {
    try {
      return enabled(namespace, fn());
    } catch (e) { /* Any failure means that we found nothing */ }

    return false;
  };
}


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/adapters/process.env.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/adapters/process.env.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var adapter = __webpack_require__(/*! ./ */ "../../node_modules/@dabh/diagnostics/adapters/index.js");

/**
 * Extracts the values from process.env.
 *
 * @type {Function}
 * @public
 */
module.exports = adapter(function processenv() {
  return process.env.DEBUG || process.env.DIAGNOSTICS;
});


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/diagnostics.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/diagnostics.js ***!
  \***********************************************************/
/***/ ((module) => {

/**
 * Contains all configured adapters for the given environment.
 *
 * @type {Array}
 * @public
 */
var adapters = [];

/**
 * Contains all modifier functions.
 *
 * @typs {Array}
 * @public
 */
var modifiers = [];

/**
 * Our default logger.
 *
 * @public
 */
var logger = function devnull() {};

/**
 * Register a new adapter that will used to find environments.
 *
 * @param {Function} adapter A function that will return the possible env.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */
function use(adapter) {
  if (~adapters.indexOf(adapter)) return false;

  adapters.push(adapter);
  return true;
}

/**
 * Assign a new log method.
 *
 * @param {Function} custom The log method.
 * @public
 */
function set(custom) {
  logger = custom;
}

/**
 * Check if the namespace is allowed by any of our adapters.
 *
 * @param {String} namespace The namespace that needs to be enabled
 * @returns {Boolean|Promise} Indication if the namespace is enabled by our adapters.
 * @public
 */
function enabled(namespace) {
  var async = [];

  for (var i = 0; i < adapters.length; i++) {
    if (adapters[i].async) {
      async.push(adapters[i]);
      continue;
    }

    if (adapters[i](namespace)) return true;
  }

  if (!async.length) return false;

  //
  // Now that we know that we Async functions, we know we run in an ES6
  // environment and can use all the API's that they offer, in this case
  // we want to return a Promise so that we can `await` in React-Native
  // for an async adapter.
  //
  return new Promise(function pinky(resolve) {
    Promise.all(
      async.map(function prebind(fn) {
        return fn(namespace);
      })
    ).then(function resolved(values) {
      resolve(values.some(Boolean));
    });
  });
}

/**
 * Add a new message modifier to the debugger.
 *
 * @param {Function} fn Modification function.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */
function modify(fn) {
  if (~modifiers.indexOf(fn)) return false;

  modifiers.push(fn);
  return true;
}

/**
 * Write data to the supplied logger.
 *
 * @param {Object} meta Meta information about the log.
 * @param {Array} args Arguments for console.log.
 * @public
 */
function write() {
  logger.apply(logger, arguments);
}

/**
 * Process the message with the modifiers.
 *
 * @param {Mixed} message The message to be transformed by modifers.
 * @returns {String} Transformed message.
 * @public
 */
function process(message) {
  for (var i = 0; i < modifiers.length; i++) {
    message = modifiers[i].apply(modifiers[i], arguments);
  }

  return message;
}

/**
 * Introduce options to the logger function.
 *
 * @param {Function} fn Calback function.
 * @param {Object} options Properties to introduce on fn.
 * @returns {Function} The passed function
 * @public
 */
function introduce(fn, options) {
  var has = Object.prototype.hasOwnProperty;

  for (var key in options) {
    if (has.call(options, key)) {
      fn[key] = options[key];
    }
  }

  return fn;
}

/**
 * Nope, we're not allowed to write messages.
 *
 * @returns {Boolean} false
 * @public
 */
function nope(options) {
  options.enabled = false;
  options.modify = modify;
  options.set = set;
  options.use = use;

  return introduce(function diagnopes() {
    return false;
  }, options);
}

/**
 * Yep, we're allowed to write debug messages.
 *
 * @param {Object} options The options for the process.
 * @returns {Function} The function that does the logging.
 * @public
 */
function yep(options) {
  /**
   * The function that receives the actual debug information.
   *
   * @returns {Boolean} indication that we're logging.
   * @public
   */
  function diagnostics() {
    var args = Array.prototype.slice.call(arguments, 0);

    write.call(write, options, process(args, options));
    return true;
  }

  options.enabled = true;
  options.modify = modify;
  options.set = set;
  options.use = use;

  return introduce(diagnostics, options);
}

/**
 * Simple helper function to introduce various of helper methods to our given
 * diagnostics function.
 *
 * @param {Function} diagnostics The diagnostics function.
 * @returns {Function} diagnostics
 * @public
 */
module.exports = function create(diagnostics) {
  diagnostics.introduce = introduce;
  diagnostics.enabled = enabled;
  diagnostics.process = process;
  diagnostics.modify = modify;
  diagnostics.write = write;
  diagnostics.nope = nope;
  diagnostics.yep = yep;
  diagnostics.set = set;
  diagnostics.use = use;

  return diagnostics;
}


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/logger/console.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/logger/console.js ***!
  \**************************************************************/
/***/ ((module) => {

/**
 * An idiot proof logger to be used as default. We've wrapped it in a try/catch
 * statement to ensure the environments without the `console` API do not crash
 * as well as an additional fix for ancient browsers like IE8 where the
 * `console.log` API doesn't have an `apply`, so we need to use the Function's
 * apply functionality to apply the arguments.
 *
 * @param {Object} meta Options of the logger.
 * @param {Array} messages The actuall message that needs to be logged.
 * @public
 */
module.exports = function (meta, messages) {
  //
  // So yea. IE8 doesn't have an apply so we need a work around to puke the
  // arguments in place.
  //
  try { Function.prototype.apply.call(console.log, console, messages); }
  catch (e) {}
}


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colorspace = __webpack_require__(/*! colorspace */ "../../node_modules/colorspace/index.js");
var kuler = __webpack_require__(/*! kuler */ "../../node_modules/kuler/index.js");

/**
 * Prefix the messages with a colored namespace.
 *
 * @param {Array} args The messages array that is getting written.
 * @param {Object} options Options for diagnostics.
 * @returns {Array} Altered messages array.
 * @public
 */
module.exports = function ansiModifier(args, options) {
  var namespace = options.namespace;
  var ansi = options.colors !== false
  ? kuler(namespace +':', colorspace(namespace))
  : namespace +':';

  args[0] = ansi +' '+ args[0];
  return args;
};


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/node/development.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/node/development.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var create = __webpack_require__(/*! ../diagnostics */ "../../node_modules/@dabh/diagnostics/diagnostics.js");
var tty = (__webpack_require__(/*! tty */ "tty").isatty)(1);

/**
 * Create a new diagnostics logger.
 *
 * @param {String} namespace The namespace it should enable.
 * @param {Object} options Additional options.
 * @returns {Function} The logger.
 * @public
 */
var diagnostics = create(function dev(namespace, options) {
  options = options || {};
  options.colors = 'colors' in options ? options.colors : tty;
  options.namespace = namespace;
  options.prod = false;
  options.dev = true;

  if (!dev.enabled(namespace) && !(options.force || dev.force)) {
    return dev.nope(options);
  }
  
  return dev.yep(options);
});

//
// Configure the logger for the given environment.
//
diagnostics.modify(__webpack_require__(/*! ../modifiers/namespace-ansi */ "../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"));
diagnostics.use(__webpack_require__(/*! ../adapters/process.env */ "../../node_modules/@dabh/diagnostics/adapters/process.env.js"));
diagnostics.set(__webpack_require__(/*! ../logger/console */ "../../node_modules/@dabh/diagnostics/logger/console.js"));

//
// Expose the diagnostics logger.
//
module.exports = diagnostics;


/***/ }),

/***/ "../../node_modules/@dabh/diagnostics/node/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@dabh/diagnostics/node/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// Select the correct build version depending on the environment.
//
if (false) {} else {
  module.exports = __webpack_require__(/*! ./development.js */ "../../node_modules/@dabh/diagnostics/node/development.js");
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/default-types.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/default-types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultMapping = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gbutton_1 = __webpack_require__(/*! ./gbutton */ "../../node_modules/@eclipse-glsp/graph/lib/gbutton.js");
const gcompartment_1 = __webpack_require__(/*! ./gcompartment */ "../../node_modules/@eclipse-glsp/graph/lib/gcompartment.js");
const gedge_1 = __webpack_require__(/*! ./gedge */ "../../node_modules/@eclipse-glsp/graph/lib/gedge.js");
const ggraph_1 = __webpack_require__(/*! ./ggraph */ "../../node_modules/@eclipse-glsp/graph/lib/ggraph.js");
const ghtml_root_1 = __webpack_require__(/*! ./ghtml-root */ "../../node_modules/@eclipse-glsp/graph/lib/ghtml-root.js");
const gissue_marker_1 = __webpack_require__(/*! ./gissue-marker */ "../../node_modules/@eclipse-glsp/graph/lib/gissue-marker.js");
const glabel_1 = __webpack_require__(/*! ./glabel */ "../../node_modules/@eclipse-glsp/graph/lib/glabel.js");
const gnode_1 = __webpack_require__(/*! ./gnode */ "../../node_modules/@eclipse-glsp/graph/lib/gnode.js");
const gport_1 = __webpack_require__(/*! ./gport */ "../../node_modules/@eclipse-glsp/graph/lib/gport.js");
const gpre_rendered_element_1 = __webpack_require__(/*! ./gpre-rendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gpre-rendered-element.js");
const gshaped_prerendered_element_1 = __webpack_require__(/*! ./gshaped-prerendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshaped-prerendered-element.js");
function getDefaultMapping() {
    // The GModelSerializer (packages/server-node/src/features/model/gmodel-serializer.ts)
    // has a built-in subtype handling.
    // If the mapping for a subtype, e.g. for comp:header, is not found it will use the mapping for comp instead.
    const mapping = new Map();
    mapping.set(protocol_1.DefaultTypes.GRAPH, ggraph_1.GGraph);
    mapping.set(protocol_1.DefaultTypes.NODE, gnode_1.GNode);
    mapping.set(protocol_1.DefaultTypes.EDGE, gedge_1.GEdge);
    mapping.set(protocol_1.DefaultTypes.PORT, gport_1.GPort);
    mapping.set(protocol_1.DefaultTypes.LABEL, glabel_1.GLabel);
    mapping.set(protocol_1.DefaultTypes.COMPARTMENT, gcompartment_1.GCompartment);
    mapping.set(protocol_1.DefaultTypes.BUTTON, gbutton_1.GButton);
    mapping.set(protocol_1.DefaultTypes.ISSUE_MARKER, gissue_marker_1.GIssueMarker);
    mapping.set(protocol_1.DefaultTypes.HTML, ghtml_root_1.GHtmlRoot);
    mapping.set(protocol_1.DefaultTypes.PRE_RENDERED, gpre_rendered_element_1.GPreRenderedElement);
    mapping.set(protocol_1.DefaultTypes.FOREIGN_OBJECT, gshaped_prerendered_element_1.GShapedPreRenderedElement);
    return mapping;
}
exports.getDefaultMapping = getDefaultMapping;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/galignable.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/galignable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GAlignableBuilder = exports.isGAlignable = exports.GAlignable = void 0;
exports.GAlignable = Symbol('GAlignable');
function isGAlignable(element) {
    return exports.GAlignable in element && element[exports.GAlignable] === true;
}
exports.isGAlignable = isGAlignable;
var GAlignableBuilder;
(function (GAlignableBuilder) {
    function alignment(builder, pointOrX, y) {
        const proxy = builder['proxy'];
        if (typeof pointOrX === 'object') {
            proxy.alignment = pointOrX;
        }
        else if (y !== undefined) {
            proxy.alignment = { x: pointOrX, y };
        }
        else {
            // Optionally handle cases where y is not provided
            proxy.alignment = { x: pointOrX, y: 0 };
            console.warn(`Incomplete parameters for GAlignableBuilder.alignment function. Setting alignment to ${JSON.stringify(proxy.alignment)}`);
        }
        return builder;
    }
    GAlignableBuilder.alignment = alignment;
})(GAlignableBuilder || (exports.GAlignableBuilder = GAlignableBuilder = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GBoundsAwareBuilder = exports.isGBoundsAware = exports.GBoundsAware = void 0;
exports.GBoundsAware = Symbol('GBoundsAware');
function isGBoundsAware(element) {
    return exports.GBoundsAware in element && element[exports.GBoundsAware] === true;
}
exports.isGBoundsAware = isGBoundsAware;
var GBoundsAwareBuilder;
(function (GBoundsAwareBuilder) {
    function position(builder, pointOrX, y) {
        const proxy = builder['proxy'];
        if (typeof pointOrX === 'object') {
            proxy.position = pointOrX;
        }
        else if (y !== undefined) {
            proxy.position = { x: pointOrX, y };
        }
        else {
            // Optionally handle cases where y is not provided
            proxy.position = { x: pointOrX, y: 0 };
            console.warn(`Incomplete parameters for GBoundsAwareBuilder.position function. Setting position to ${JSON.stringify(proxy.position)}`);
        }
        return builder;
    }
    GBoundsAwareBuilder.position = position;
    function size(builder, sizeOrWidth, height) {
        const proxy = builder['proxy'];
        if (typeof sizeOrWidth === 'object') {
            proxy.size = sizeOrWidth;
        }
        else if (height !== undefined) {
            proxy.size = { width: sizeOrWidth, height };
        }
        else {
            // Optionally handle cases where height is not provided
            proxy.size = { width: sizeOrWidth, height: 0 };
            console.warn(`Incomplete parameters for GBoundsAwareBuilder.size function. Setting size to ${JSON.stringify(proxy.size)}`);
        }
        return builder;
    }
    GBoundsAwareBuilder.size = size;
})(GBoundsAwareBuilder || (exports.GBoundsAwareBuilder = GBoundsAwareBuilder = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gbutton.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gbutton.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GButtonBuilder = exports.GButton = void 0;
/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GButton extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.BUTTON_EXPAND;
        this.enabled = true;
    }
    static builder(constructor) {
        return new GButtonBuilder(constructor !== null && constructor !== void 0 ? constructor : GButton).type(protocol_1.DefaultTypes.BUTTON_EXPAND);
    }
}
exports.GButton = GButton;
class GButtonBuilder extends gshape_element_1.GShapeElementBuilder {
    enabled(enabled) {
        this.proxy.enabled = enabled;
        return this;
    }
}
exports.GButtonBuilder = GButtonBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gcompartment.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gcompartment.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GCompartmentBuilder = exports.GCompartment = void 0;
/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const glayouting_1 = __webpack_require__(/*! ./glayouting */ "../../node_modules/@eclipse-glsp/graph/lib/glayouting.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GCompartment extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.COMPARTMENT;
        this[_a] = true;
    }
    static builder() {
        return new GCompartmentBuilder(GCompartment).type(protocol_1.DefaultTypes.COMPARTMENT);
    }
}
exports.GCompartment = GCompartment;
_a = glayouting_1.GLayouting;
class GCompartmentBuilder extends gshape_element_1.GShapeElementBuilder {
    layout(layout) {
        return glayouting_1.GLayoutingBuilder.layout(this, layout);
    }
}
exports.GCompartmentBuilder = GCompartmentBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gedge-layoutable.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gedge-layoutable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GEdgeLayoutableBuilder = exports.isGEdgeLayoutable = exports.GEdgeLayoutable = void 0;
exports.GEdgeLayoutable = Symbol('GEdgeLayoutable');
function isGEdgeLayoutable(element) {
    return exports.GEdgeLayoutable in element && element[exports.GEdgeLayoutable] === true;
}
exports.isGEdgeLayoutable = isGEdgeLayoutable;
var GEdgeLayoutableBuilder;
(function (GEdgeLayoutableBuilder) {
    function edgePlacement(builder, placement) {
        builder['proxy'].edgePlacement = placement;
        return builder;
    }
    GEdgeLayoutableBuilder.edgePlacement = edgePlacement;
})(GEdgeLayoutableBuilder || (exports.GEdgeLayoutableBuilder = GEdgeLayoutableBuilder = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gedge.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gedge.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GEdgeBuilder = exports.GEdge = void 0;
/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
class GEdge extends gmodel_element_1.GModelElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.EDGE;
        this.routingPoints = [];
    }
    static builder() {
        return new GEdgeBuilder(GEdge).type(protocol_1.DefaultTypes.EDGE);
    }
}
exports.GEdge = GEdge;
(function (GEdge) {
    function is(object) {
        return GEdge.is(object);
    }
    GEdge.is = is;
})(GEdge || (exports.GEdge = GEdge = {}));
class GEdgeBuilder extends gmodel_element_1.GModelElementBuilder {
    source(source) {
        this.proxy.sourceId = source.id;
        return this;
    }
    sourceId(sourceId) {
        this.proxy.sourceId = sourceId;
        return this;
    }
    target(target) {
        this.proxy.targetId = target.id;
        return this;
    }
    targetId(targetId) {
        this.proxy.targetId = targetId;
        return this;
    }
    routerKind(routerKind) {
        this.proxy.routerKind = routerKind;
        return this;
    }
    addRoutingPoint(xOrPoint, y) {
        if (typeof xOrPoint === 'object') {
            this.proxy.routingPoints.push(xOrPoint);
        }
        else if (y) {
            this.proxy.routingPoints.push({ x: xOrPoint, y });
        }
        return this;
    }
    addRoutingPoints(...routingPoints) {
        (0, protocol_1.flatPush)(this.proxy.routingPoints, routingPoints);
        return this;
    }
}
exports.GEdgeBuilder = GEdgeBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gforeign-object-element.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gforeign-object-element.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GForeignObjectElementBuilder = exports.GForeignObjectElement = void 0;
const gshaped_prerendered_element_1 = __webpack_require__(/*! ./gshaped-prerendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshaped-prerendered-element.js");
/**
 * A `foreignObject` element to be transferred to the DOM within the SVG.
 *
 * This can be useful to to benefit from e.g. HTML rendering features, such as line wrapping, inside of
 * the SVG diagram.  Note that `foreignObject` is not supported by all browsers and SVG viewers may not
 * support rendering the `foreignObject` content.
 *
 * If no dimensions are specified in the schema element, this element will obtain the dimension of
 * its parent to fill the entire available room. Thus, this element requires specified bounds itself
 * or bounds to be available for its parent.
 */
class GForeignObjectElement extends gshaped_prerendered_element_1.GShapedPreRenderedElement {
    static builder() {
        return new GForeignObjectElementBuilder(GForeignObjectElement);
    }
}
exports.GForeignObjectElement = GForeignObjectElement;
class GForeignObjectElementBuilder extends gshaped_prerendered_element_1.GShapePreRenderedElementBuilder {
    namespace(namespace) {
        this.proxy.namespace = namespace;
        return this;
    }
}
exports.GForeignObjectElementBuilder = GForeignObjectElementBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/ggraph.js":
/*!************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/ggraph.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GGraphBuilder = exports.GGraph = void 0;
/********************************************************************************
 * Copyright (c) 2022 StMicroelectronics.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/**
 * TS implementation of the GLSP graph definition
 * (https://github.com/eclipse-glsp/glsp-server/tree/master/plugins/org.eclipse.glsp.graph/src-gen/org/eclipse/glsp/graph)
 * Parts of the implementation is derived from Sprotty's SModel API
 * (https://github.com/eclipse/sprotty/blob/master/packages/sprotty/src/base/model/smodel.ts)
 */
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gbounds_aware_1 = __webpack_require__(/*! ./gbounds-aware */ "../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js");
const glayoutable_1 = __webpack_require__(/*! ./glayoutable */ "../../node_modules/@eclipse-glsp/graph/lib/glayoutable.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
class GGraph extends gmodel_element_1.GModelRoot {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.GRAPH;
        this.position = protocol_1.Point.ORIGIN;
        this[_a] = true;
        this[_b] = true;
    }
    static builder() {
        return new GGraphBuilder(GGraph);
    }
}
exports.GGraph = GGraph;
_a = gbounds_aware_1.GBoundsAware, _b = glayoutable_1.GLayoutable;
class GGraphBuilder extends gmodel_element_1.GModelRootBuilder {
    position(positionOrX, y) {
        return gbounds_aware_1.GBoundsAwareBuilder.position(this, positionOrX, y);
    }
    size(sizeOrWidth, height) {
        return gbounds_aware_1.GBoundsAwareBuilder.size(this, sizeOrWidth, height);
    }
    addLayoutOption(key, value) {
        return glayoutable_1.GLayoutableBuilder.addLayoutOption(this, key, value);
    }
    addLayoutOptions(layoutOptions) {
        return glayoutable_1.GLayoutableBuilder.addLayoutOptions(this, layoutOptions);
    }
}
exports.GGraphBuilder = GGraphBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/ghtml-root.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/ghtml-root.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GHtmlRootBuilder = exports.GHtmlRoot = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 StMicroelectronics.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
/**
 * Root model element class for HTML content. Usually this is rendered with a `div` DOM element.
 */
class GHtmlRoot extends gmodel_element_1.GModelRoot {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.HTML;
        this.classes = [];
    }
    static builder() {
        return new GHtmlRootBuilder(GHtmlRoot);
    }
}
exports.GHtmlRoot = GHtmlRoot;
class GHtmlRootBuilder extends gmodel_element_1.GModelRootBuilder {
    addClasses(...classes) {
        (0, protocol_1.flatPush)(this.proxy.classes, classes);
        return this;
    }
}
exports.GHtmlRootBuilder = GHtmlRootBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gissue-marker.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gissue-marker.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GIssueMarkerBuilder = exports.GIssueMarker = void 0;
/********************************************************************************
 * Copyright (c) 2022-2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GIssueMarker extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.ISSUE_MARKER;
        this.issues = [];
    }
    static builder() {
        return new GIssueMarkerBuilder(GIssueMarker).type(protocol_1.DefaultTypes.ISSUE_MARKER);
    }
}
exports.GIssueMarker = GIssueMarker;
class GIssueMarkerBuilder extends gshape_element_1.GShapeElementBuilder {
    addIssue(issueOrMessage, severity) {
        if (typeof issueOrMessage === 'object') {
            this.proxy.issues.push(issueOrMessage);
        }
        else if (severity) {
            this.proxy.issues.push({ message: issueOrMessage, severity });
        }
        return this;
    }
    addIssues(...issues) {
        (0, protocol_1.flatPush)(this.proxy.issues, issues);
        return this;
    }
}
exports.GIssueMarkerBuilder = GIssueMarkerBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/glabel.js":
/*!************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/glabel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLabelBuilder = exports.GLabel = void 0;
/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const galignable_1 = __webpack_require__(/*! ./galignable */ "../../node_modules/@eclipse-glsp/graph/lib/galignable.js");
const gedge_layoutable_1 = __webpack_require__(/*! ./gedge-layoutable */ "../../node_modules/@eclipse-glsp/graph/lib/gedge-layoutable.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GLabel extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.LABEL;
        this.alignment = protocol_1.Point.ORIGIN;
        this[_a] = true;
        this[_b] = true;
    }
    static builder(constructor) {
        return new GLabelBuilder(constructor !== null && constructor !== void 0 ? constructor : GLabel).type(protocol_1.DefaultTypes.LABEL);
    }
}
exports.GLabel = GLabel;
_a = galignable_1.GAlignable, _b = gedge_layoutable_1.GEdgeLayoutable;
class GLabelBuilder extends gshape_element_1.GShapeElementBuilder {
    alignment(xOrAlign, y) {
        return galignable_1.GAlignableBuilder.alignment(this, xOrAlign, y);
    }
    text(text) {
        this.proxy.text = text;
        return this;
    }
    edgePlacement(placement) {
        return gedge_layoutable_1.GEdgeLayoutableBuilder.edgePlacement(this, placement);
    }
}
exports.GLabelBuilder = GLabelBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/glayoutable.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/glayoutable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLayoutableBuilder = exports.isGLayoutable = exports.GLayoutable = void 0;
exports.GLayoutable = Symbol('GLayoutable');
function isGLayoutable(element) {
    return exports.GLayoutable in element && element[exports.GLayoutable] === true;
}
exports.isGLayoutable = isGLayoutable;
var GLayoutableBuilder;
(function (GLayoutableBuilder) {
    function addLayoutOption(builder, key, value) {
        const proxy = builder['proxy'];
        if (!proxy.layoutOptions) {
            proxy.layoutOptions = {};
        }
        proxy.layoutOptions[key] = value;
        return builder;
    }
    GLayoutableBuilder.addLayoutOption = addLayoutOption;
    function addLayoutOptions(builder, layoutOptions) {
        const toAssign = {};
        const proxy = builder['proxy'];
        if (layoutOptions instanceof Map) {
            [...layoutOptions.keys()].forEach(key => (toAssign[key] = layoutOptions.get(key)));
        }
        else {
            Object.keys(layoutOptions).forEach(key => (toAssign[key] = layoutOptions[key]));
        }
        if (proxy.layoutOptions) {
            Object.assign(proxy.layoutOptions, toAssign);
        }
        else {
            proxy.layoutOptions = toAssign;
        }
        return builder;
    }
    GLayoutableBuilder.addLayoutOptions = addLayoutOptions;
})(GLayoutableBuilder || (exports.GLayoutableBuilder = GLayoutableBuilder = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/glayouting.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/glayouting.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLayoutingBuilder = exports.isGLayouting = exports.GLayouting = void 0;
exports.GLayouting = Symbol('GLayouting');
function isGLayouting(element) {
    return exports.GLayouting in element && element[exports.GLayouting] === true;
}
exports.isGLayouting = isGLayouting;
var GLayoutingBuilder;
(function (GLayoutingBuilder) {
    function layout(builder, newLayout) {
        builder['proxy'].layout = newLayout;
        return builder;
    }
    GLayoutingBuilder.layout = layout;
})(GLayoutingBuilder || (exports.GLayoutingBuilder = GLayoutingBuilder = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelRootBuilder = exports.GModelRoot = exports.GModelElementBuilder = exports.GModelElement = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
/**
 * Base type for all elements of the graphical model.
 * Each model element must have a unique ID and a type that is used to look up its view.
 */
class GModelElement {
    constructor() {
        /**
         * A set of css classes that should be applied to the DOM element that corresponds to this element.
         */
        this.cssClasses = [];
        /**
         * A `GModelElement can have an arbitrary amount of children. This parent-child relation ship is also reflected in
         * the corresponding DOM element i.e. DOM elements that reflect children of this element are also children
         * of the DOM element that reflects this element.
         */
        this.children = [];
    }
    /**
     * Retrieve the {@link GModelRoot} element by traversing up the parent hierachy.
     */
    get root() {
        let current = this;
        while (!(current instanceof GModelRoot)) {
            current = current.parent;
        }
        return current;
    }
}
exports.GModelElement = GModelElement;
/**
 * A fluent builder API that simplifies the construction of complex {@link GModelElement}s.
 * The builder API is derived from the Java GLSP server implementation where it is used to hide the complexity
 * of creating EMF objects. However, the API is also useful in a Typescript/Node context to declare the creation of a new
 * {@link GModelElement} in a more concise way.
 */
class GModelElementBuilder {
    constructor(elementConstructor) {
        this.elementConstructor = elementConstructor;
        this.proxy = new elementConstructor();
        this.proxy.cssClasses = [];
        this.proxy.children = [];
        this.proxy.id = uuid.v4();
    }
    reset() {
        this.proxy = new this.elementConstructor();
        return this;
    }
    build() {
        const element = new this.elementConstructor();
        Object.assign(element, this.proxy);
        element.children.forEach(child => (child.parent = element));
        if (element.id === undefined) {
            throw new Error('The `id` property of a GModelElement must not be undefined!');
        }
        if (element.type === undefined) {
            throw new Error('The `type` property of a GModelElement must not be undefined!');
        }
        return element;
    }
    id(id) {
        this.proxy.id = id;
        return this;
    }
    type(type) {
        this.proxy.type = type;
        return this;
    }
    addCssClass(cssClass) {
        this.proxy.cssClasses.push(cssClass);
        return this;
    }
    addCssClasses(...cssClasses) {
        (0, protocol_1.flatPush)(this.proxy.cssClasses, cssClasses);
        return this;
    }
    add(child) {
        this.proxy.children.push(child);
        return this;
    }
    addChildren(...children) {
        (0, protocol_1.flatPush)(this.proxy.children, children);
        return this;
    }
    addArg(key, value) {
        if (!this.proxy.args) {
            this.proxy.args = {};
        }
        this.proxy.args[key] = value;
        return this;
    }
    addArgs(args) {
        const toAssign = {};
        if (args instanceof Map) {
            [...args.keys()].forEach(key => (toAssign[key] = args.get(key)));
        }
        else {
            Object.keys(args).forEach(key => (toAssign[key] = args[key]));
        }
        if (this.proxy.args) {
            Object.assign(this.proxy.args, toAssign);
        }
        else {
            this.proxy.args = toAssign;
        }
        return this;
    }
}
exports.GModelElementBuilder = GModelElementBuilder;
class GModelRoot extends GModelElement {
    static builder() {
        return new GModelRootBuilder(GModelRoot);
    }
}
exports.GModelRoot = GModelRoot;
class GModelRootBuilder extends GModelElementBuilder {
    revision(revision) {
        this.proxy.revision = revision;
        return this;
    }
    canvasBounds(positionOrBounds, size) {
        let bounds;
        if (size) {
            bounds = { ...positionOrBounds, ...size };
        }
        else {
            bounds = positionOrBounds;
        }
        this.proxy.canvasBounds = bounds;
        return this;
    }
}
exports.GModelRootBuilder = GModelRootBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-util.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gmodel-util.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findParentByClass = exports.findParent = void 0;
/**
 * Returns the first element matching the search predicate starting from the given
 * element and walking up the parent hierarchy.
 *
 * @param element   The element to start the search from.
 * @param searchPredicate The predicate which the element should match.
 * @returns The first matching element or `undefined`.
 */
function findParent(element, searchPredicate) {
    if (!element) {
        return undefined;
    }
    if (searchPredicate(element)) {
        return element;
    }
    const parent = element.parent;
    return parent ? findParent(parent, searchPredicate) : undefined;
}
exports.findParent = findParent;
/**
 * Returns the first parent element that is an instance of the given {@link GModelElementConstructor} starting from the given element.
 * (recursively walking up the parent hierarchy).
 *
 * @param element   The element to start the search from.
 * @param constructor The queried parent class ({@link GModelElementConstructor}).
 * @returns The first matching parent element or `undefined`.
 */
function findParentByClass(element, constructor) {
    const predicate = element => element instanceof constructor;
    const result = findParent(element, predicate);
    if (result) {
        return result;
    }
    return undefined;
}
exports.findParentByClass = findParentByClass;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gnode.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gnode.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GNodeBuilder = exports.GNode = void 0;
/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gedge_layoutable_1 = __webpack_require__(/*! ./gedge-layoutable */ "../../node_modules/@eclipse-glsp/graph/lib/gedge-layoutable.js");
const glayouting_1 = __webpack_require__(/*! ./glayouting */ "../../node_modules/@eclipse-glsp/graph/lib/glayouting.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GNode extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.NODE;
        this[_a] = true;
        this[_b] = true;
    }
    static builder() {
        return new GNodeBuilder(GNode).type(protocol_1.DefaultTypes.NODE);
    }
}
exports.GNode = GNode;
_a = gedge_layoutable_1.GEdgeLayoutable, _b = glayouting_1.GLayouting;
class GNodeBuilder extends gshape_element_1.GShapeElementBuilder {
    edgePlacement(placement) {
        return gedge_layoutable_1.GEdgeLayoutableBuilder.edgePlacement(this, placement);
    }
    layout(layout) {
        return glayouting_1.GLayoutingBuilder.layout(this, layout);
    }
}
exports.GNodeBuilder = GNodeBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gport.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GPort = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gshape_element_1 = __webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js");
class GPort extends gshape_element_1.GShapeElement {
    constructor() {
        super(...arguments);
        this.type = protocol_1.DefaultTypes.PORT;
    }
    static builder() {
        return new gshape_element_1.GShapeElementBuilder(GPort).type(protocol_1.DefaultTypes.PORT);
    }
}
exports.GPort = GPort;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gpre-rendered-element.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gpre-rendered-element.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GPreRenderedElementBuilder = exports.GPreRenderedElement = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
/**
 * Pre-rendered elements contain HTML or SVG code to be transferred to the DOM. This can be useful to
 * render complex figures or to compute the view on the server instead of the client code.
 * Pre rendered elements are often used for the popup model that is created by a `PopupModelFactory`.
 * A popup model is rendered when hovering over a element and for many common use cases e.g rendering a tooltip
 * this model can be computed entirely on the server side.
 */
class GPreRenderedElement extends gmodel_element_1.GModelElement {
    static builder() {
        return new GPreRenderedElementBuilder(GPreRenderedElement).type(protocol_1.DefaultTypes.PRE_RENDERED);
    }
}
exports.GPreRenderedElement = GPreRenderedElement;
class GPreRenderedElementBuilder extends gmodel_element_1.GModelElementBuilder {
    code(code) {
        this.proxy.code = code;
        return this;
    }
}
exports.GPreRenderedElementBuilder = GPreRenderedElementBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gresizable.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gresizable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GResizeLocation = exports.GResizableBuilder = exports.isGResizable = exports.GResizable = void 0;
exports.GResizable = Symbol('GResizable');
function isGResizable(element) {
    return exports.GResizable in element && element[exports.GResizable] === true;
}
exports.isGResizable = isGResizable;
var GResizableBuilder;
(function (GResizableBuilder) {
    function resizeLocations(builder, resizeLocations) {
        const proxy = builder['proxy'];
        proxy.resizeLocations = resizeLocations;
        return builder;
    }
    GResizableBuilder.resizeLocations = resizeLocations;
})(GResizableBuilder || (exports.GResizableBuilder = GResizableBuilder = {}));
var GResizeLocation;
(function (GResizeLocation) {
    GResizeLocation["TopLeft"] = "top-left";
    GResizeLocation["Top"] = "top";
    GResizeLocation["TopRight"] = "top-right";
    GResizeLocation["Right"] = "right";
    GResizeLocation["BottomRight"] = "bottom-right";
    GResizeLocation["Bottom"] = "bottom";
    GResizeLocation["BottomLeft"] = "bottom-left";
    GResizeLocation["Left"] = "left";
})(GResizeLocation || (exports.GResizeLocation = GResizeLocation = {}));
(function (GResizeLocation) {
    GResizeLocation.CORNERS = [
        GResizeLocation.TopLeft,
        GResizeLocation.TopRight,
        GResizeLocation.BottomRight,
        GResizeLocation.BottomLeft
    ];
    GResizeLocation.CROSS = [GResizeLocation.Top, GResizeLocation.Right, GResizeLocation.Bottom, GResizeLocation.Left];
    GResizeLocation.ALL = [...GResizeLocation.CORNERS, ...GResizeLocation.CROSS];
})(GResizeLocation || (exports.GResizeLocation = GResizeLocation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GShapeElementBuilder = exports.GShapeElement = void 0;
const gbounds_aware_1 = __webpack_require__(/*! ./gbounds-aware */ "../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js");
const glayoutable_1 = __webpack_require__(/*! ./glayoutable */ "../../node_modules/@eclipse-glsp/graph/lib/glayoutable.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
const gresizable_1 = __webpack_require__(/*! ./gresizable */ "../../node_modules/@eclipse-glsp/graph/lib/gresizable.js");
class GShapeElement extends gmodel_element_1.GModelElement {
    constructor() {
        super(...arguments);
        this[_a] = true;
        this[_b] = true;
        this[_c] = true;
    }
}
exports.GShapeElement = GShapeElement;
_a = gbounds_aware_1.GBoundsAware, _b = glayoutable_1.GLayoutable, _c = gresizable_1.GResizable;
class GShapeElementBuilder extends gmodel_element_1.GModelElementBuilder {
    position(pointOrX, y) {
        return gbounds_aware_1.GBoundsAwareBuilder.position(this, pointOrX, y);
    }
    size(sizeOrWidth, height) {
        return gbounds_aware_1.GBoundsAwareBuilder.size(this, sizeOrWidth, height);
    }
    addLayoutOption(key, value) {
        return glayoutable_1.GLayoutableBuilder.addLayoutOption(this, key, value);
    }
    addLayoutOptions(layoutOptions) {
        return glayoutable_1.GLayoutableBuilder.addLayoutOptions(this, layoutOptions);
    }
    resizeLocations(resizeLocations) {
        return gresizable_1.GResizableBuilder.resizeLocations(this, resizeLocations);
    }
}
exports.GShapeElementBuilder = GShapeElementBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/gshaped-prerendered-element.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/gshaped-prerendered-element.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GShapePreRenderedElementBuilder = exports.GShapedPreRenderedElement = void 0;
const galignable_1 = __webpack_require__(/*! ./galignable */ "../../node_modules/@eclipse-glsp/graph/lib/galignable.js");
const gbounds_aware_1 = __webpack_require__(/*! ./gbounds-aware */ "../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js");
const gmodel_element_1 = __webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
const gpre_rendered_element_1 = __webpack_require__(/*! ./gpre-rendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gpre-rendered-element.js");
/**
 * Pre-rendered elements contain HTML or SVG code to be transferred to the DOM. This can be useful to
 * render complex figures or to compute the view on the server instead of the client code.
 * Pre rendered elements are often used for the popup model that is created by a `PopupModelFactory`.
 * A popup model is rendered when hovering over a element and for many common use cases e.g rendering a tooltip
 * this model can be computed entirely on the server side.
 */
class GShapedPreRenderedElement extends gpre_rendered_element_1.GPreRenderedElement {
    constructor() {
        super(...arguments);
        this[_a] = true;
        this[_b] = true;
    }
    static builder() {
        return new GShapePreRenderedElementBuilder(GShapedPreRenderedElement);
    }
}
exports.GShapedPreRenderedElement = GShapedPreRenderedElement;
_a = gbounds_aware_1.GBoundsAware, _b = galignable_1.GAlignable;
class GShapePreRenderedElementBuilder extends gmodel_element_1.GModelElementBuilder {
    code(code) {
        this.proxy.code = code;
        return this;
    }
    position(pointOrX, y) {
        return gbounds_aware_1.GBoundsAwareBuilder.position(this, pointOrX, y);
    }
    size(sizeOrWidth, height) {
        return gbounds_aware_1.GBoundsAwareBuilder.size(this, sizeOrWidth, height);
    }
}
exports.GShapePreRenderedElementBuilder = GShapePreRenderedElementBuilder;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/graph/lib/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/graph/lib/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
__exportStar(__webpack_require__(/*! ./default-types */ "../../node_modules/@eclipse-glsp/graph/lib/default-types.js"), exports);
__exportStar(__webpack_require__(/*! ./galignable */ "../../node_modules/@eclipse-glsp/graph/lib/galignable.js"), exports);
__exportStar(__webpack_require__(/*! ./gbounds-aware */ "../../node_modules/@eclipse-glsp/graph/lib/gbounds-aware.js"), exports);
__exportStar(__webpack_require__(/*! ./gbutton */ "../../node_modules/@eclipse-glsp/graph/lib/gbutton.js"), exports);
__exportStar(__webpack_require__(/*! ./gcompartment */ "../../node_modules/@eclipse-glsp/graph/lib/gcompartment.js"), exports);
__exportStar(__webpack_require__(/*! ./gedge */ "../../node_modules/@eclipse-glsp/graph/lib/gedge.js"), exports);
__exportStar(__webpack_require__(/*! ./gedge-layoutable */ "../../node_modules/@eclipse-glsp/graph/lib/gedge-layoutable.js"), exports);
__exportStar(__webpack_require__(/*! ./gforeign-object-element */ "../../node_modules/@eclipse-glsp/graph/lib/gforeign-object-element.js"), exports);
__exportStar(__webpack_require__(/*! ./ggraph */ "../../node_modules/@eclipse-glsp/graph/lib/ggraph.js"), exports);
__exportStar(__webpack_require__(/*! ./ghtml-root */ "../../node_modules/@eclipse-glsp/graph/lib/ghtml-root.js"), exports);
__exportStar(__webpack_require__(/*! ./gissue-marker */ "../../node_modules/@eclipse-glsp/graph/lib/gissue-marker.js"), exports);
__exportStar(__webpack_require__(/*! ./glabel */ "../../node_modules/@eclipse-glsp/graph/lib/glabel.js"), exports);
__exportStar(__webpack_require__(/*! ./glayoutable */ "../../node_modules/@eclipse-glsp/graph/lib/glayoutable.js"), exports);
__exportStar(__webpack_require__(/*! ./glayouting */ "../../node_modules/@eclipse-glsp/graph/lib/glayouting.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel-util */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-util.js"), exports);
__exportStar(__webpack_require__(/*! ./gnode */ "../../node_modules/@eclipse-glsp/graph/lib/gnode.js"), exports);
__exportStar(__webpack_require__(/*! ./gport */ "../../node_modules/@eclipse-glsp/graph/lib/gport.js"), exports);
__exportStar(__webpack_require__(/*! ./gpre-rendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gpre-rendered-element.js"), exports);
__exportStar(__webpack_require__(/*! ./gresizable */ "../../node_modules/@eclipse-glsp/graph/lib/gresizable.js"), exports);
__exportStar(__webpack_require__(/*! ./gshape-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshape-element.js"), exports);
__exportStar(__webpack_require__(/*! ./gshaped-prerendered-element */ "../../node_modules/@eclipse-glsp/graph/lib/gshaped-prerendered-element.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompoundOperation = exports.Operation = exports.RejectAction = exports.ResponseAction = exports.RequestAction = exports.ActionMessage = exports.Action = void 0;
/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty = __webpack_require__(/*! sprotty-protocol/lib/actions */ "../../node_modules/sprotty-protocol/lib/actions.js");
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
var Action;
(function (Action) {
    function is(object) {
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, 'kind');
    }
    Action.is = is;
    /**
     * Typeguard function to check wether the given object is an {@link Action} with the given `kind`.
     * @param object The object to check.
     * @param kind  The expected action kind.
     * @returns A type literal indicating wether the given object is an action with the given kind.
     */
    function hasKind(object, kind) {
        return Action.is(object) && object.kind === kind;
    }
    Action.hasKind = hasKind;
})(Action || (exports.Action = Action = {}));
var ActionMessage;
(function (ActionMessage) {
    function is(object, typeguard) {
        const actionGuard = typeguard !== null && typeguard !== void 0 ? typeguard : Action.is;
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, 'clientId') && 'action' in object && actionGuard(object.action);
    }
    ActionMessage.is = is;
})(ActionMessage || (exports.ActionMessage = ActionMessage = {}));
var RequestAction;
(function (RequestAction) {
    function is(object) {
        return Action.is(object) && (0, type_util_1.hasStringProp)(object, 'requestId');
    }
    RequestAction.is = is;
    /**
     * Typeguard function to check wether the given object is an {@link RequestAction} with the given `kind`.
     * @param object The object to check.
     * @param kind  The expected action kind.
     * @returns A type literal indicating wether the given object is a request action with the given kind.
     */
    function hasKind(object, kind) {
        return RequestAction.is(object) && object.kind === kind;
    }
    RequestAction.hasKind = hasKind;
    function generateRequestId() {
        return sprotty.generateRequestId();
    }
    RequestAction.generateRequestId = generateRequestId;
})(RequestAction || (exports.RequestAction = RequestAction = {}));
var ResponseAction;
(function (ResponseAction) {
    function is(object) {
        return Action.is(object) && (0, type_util_1.hasStringProp)(object, 'responseId');
    }
    ResponseAction.is = is;
    /**
     * Typeguard function to check wether the given object is an {@link ResponseAction} with a non-empty response id.
     * @param object The object to check.
     * @returns A type literal indicating wether the given object is a response action with a non-empty response id.
     */
    function hasValidResponseId(object) {
        return ResponseAction.is(object) && object.responseId !== '';
    }
    ResponseAction.hasValidResponseId = hasValidResponseId;
})(ResponseAction || (exports.ResponseAction = ResponseAction = {}));
var RejectAction;
(function (RejectAction) {
    RejectAction.KIND = 'rejectRequest';
    function is(object) {
        return Action.hasKind(object, RejectAction.KIND) && (0, type_util_1.hasStringProp)(object, 'message');
    }
    RejectAction.is = is;
    function create(message, options = {}) {
        return {
            kind: RejectAction.KIND,
            responseId: '',
            message,
            ...options
        };
    }
    RejectAction.create = create;
})(RejectAction || (exports.RejectAction = RejectAction = {}));
var Operation;
(function (Operation) {
    function is(object) {
        return Action.is(object) && 'isOperation' in object && object.isOperation === true;
    }
    Operation.is = is;
    /**
     * Typeguard function to check wether the given object is an {@link Operation} with the given `kind`.
     * @param object The object to check.
     * @param kind  The expected operation kind.
     * @returns A type literal indicating wether the given object is an operation with the given kind.
     */
    function hasKind(object, kind) {
        return Operation.is(object) && object.kind === kind;
    }
    Operation.hasKind = hasKind;
})(Operation || (exports.Operation = Operation = {}));
var CompoundOperation;
(function (CompoundOperation) {
    CompoundOperation.KIND = 'compound';
    function is(object) {
        return Operation.hasKind(object, CompoundOperation.KIND) && (0, type_util_1.hasArrayProp)(object, 'operationList');
    }
    CompoundOperation.is = is;
    function create(operationList, options = {}) {
        return {
            kind: CompoundOperation.KIND,
            isOperation: true,
            operationList,
            ...options
        };
    }
    CompoundOperation.create = create;
})(CompoundOperation || (exports.CompoundOperation = CompoundOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndProgressAction = exports.UpdateProgressAction = exports.StartProgressAction = exports.MessageAction = exports.StatusAction = void 0;
/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var StatusAction;
(function (StatusAction) {
    StatusAction.KIND = 'status';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, StatusAction.KIND) && (0, type_util_1.hasStringProp)(object, 'severity') && (0, type_util_1.hasStringProp)(object, 'message');
    }
    StatusAction.is = is;
    function create(message, options = {}) {
        return {
            kind: StatusAction.KIND,
            severity: 'INFO',
            message,
            ...options
        };
    }
    StatusAction.create = create;
})(StatusAction || (exports.StatusAction = StatusAction = {}));
var MessageAction;
(function (MessageAction) {
    MessageAction.KIND = 'message';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, MessageAction.KIND) && (0, type_util_1.hasStringProp)(object, 'message') && (0, type_util_1.hasStringProp)(object, 'severity');
    }
    MessageAction.is = is;
    function create(message, options = {}) {
        return {
            kind: MessageAction.KIND,
            message,
            severity: 'INFO',
            ...options
        };
    }
    MessageAction.create = create;
})(MessageAction || (exports.MessageAction = MessageAction = {}));
var StartProgressAction;
(function (StartProgressAction) {
    StartProgressAction.KIND = 'startProgress';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, StartProgressAction.KIND) && (0, type_util_1.hasStringProp)(object, 'progressId') && (0, type_util_1.hasStringProp)(object, 'title');
    }
    StartProgressAction.is = is;
    function create(options) {
        return {
            kind: StartProgressAction.KIND,
            ...options
        };
    }
    StartProgressAction.create = create;
})(StartProgressAction || (exports.StartProgressAction = StartProgressAction = {}));
var UpdateProgressAction;
(function (UpdateProgressAction) {
    UpdateProgressAction.KIND = 'updateProgress';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, UpdateProgressAction.KIND) && (0, type_util_1.hasStringProp)(object, 'progressId');
    }
    UpdateProgressAction.is = is;
    function create(progressId, options = {}) {
        return {
            kind: UpdateProgressAction.KIND,
            progressId,
            ...options
        };
    }
    UpdateProgressAction.create = create;
})(UpdateProgressAction || (exports.UpdateProgressAction = UpdateProgressAction = {}));
var EndProgressAction;
(function (EndProgressAction) {
    EndProgressAction.KIND = 'endProgress';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, EndProgressAction.KIND) && (0, type_util_1.hasStringProp)(object, 'progressId');
    }
    EndProgressAction.is = is;
    function create(progressId, message) {
        return {
            kind: EndProgressAction.KIND,
            progressId,
            message
        };
    }
    EndProgressAction.create = create;
})(EndProgressAction || (exports.EndProgressAction = EndProgressAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PasteOperation = exports.CutOperation = exports.SetClipboardDataAction = exports.RequestClipboardDataAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestClipboardDataAction;
(function (RequestClipboardDataAction) {
    RequestClipboardDataAction.KIND = 'requestClipboardData';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestClipboardDataAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'editorContext');
    }
    RequestClipboardDataAction.is = is;
    function create(editorContext, options = {}) {
        return {
            kind: RequestClipboardDataAction.KIND,
            requestId: '',
            editorContext,
            ...options
        };
    }
    RequestClipboardDataAction.create = create;
})(RequestClipboardDataAction || (exports.RequestClipboardDataAction = RequestClipboardDataAction = {}));
var SetClipboardDataAction;
(function (SetClipboardDataAction) {
    SetClipboardDataAction.KIND = 'setClipboardData';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetClipboardDataAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'clipboardData');
    }
    SetClipboardDataAction.is = is;
    function create(clipboardData, options = {}) {
        return {
            kind: SetClipboardDataAction.KIND,
            responseId: '',
            clipboardData,
            ...options
        };
    }
    SetClipboardDataAction.create = create;
})(SetClipboardDataAction || (exports.SetClipboardDataAction = SetClipboardDataAction = {}));
var CutOperation;
(function (CutOperation) {
    CutOperation.KIND = 'cut';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, CutOperation.KIND) && (0, type_util_1.hasObjectProp)(object, 'editorContext');
    }
    CutOperation.is = is;
    function create(editorContext, options = {}) {
        return {
            kind: CutOperation.KIND,
            isOperation: true,
            editorContext,
            ...options
        };
    }
    CutOperation.create = create;
})(CutOperation || (exports.CutOperation = CutOperation = {}));
var PasteOperation;
(function (PasteOperation) {
    PasteOperation.KIND = 'paste';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, PasteOperation.KIND) && (0, type_util_1.hasObjectProp)(object, 'clipboardData') && (0, type_util_1.hasObjectProp)(object, 'editorContext');
    }
    PasteOperation.is = is;
    function create(options) {
        return {
            kind: PasteOperation.KIND,
            isOperation: true,
            ...options
        };
    }
    PasteOperation.create = create;
})(PasteOperation || (exports.PasteOperation = PasteOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetContextActions = exports.RequestContextActions = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestContextActions;
(function (RequestContextActions) {
    RequestContextActions.KIND = 'requestContextActions';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestContextActions.KIND) && (0, type_util_1.hasStringProp)(object, 'contextId') && (0, type_util_1.hasObjectProp)(object, 'editorContext');
    }
    RequestContextActions.is = is;
    function create(options) {
        return {
            kind: RequestContextActions.KIND,
            requestId: '',
            ...options
        };
    }
    RequestContextActions.create = create;
})(RequestContextActions || (exports.RequestContextActions = RequestContextActions = {}));
var SetContextActions;
(function (SetContextActions) {
    SetContextActions.KIND = 'setContextActions';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetContextActions.KIND) && (0, type_util_1.hasArrayProp)(object, 'actions');
    }
    SetContextActions.is = is;
    function create(actions, options = {}) {
        return {
            kind: SetContextActions.KIND,
            responseId: '',
            actions,
            ...options
        };
    }
    SetContextActions.create = create;
})(SetContextActions || (exports.SetContextActions = SetContextActions = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeRoutingPointsOperation = exports.ReconnectEdgeOperation = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var ReconnectEdgeOperation;
(function (ReconnectEdgeOperation) {
    ReconnectEdgeOperation.KIND = 'reconnectEdge';
    function is(object) {
        return (base_protocol_1.Operation.hasKind(object, ReconnectEdgeOperation.KIND) &&
            (0, type_util_1.hasStringProp)(object, 'edgeElementId') &&
            (0, type_util_1.hasStringProp)(object, 'sourceElementId') &&
            (0, type_util_1.hasStringProp)(object, 'targetElementId'));
    }
    ReconnectEdgeOperation.is = is;
    function create(options) {
        return {
            kind: ReconnectEdgeOperation.KIND,
            isOperation: true,
            ...options
        };
    }
    ReconnectEdgeOperation.create = create;
})(ReconnectEdgeOperation || (exports.ReconnectEdgeOperation = ReconnectEdgeOperation = {}));
var ChangeRoutingPointsOperation;
(function (ChangeRoutingPointsOperation) {
    ChangeRoutingPointsOperation.KIND = 'changeRoutingPoints';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, ChangeRoutingPointsOperation.KIND) && (0, type_util_1.hasArrayProp)(object, 'newRoutingPoints');
    }
    ChangeRoutingPointsOperation.is = is;
    function create(newRoutingPoints, options = {}) {
        return {
            kind: ChangeRoutingPointsOperation.KIND,
            isOperation: true,
            newRoutingPoints,
            ...options
        };
    }
    ChangeRoutingPointsOperation.create = create;
})(ChangeRoutingPointsOperation || (exports.ChangeRoutingPointsOperation = ChangeRoutingPointsOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteElementOperation = exports.CreateEdgeOperation = exports.CreateNodeOperation = exports.CreateOperation = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var CreateOperation;
(function (CreateOperation) {
    function is(object) {
        return base_protocol_1.Operation.is(object) && (0, type_util_1.hasStringProp)(object, 'elementTypeId');
    }
    CreateOperation.is = is;
    /**
     * Typeguard function to check wether the given object is a {@link CreateOperation} with the given `kind`.
     * @param object The object to check.
     * @param kind  The expected operation kind.
     * @returns A type literal indicating wether the given object is a create operation with the given kind.
     */
    function hasKind(object, kind) {
        return CreateOperation.is(object) && object.kind === kind;
    }
    CreateOperation.hasKind = hasKind;
})(CreateOperation || (exports.CreateOperation = CreateOperation = {}));
var CreateNodeOperation;
(function (CreateNodeOperation) {
    CreateNodeOperation.KIND = 'createNode';
    function is(object) {
        return CreateOperation.hasKind(object, CreateNodeOperation.KIND);
    }
    CreateNodeOperation.is = is;
    function create(elementTypeId, options = {}) {
        return {
            kind: CreateNodeOperation.KIND,
            isOperation: true,
            elementTypeId,
            ...options
        };
    }
    CreateNodeOperation.create = create;
})(CreateNodeOperation || (exports.CreateNodeOperation = CreateNodeOperation = {}));
var CreateEdgeOperation;
(function (CreateEdgeOperation) {
    CreateEdgeOperation.KIND = 'createEdge';
    function is(object) {
        return (CreateOperation.hasKind(object, CreateEdgeOperation.KIND) && (0, type_util_1.hasStringProp)(object, 'sourceElementId') && (0, type_util_1.hasStringProp)(object, 'targetElementId'));
    }
    CreateEdgeOperation.is = is;
    function create(options) {
        return {
            kind: CreateEdgeOperation.KIND,
            isOperation: true,
            ...options
        };
    }
    CreateEdgeOperation.create = create;
})(CreateEdgeOperation || (exports.CreateEdgeOperation = CreateEdgeOperation = {}));
var DeleteElementOperation;
(function (DeleteElementOperation) {
    DeleteElementOperation.KIND = 'deleteElement';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, DeleteElementOperation.KIND) && (0, type_util_1.hasArrayProp)(object, 'elementIds');
    }
    DeleteElementOperation.is = is;
    function create(elementIds, options = {}) {
        return {
            kind: DeleteElementOperation.KIND,
            isOperation: true,
            elementIds,
            ...options
        };
    }
    DeleteElementOperation.create = create;
})(DeleteElementOperation || (exports.DeleteElementOperation = DeleteElementOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPopupModelAction = exports.RequestPopupModelAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestPopupModelAction;
(function (RequestPopupModelAction) {
    RequestPopupModelAction.KIND = 'requestPopupModel';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestPopupModelAction.KIND) && (0, type_util_1.hasStringProp)(object, 'elementId') && (0, type_util_1.hasObjectProp)(object, 'bounds');
    }
    RequestPopupModelAction.is = is;
    function create(options) {
        return {
            kind: RequestPopupModelAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestPopupModelAction.create = create;
})(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
var SetPopupModelAction;
(function (SetPopupModelAction) {
    SetPopupModelAction.KIND = 'setPopupModel';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetPopupModelAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'newRoot');
    }
    SetPopupModelAction.is = is;
    function create(newRoot, options = {}) {
        return {
            kind: SetPopupModelAction.KIND,
            responseId: '',
            newRoot,
            ...options
        };
    }
    SetPopupModelAction.create = create;
})(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigateToExternalTargetAction = exports.SetResolvedNavigationTargetAction = exports.ResolveNavigationTargetAction = exports.NavigateToTargetAction = exports.SetNavigationTargetsAction = exports.RequestNavigationTargetsAction = exports.NavigationTarget = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var NavigationTarget;
(function (NavigationTarget) {
    function is(object) {
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, 'uri');
    }
    NavigationTarget.is = is;
    /**
     *  Generic key to store element ids as additional argument
     */
    NavigationTarget.ELEMENT_IDS = 'elementIds';
    /**
     * The separator that is used to store he values for the {@link ELEMENT_IDS} as a single string.
     */
    NavigationTarget.ELEMENT_IDS_SEPARATOR = '&';
    /**
     *  Generic key ot store the line property of a {@link TextPosition} as additional argument.
     */
    NavigationTarget.TEXT_LINE = 'line';
    /**
     *  Generic key ot store the character property of a {@link TextPosition} as additional argument.
     */
    NavigationTarget.TEXT_COLUMN = 'column';
    /**
     * Utility function to check wether the given {@link NavigationTarget} has additional arguments defined.
     * @param target The navigation target to check.
     * @returns `true` if the navigation target has a non-empty `args` property, `false`
     */
    function hasArguments(target) {
        return target.args !== undefined && Object.keys(target.args).length > 0;
    }
    NavigationTarget.hasArguments = hasArguments;
    /**
     * Adds a new key-value pair to the additional arguments of the given {@link NavigationTarget}.
     * @param target The navigation target.
     * @param key The key of the new argument.
     * @param value The (primitive) value of the new argument.
     */
    function addArgument(target, key, value) {
        if (!target.args) {
            target.args = {};
        }
        target.args[key] = value;
    }
    NavigationTarget.addArgument = addArgument;
    /**
     * Retrieves the element ids that have been stored with the generic {@link ELEMENT_IDS} key from the args of the
     * given target.
     * @param target The navigation target.
     * @returns An array with the parsed element ids. The array is empty if no {@link ELEMENT_IDS} key is present in the args
     * of the navigation target.
     */
    function getElementIds(target) {
        var _a;
        if (!((_a = target === null || target === void 0 ? void 0 : target.args) === null || _a === void 0 ? void 0 : _a[NavigationTarget.ELEMENT_IDS])) {
            return [];
        }
        const elementIdsValue = target.args[NavigationTarget.ELEMENT_IDS].toString();
        return elementIdsValue.split(NavigationTarget.ELEMENT_IDS_SEPARATOR);
    }
    NavigationTarget.getElementIds = getElementIds;
    /**
     * Stores the given element ids in the given {@link NavigationTarget} as additional arguments using the generic {@link ELEMENT_IDS} key.
     * @param target The navigation target.
     * @param elementIds The element ids that should be stored.
     * @returns the value of the {@link ELEMENT_IDS} key after storing the given element ids.
     */
    function setElementIds(target, ...elementIds) {
        if (target.args === undefined) {
            target.args = {};
        }
        return (target.args[NavigationTarget.ELEMENT_IDS] = elementIds.join(NavigationTarget.ELEMENT_IDS_SEPARATOR));
    }
    NavigationTarget.setElementIds = setElementIds;
    /**
     * Stores the given {@link TextPosition} in the given {@link NavigationTarget} as additional arguments using
     * the generic {@link TEXT_LINE} & {@link TEXT_COLUMN} keys.
     * @param target The navigation target.
     * @param position The text position that should be stored.
     */
    function setTextPosition(target, position) {
        if (position) {
            if (target.args === undefined) {
                target.args = {};
            }
            target.args[NavigationTarget.TEXT_LINE] = position.line;
            target.args[NavigationTarget.TEXT_COLUMN] = position.character;
        }
    }
    NavigationTarget.setTextPosition = setTextPosition;
    /**
     * Retrieves the {@link TextPosition} that have been stored with the generic {@link TEXT_LINE} & {@link TEXT_COLUMN} keys
     * from the args of the given target.
     * @param target The navigation target.
     * @returns The parsed text position or `undefined` if one of the generic text keys is not present in the args
     * of the navigation target.
     */
    function getTextPosition(target) {
        if (!target.args || !target.args[NavigationTarget.TEXT_LINE] || !target.args[NavigationTarget.TEXT_COLUMN]) {
            return undefined;
        }
        return {
            line: Number(target.args[NavigationTarget.TEXT_LINE]),
            character: Number(target.args[NavigationTarget.TEXT_COLUMN])
        };
    }
    NavigationTarget.getTextPosition = getTextPosition;
})(NavigationTarget || (exports.NavigationTarget = NavigationTarget = {}));
var RequestNavigationTargetsAction;
(function (RequestNavigationTargetsAction) {
    RequestNavigationTargetsAction.KIND = 'requestNavigationTargets';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestNavigationTargetsAction.KIND) && (0, type_util_1.hasStringProp)(object, 'targetTypeId') && (0, type_util_1.hasObjectProp)(object, 'editorContext');
    }
    RequestNavigationTargetsAction.is = is;
    function create(options) {
        return {
            kind: RequestNavigationTargetsAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestNavigationTargetsAction.create = create;
})(RequestNavigationTargetsAction || (exports.RequestNavigationTargetsAction = RequestNavigationTargetsAction = {}));
var SetNavigationTargetsAction;
(function (SetNavigationTargetsAction) {
    SetNavigationTargetsAction.KIND = 'setNavigationTargets';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetNavigationTargetsAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'targets');
    }
    SetNavigationTargetsAction.is = is;
    function create(targets, options = {}) {
        return {
            kind: SetNavigationTargetsAction.KIND,
            responseId: '',
            targets,
            ...options
        };
    }
    SetNavigationTargetsAction.create = create;
})(SetNavigationTargetsAction || (exports.SetNavigationTargetsAction = SetNavigationTargetsAction = {}));
var NavigateToTargetAction;
(function (NavigateToTargetAction) {
    NavigateToTargetAction.KIND = 'navigateToTarget';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, NavigateToTargetAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'target');
    }
    NavigateToTargetAction.is = is;
    function create(target) {
        return {
            kind: NavigateToTargetAction.KIND,
            target
        };
    }
    NavigateToTargetAction.create = create;
})(NavigateToTargetAction || (exports.NavigateToTargetAction = NavigateToTargetAction = {}));
var ResolveNavigationTargetAction;
(function (ResolveNavigationTargetAction) {
    ResolveNavigationTargetAction.KIND = 'resolveNavigationTarget';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, ResolveNavigationTargetAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'navigationTarget');
    }
    ResolveNavigationTargetAction.is = is;
    function create(navigationTarget, options = {}) {
        return {
            kind: ResolveNavigationTargetAction.KIND,
            requestId: '',
            navigationTarget,
            ...options
        };
    }
    ResolveNavigationTargetAction.create = create;
})(ResolveNavigationTargetAction || (exports.ResolveNavigationTargetAction = ResolveNavigationTargetAction = {}));
var SetResolvedNavigationTargetAction;
(function (SetResolvedNavigationTargetAction) {
    SetResolvedNavigationTargetAction.KIND = 'setResolvedNavigationTarget';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetResolvedNavigationTargetAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'elementIds');
    }
    SetResolvedNavigationTargetAction.is = is;
    function create(elementIds, options = {}) {
        return {
            kind: SetResolvedNavigationTargetAction.KIND,
            responseId: '',
            elementIds,
            ...options
        };
    }
    SetResolvedNavigationTargetAction.create = create;
})(SetResolvedNavigationTargetAction || (exports.SetResolvedNavigationTargetAction = SetResolvedNavigationTargetAction = {}));
var NavigateToExternalTargetAction;
(function (NavigateToExternalTargetAction) {
    NavigateToExternalTargetAction.KIND = 'navigateToExternalTarget';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, NavigateToExternalTargetAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'target');
    }
    NavigateToExternalTargetAction.is = is;
    function create(target) {
        return {
            kind: NavigateToExternalTargetAction.KIND,
            target
        };
    }
    NavigateToExternalTargetAction.create = create;
})(NavigateToExternalTargetAction || (exports.NavigateToExternalTargetAction = NavigateToExternalTargetAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectAllAction = exports.SelectAction = void 0;
const array_util_1 = __webpack_require__(/*! ../utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var SelectAction;
(function (SelectAction) {
    SelectAction.KIND = 'elementSelected';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SelectAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'selectedElementsIDs') && (0, type_util_1.hasArrayProp)(object, 'deselectedElementsIDs');
    }
    SelectAction.is = is;
    function create(options = {}) {
        var _a, _b;
        const deselectedElementsIDs = (_a = options.deselectedElementsIDs) !== null && _a !== void 0 ? _a : [];
        return {
            kind: SelectAction.KIND,
            selectedElementsIDs: (_b = options.selectedElementsIDs) !== null && _b !== void 0 ? _b : [],
            deselectedElementsIDs: (0, array_util_1.isStringArray)(deselectedElementsIDs, true) ? deselectedElementsIDs : [],
            deselectAll: typeof deselectedElementsIDs === 'boolean' ? deselectedElementsIDs : false
        };
    }
    SelectAction.create = create;
    function addSelection(selectedElementsIDs) {
        return create({ selectedElementsIDs });
    }
    SelectAction.addSelection = addSelection;
    function removeSelection(deselectedElementsIDs) {
        return create({ deselectedElementsIDs });
    }
    SelectAction.removeSelection = removeSelection;
    function setSelection(selectedElementsIDs) {
        return create({ selectedElementsIDs, deselectedElementsIDs: true });
    }
    SelectAction.setSelection = setSelection;
})(SelectAction || (exports.SelectAction = SelectAction = {}));
var SelectAllAction;
(function (SelectAllAction) {
    SelectAllAction.KIND = 'allSelected';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SelectAllAction.KIND) && (0, type_util_1.hasBooleanProp)(object, 'select');
    }
    SelectAllAction.is = is;
    function create(select = true) {
        return {
            kind: SelectAllAction.KIND,
            select
        };
    }
    SelectAllAction.create = create;
})(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationStatus = exports.ApplyLabelEditOperation = exports.SetEditValidationResultAction = exports.RequestEditValidationAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestEditValidationAction;
(function (RequestEditValidationAction) {
    RequestEditValidationAction.KIND = 'requestEditValidation';
    function is(object) {
        return (base_protocol_1.RequestAction.hasKind(object, RequestEditValidationAction.KIND) &&
            (0, type_util_1.hasStringProp)(object, 'contextId') &&
            (0, type_util_1.hasStringProp)(object, 'modelElementId') &&
            (0, type_util_1.hasStringProp)(object, 'text'));
    }
    RequestEditValidationAction.is = is;
    function create(options) {
        return {
            kind: RequestEditValidationAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestEditValidationAction.create = create;
})(RequestEditValidationAction || (exports.RequestEditValidationAction = RequestEditValidationAction = {}));
var SetEditValidationResultAction;
(function (SetEditValidationResultAction) {
    SetEditValidationResultAction.KIND = 'setEditValidationResult';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetEditValidationResultAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'status');
    }
    SetEditValidationResultAction.is = is;
    function create(status, options = {}) {
        return {
            kind: SetEditValidationResultAction.KIND,
            responseId: '',
            status,
            ...options
        };
    }
    SetEditValidationResultAction.create = create;
})(SetEditValidationResultAction || (exports.SetEditValidationResultAction = SetEditValidationResultAction = {}));
var ApplyLabelEditOperation;
(function (ApplyLabelEditOperation) {
    ApplyLabelEditOperation.KIND = 'applyLabelEdit';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, ApplyLabelEditOperation.KIND) && (0, type_util_1.hasStringProp)(object, 'labelId') && (0, type_util_1.hasStringProp)(object, 'text');
    }
    ApplyLabelEditOperation.is = is;
    function create(options) {
        return {
            kind: ApplyLabelEditOperation.KIND,
            isOperation: true,
            ...options
        };
    }
    ApplyLabelEditOperation.create = create;
})(ApplyLabelEditOperation || (exports.ApplyLabelEditOperation = ApplyLabelEditOperation = {}));
var ValidationStatus;
(function (ValidationStatus) {
    /**
     * The default {@link ValidationStatus} severity levels used in GLSP.
     */
    let Severity;
    (function (Severity) {
        Severity[Severity["FATAL"] = 0] = "FATAL";
        Severity[Severity["ERROR"] = 1] = "ERROR";
        Severity[Severity["WARNING"] = 2] = "WARNING";
        Severity[Severity["INFO"] = 3] = "INFO";
        Severity[Severity["OK"] = 4] = "OK";
        Severity[Severity["NONE"] = 5] = "NONE";
    })(Severity = ValidationStatus.Severity || (ValidationStatus.Severity = {}));
    /**
     * An empty {@link ValidationStatus}.
     */
    ValidationStatus.NONE = {
        severity: Severity.NONE,
        message: '',
        error: { code: -1, message: '', data: {} }
    };
    /**
     * Utility function to check wether the given {@link ValidationStatus} has
     * a severity that is considered to be OK.
     * @param validationStatus The validation status to check.
     * @returns `true` if the given status has a non critical severity, `false` otherwise.
     */
    function isOk(validationStatus) {
        return (validationStatus.severity === Severity.OK ||
            validationStatus.severity === Severity.INFO ||
            validationStatus.severity === Severity.NONE);
    }
    ValidationStatus.isOk = isOk;
    /**
     * Utility function to check wether the given {@link ValidationStatus} has
     * a `warning` severity.
     * @param validationStatus The validation status to check.
     * @returns `true` if the given status has a `warning` severity, `false` otherwise.
     */
    function isWarning(validationStatus) {
        return validationStatus.severity === Severity.WARNING;
    }
    ValidationStatus.isWarning = isWarning;
    /**
     * Utility function to check wether the given {@link ValidationStatus} has
     * an `error` or `fatal` severity.
     * @param validationStatus The validation status to check.
     * @returns `true` if the given status has a `error` or `fatal` severity, `false` otherwise.
     */
    function isError(validationStatus) {
        return validationStatus.severity === Severity.ERROR || validationStatus.severity === Severity.FATAL;
    }
    ValidationStatus.isError = isError;
})(ValidationStatus || (exports.ValidationStatus = ValidationStatus = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2019-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckEdgeResultAction = exports.RequestCheckEdgeAction = exports.SetTypeHintsAction = exports.RequestTypeHintsAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestTypeHintsAction;
(function (RequestTypeHintsAction) {
    RequestTypeHintsAction.KIND = 'requestTypeHints';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestTypeHintsAction.KIND);
    }
    RequestTypeHintsAction.is = is;
    function create(options = {}) {
        return {
            kind: RequestTypeHintsAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestTypeHintsAction.create = create;
})(RequestTypeHintsAction || (exports.RequestTypeHintsAction = RequestTypeHintsAction = {}));
var SetTypeHintsAction;
(function (SetTypeHintsAction) {
    SetTypeHintsAction.KIND = 'setTypeHints';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetTypeHintsAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'shapeHints') && (0, type_util_1.hasArrayProp)(object, 'edgeHints');
    }
    SetTypeHintsAction.is = is;
    function create(options) {
        return {
            kind: SetTypeHintsAction.KIND,
            responseId: '',
            ...options
        };
    }
    SetTypeHintsAction.create = create;
})(SetTypeHintsAction || (exports.SetTypeHintsAction = SetTypeHintsAction = {}));
var RequestCheckEdgeAction;
(function (RequestCheckEdgeAction) {
    RequestCheckEdgeAction.KIND = 'requestCheckEdge';
    function is(object) {
        return (base_protocol_1.Action.hasKind(object, RequestCheckEdgeAction.KIND) &&
            (0, type_util_1.hasStringProp)(object, 'edgeType') &&
            (0, type_util_1.hasStringProp)(object, 'sourceElementId') &&
            (0, type_util_1.hasStringProp)(object, 'targetElementId', true));
    }
    RequestCheckEdgeAction.is = is;
    function create(options) {
        var _a;
        return {
            kind: RequestCheckEdgeAction.KIND,
            edgeType: options.edgeType,
            sourceElementId: getElementTypeId(options.sourceElement),
            targetElementId: options.targetElement ? getElementTypeId(options.targetElement) : undefined,
            requestId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ''
        };
    }
    RequestCheckEdgeAction.create = create;
})(RequestCheckEdgeAction || (exports.RequestCheckEdgeAction = RequestCheckEdgeAction = {}));
function getElementTypeId(element) {
    if (typeof element === 'string') {
        return element;
    }
    return element.id;
}
var CheckEdgeResultAction;
(function (CheckEdgeResultAction) {
    CheckEdgeResultAction.KIND = 'checkEdgeTargetResult';
    function is(object) {
        return (base_protocol_1.Action.hasKind(object, CheckEdgeResultAction.KIND) &&
            (0, type_util_1.hasBooleanProp)(object, 'isValid') &&
            (0, type_util_1.hasStringProp)(object, 'edgeType') &&
            (0, type_util_1.hasStringProp)(object, 'sourceElementId') &&
            (0, type_util_1.hasStringProp)(object, 'targetElementId', true));
    }
    CheckEdgeResultAction.is = is;
    function create(options) {
        return {
            kind: CheckEdgeResultAction.KIND,
            responseId: '',
            ...options
        };
    }
    CheckEdgeResultAction.create = create;
})(CheckEdgeResultAction || (exports.CheckEdgeResultAction = CheckEdgeResultAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteMarkersAction = exports.SetMarkersAction = exports.RequestMarkersAction = exports.MarkersReason = exports.MarkerKind = void 0;
/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
/**
 * The default marker kinds used in GLSP
 */
var MarkerKind;
(function (MarkerKind) {
    MarkerKind.INFO = 'info';
    MarkerKind.WARNING = 'warning';
    MarkerKind.ERROR = 'error';
})(MarkerKind || (exports.MarkerKind = MarkerKind = {}));
/**
 * The default reasons for markers.
 */
var MarkersReason;
(function (MarkersReason) {
    /** Markers resulting from a batch validation */
    MarkersReason.BATCH = 'batch';
    /** Markers resulting from a live validation */
    MarkersReason.LIVE = 'live';
})(MarkersReason || (exports.MarkersReason = MarkersReason = {}));
var RequestMarkersAction;
(function (RequestMarkersAction) {
    RequestMarkersAction.KIND = 'requestMarkers';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestMarkersAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'elementsIDs');
    }
    RequestMarkersAction.is = is;
    function create(elementsIDs, options = {}) {
        return {
            kind: RequestMarkersAction.KIND,
            requestId: '',
            elementsIDs,
            reason: MarkersReason.BATCH,
            ...options
        };
    }
    RequestMarkersAction.create = create;
})(RequestMarkersAction || (exports.RequestMarkersAction = RequestMarkersAction = {}));
var SetMarkersAction;
(function (SetMarkersAction) {
    SetMarkersAction.KIND = 'setMarkers';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetMarkersAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'markers');
    }
    SetMarkersAction.is = is;
    function create(markers, options = {}) {
        return {
            kind: SetMarkersAction.KIND,
            responseId: '',
            markers,
            reason: MarkersReason.BATCH,
            ...options
        };
    }
    SetMarkersAction.create = create;
})(SetMarkersAction || (exports.SetMarkersAction = SetMarkersAction = {}));
var DeleteMarkersAction;
(function (DeleteMarkersAction) {
    DeleteMarkersAction.KIND = 'deleteMarkers';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, DeleteMarkersAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'markers');
    }
    DeleteMarkersAction.is = is;
    function create(markers) {
        return {
            kind: DeleteMarkersAction.KIND,
            markers
        };
    }
    DeleteMarkersAction.create = create;
})(DeleteMarkersAction || (exports.DeleteMarkersAction = DeleteMarkersAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceModelChangedAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestModelAction;
(function (RequestModelAction) {
    RequestModelAction.KIND = 'requestModel';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestModelAction.KIND);
    }
    RequestModelAction.is = is;
    function create(options = {}) {
        return {
            kind: RequestModelAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestModelAction.create = create;
})(RequestModelAction || (exports.RequestModelAction = RequestModelAction = {}));
var SetModelAction;
(function (SetModelAction) {
    SetModelAction.KIND = 'setModel';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetModelAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'newRoot');
    }
    SetModelAction.is = is;
    function create(newRoot, options = {}) {
        return {
            kind: SetModelAction.KIND,
            responseId: '',
            newRoot,
            ...options
        };
    }
    SetModelAction.create = create;
})(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
var UpdateModelAction;
(function (UpdateModelAction) {
    UpdateModelAction.KIND = 'updateModel';
    function is(action) {
        return base_protocol_1.Action.hasKind(action, UpdateModelAction.KIND) && (0, type_util_1.hasObjectProp)(action, 'newRoot');
    }
    UpdateModelAction.is = is;
    function create(newRoot, options = {}) {
        return {
            kind: UpdateModelAction.KIND,
            newRoot,
            animate: true,
            ...options
        };
    }
    UpdateModelAction.create = create;
})(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
var SourceModelChangedAction;
(function (SourceModelChangedAction) {
    SourceModelChangedAction.KIND = 'sourceModelChanged';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SourceModelChangedAction.KIND) && (0, type_util_1.hasStringProp)(object, 'sourceModelName');
    }
    SourceModelChangedAction.is = is;
    function create(sourceModelName) {
        return {
            kind: SourceModelChangedAction.KIND,
            sourceModelName: sourceModelName
        };
    }
    SourceModelChangedAction.create = create;
})(SourceModelChangedAction || (exports.SourceModelChangedAction = SourceModelChangedAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditMode = exports.SetEditModeAction = void 0;
/********************************************************************************
 * Copyright (c) 2020-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var SetEditModeAction;
(function (SetEditModeAction) {
    SetEditModeAction.KIND = 'setEditMode';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetEditModeAction.KIND) && (0, type_util_1.hasStringProp)(object, 'editMode');
    }
    SetEditModeAction.is = is;
    function create(editMode) {
        return {
            kind: SetEditModeAction.KIND,
            editMode
        };
    }
    SetEditModeAction.create = create;
})(SetEditModeAction || (exports.SetEditModeAction = SetEditModeAction = {}));
/**
 * The potential default values for the `editMode` property of  a {@link SetEditModeAction}.
 */
var EditMode;
(function (EditMode) {
    EditMode.READONLY = 'readonly';
    EditMode.EDITABLE = 'editable';
})(EditMode || (exports.EditMode = EditMode = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutOperation = exports.ComputedBoundsAction = exports.RequestBoundsAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var RequestBoundsAction;
(function (RequestBoundsAction) {
    RequestBoundsAction.KIND = 'requestBounds';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestBoundsAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'newRoot');
    }
    RequestBoundsAction.is = is;
    function create(newRoot, options = {}) {
        return {
            kind: RequestBoundsAction.KIND,
            requestId: '',
            newRoot,
            ...options
        };
    }
    RequestBoundsAction.create = create;
})(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
var ComputedBoundsAction;
(function (ComputedBoundsAction) {
    ComputedBoundsAction.KIND = 'computedBounds';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, ComputedBoundsAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'bounds');
    }
    ComputedBoundsAction.is = is;
    function create(bounds, options = {}) {
        return {
            kind: ComputedBoundsAction.KIND,
            responseId: '',
            bounds,
            ...options
        };
    }
    ComputedBoundsAction.create = create;
})(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
var LayoutOperation;
(function (LayoutOperation) {
    LayoutOperation.KIND = 'layout';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, LayoutOperation.KIND) && (0, type_util_1.hasArrayProp)(object, 'elementIds');
    }
    LayoutOperation.is = is;
    function create(elementIds, options = {}) {
        return {
            kind: LayoutOperation.KIND,
            isOperation: true,
            elementIds,
            ...options
        };
    }
    LayoutOperation.create = create;
})(LayoutOperation || (exports.LayoutOperation = LayoutOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExportSvgAction = exports.RequestExportSvgAction = exports.SetDirtyStateAction = exports.SaveModelAction = void 0;
/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var SaveModelAction;
(function (SaveModelAction) {
    SaveModelAction.KIND = 'saveModel';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SaveModelAction.KIND);
    }
    SaveModelAction.is = is;
    function create(options = {}) {
        return {
            kind: SaveModelAction.KIND,
            ...options
        };
    }
    SaveModelAction.create = create;
})(SaveModelAction || (exports.SaveModelAction = SaveModelAction = {}));
var SetDirtyStateAction;
(function (SetDirtyStateAction) {
    SetDirtyStateAction.KIND = 'setDirtyState';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, SetDirtyStateAction.KIND) && (0, type_util_1.hasBooleanProp)(object, 'isDirty');
    }
    SetDirtyStateAction.is = is;
    function create(isDirty, options = {}) {
        return {
            kind: SetDirtyStateAction.KIND,
            isDirty,
            ...options
        };
    }
    SetDirtyStateAction.create = create;
})(SetDirtyStateAction || (exports.SetDirtyStateAction = SetDirtyStateAction = {}));
var RequestExportSvgAction;
(function (RequestExportSvgAction) {
    RequestExportSvgAction.KIND = 'requestExportSvg';
    function is(object) {
        return base_protocol_1.RequestAction.hasKind(object, RequestExportSvgAction.KIND);
    }
    RequestExportSvgAction.is = is;
    function create(options = {}) {
        return {
            kind: RequestExportSvgAction.KIND,
            requestId: '',
            ...options
        };
    }
    RequestExportSvgAction.create = create;
})(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
var ExportSvgAction;
(function (ExportSvgAction) {
    ExportSvgAction.KIND = 'exportSvg';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, ExportSvgAction.KIND) && (0, type_util_1.hasStringProp)(object, 'svg');
    }
    ExportSvgAction.is = is;
    function create(svg, options = {}) {
        return {
            kind: ExportSvgAction.KIND,
            svg,
            responseId: '',
            ...options
        };
    }
    ExportSvgAction.create = create;
})(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeContainerOperation = exports.ChangeBoundsOperation = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var ChangeBoundsOperation;
(function (ChangeBoundsOperation) {
    ChangeBoundsOperation.KIND = 'changeBounds';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, ChangeBoundsOperation.KIND) && (0, type_util_1.hasArrayProp)(object, 'newBounds');
    }
    ChangeBoundsOperation.is = is;
    function create(newBounds) {
        return {
            kind: ChangeBoundsOperation.KIND,
            isOperation: true,
            newBounds
        };
    }
    ChangeBoundsOperation.create = create;
})(ChangeBoundsOperation || (exports.ChangeBoundsOperation = ChangeBoundsOperation = {}));
var ChangeContainerOperation;
(function (ChangeContainerOperation) {
    ChangeContainerOperation.KIND = 'changeContainer';
    function is(object) {
        return base_protocol_1.Operation.hasKind(object, ChangeContainerOperation.KIND) && (0, type_util_1.hasStringProp)(object, 'elementId') && (0, type_util_1.hasStringProp)(object, 'targetContainerId');
    }
    ChangeContainerOperation.is = is;
    function create(options) {
        return {
            kind: ChangeContainerOperation.KIND,
            isOperation: true,
            ...options
        };
    }
    ChangeContainerOperation.create = create;
})(ChangeContainerOperation || (exports.ChangeContainerOperation = ChangeContainerOperation = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TriggerEdgeCreationAction = exports.TriggerNodeCreationAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var TriggerNodeCreationAction;
(function (TriggerNodeCreationAction) {
    TriggerNodeCreationAction.KIND = 'triggerNodeCreation';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, TriggerNodeCreationAction.KIND) && (0, type_util_1.hasStringProp)(object, 'elementTypeId');
    }
    TriggerNodeCreationAction.is = is;
    function create(elementTypeId, options) {
        return {
            kind: TriggerNodeCreationAction.KIND,
            elementTypeId,
            ...options
        };
    }
    TriggerNodeCreationAction.create = create;
})(TriggerNodeCreationAction || (exports.TriggerNodeCreationAction = TriggerNodeCreationAction = {}));
var TriggerEdgeCreationAction;
(function (TriggerEdgeCreationAction) {
    TriggerEdgeCreationAction.KIND = 'triggerEdgeCreation';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, TriggerEdgeCreationAction.KIND) && (0, type_util_1.hasStringProp)(object, 'elementTypeId');
    }
    TriggerEdgeCreationAction.is = is;
    function create(elementTypeId, options = {}) {
        return {
            kind: TriggerEdgeCreationAction.KIND,
            elementTypeId,
            ...options
        };
    }
    TriggerEdgeCreationAction.create = create;
})(TriggerEdgeCreationAction || (exports.TriggerEdgeCreationAction = TriggerEdgeCreationAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuItem = exports.PaletteItem = exports.LabeledAction = exports.EditorContext = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const tool_palette_1 = __webpack_require__(/*! ./tool-palette */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js");
var EditorContext;
(function (EditorContext) {
    function is(object) {
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasArrayProp)(object, 'selectedElementIds');
    }
    EditorContext.is = is;
})(EditorContext || (exports.EditorContext = EditorContext = {}));
var LabeledAction;
(function (LabeledAction) {
    function is(object) {
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, 'label') && (0, type_util_1.hasArrayProp)(object, 'actions');
    }
    LabeledAction.is = is;
    function toActionArray(input) {
        if (Array.isArray(input)) {
            return input;
        }
        else if (LabeledAction.is(input)) {
            return input.actions;
        }
        return [input];
    }
    LabeledAction.toActionArray = toActionArray;
})(LabeledAction || (exports.LabeledAction = LabeledAction = {}));
var PaletteItem;
(function (PaletteItem) {
    function is(object) {
        return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, 'id') && (0, type_util_1.hasStringProp)(object, 'sortString');
    }
    PaletteItem.is = is;
    function getTriggerAction(item) {
        if (item) {
            const initialActions = item.actions
                .filter(a => isTriggerElementCreationAction(a))
                .map(action => action);
            return initialActions.length > 0 ? initialActions[0] : undefined;
        }
        return undefined;
    }
    PaletteItem.getTriggerAction = getTriggerAction;
    function isTriggerElementCreationAction(object) {
        return tool_palette_1.TriggerNodeCreationAction.is(object) || tool_palette_1.TriggerEdgeCreationAction.is(object);
    }
    PaletteItem.isTriggerElementCreationAction = isTriggerElementCreationAction;
})(PaletteItem || (exports.PaletteItem = PaletteItem = {}));
var MenuItem;
(function (MenuItem) {
    function is(object) {
        return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, 'id');
    }
    MenuItem.is = is;
})(MenuItem || (exports.MenuItem = MenuItem = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RedoAction = exports.UndoAction = void 0;
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var UndoAction;
(function (UndoAction) {
    UndoAction.KIND = 'glspUndo';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, UndoAction.KIND);
    }
    UndoAction.is = is;
    function create() {
        return {
            kind: UndoAction.KIND
        };
    }
    UndoAction.create = create;
})(UndoAction || (exports.UndoAction = UndoAction = {}));
var RedoAction;
(function (RedoAction) {
    RedoAction.KIND = 'glspRedo';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, RedoAction.KIND);
    }
    RedoAction.is = is;
    function create() {
        return {
            kind: RedoAction.KIND
        };
    }
    RedoAction.create = create;
})(RedoAction || (exports.RedoAction = RedoAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FitToScreenAction = exports.CenterAction = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const base_protocol_1 = __webpack_require__(/*! ./base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
var CenterAction;
(function (CenterAction) {
    CenterAction.KIND = 'center';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, CenterAction.KIND) && (0, type_util_1.hasBooleanProp)(object, 'animate') && (0, type_util_1.hasBooleanProp)(object, 'retainZoom');
    }
    CenterAction.is = is;
    function create(elementIds, options = {}) {
        return {
            kind: CenterAction.KIND,
            animate: true,
            retainZoom: false,
            elementIds,
            ...options
        };
    }
    CenterAction.create = create;
})(CenterAction || (exports.CenterAction = CenterAction = {}));
var FitToScreenAction;
(function (FitToScreenAction) {
    FitToScreenAction.KIND = 'fit';
    function is(object) {
        return base_protocol_1.Action.hasKind(object, FitToScreenAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'elementIds') && (0, type_util_1.hasBooleanProp)(object, 'animate');
    }
    FitToScreenAction.is = is;
    function create(elementIds, options = {}) {
        return {
            kind: FitToScreenAction.KIND,
            animate: true,
            elementIds,
            ...options
        };
    }
    FitToScreenAction.create = create;
})(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseGLSPClient = exports.GLOBAL_HANDLER_ID = void 0;
const sprotty_protocol_1 = __webpack_require__(/*! sprotty-protocol */ "../../node_modules/sprotty-protocol/lib/index.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/node/main.js");
const array_util_1 = __webpack_require__(/*! ../utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
const event_1 = __webpack_require__(/*! ../utils/event */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/event.js");
const glsp_client_1 = __webpack_require__(/*! ./glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js");
exports.GLOBAL_HANDLER_ID = '*';
/**
 * A simple {@link GLSPClient} implementation for use cases where the client & server are running
 * in the same context/process without a communication layer (like json-rpc) between. The client
 * directly communicates with a given {@link GLSPServer} instance.
 */
class BaseGLSPClient {
    get onServerInitialized() {
        return this.onServerInitializedEmitter.event;
    }
    constructor(options) {
        this.options = options;
        this.serverDeferred = new sprotty_protocol_1.Deferred();
        this.onStartDeferred = new sprotty_protocol_1.Deferred();
        this.onStopDeferred = new sprotty_protocol_1.Deferred();
        this.startupTimeout = 1500;
        this.actionMessageHandlers = new Map([[exports.GLOBAL_HANDLER_ID, []]]);
        this.onServerInitializedEmitter = new event_1.Emitter();
        this.state = glsp_client_1.ClientState.Initial;
        this.proxy = this.createProxy();
    }
    createProxy() {
        return {
            process: message => {
                var _a;
                const handlers = (_a = this.actionMessageHandlers.get(message.clientId)) !== null && _a !== void 0 ? _a : this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID);
                if (!handlers) {
                    console.warn('No ActionMessageHandler is configured- Cannot process server message', message);
                    return;
                }
                handlers.forEach(handler => handler(message));
            }
        };
    }
    configureServer(server) {
        if (this.state === glsp_client_1.ClientState.Running) {
            throw new Error('Could not configure new server. The GLSPClient is already running');
        }
        this.serverDeferred.resolve(server);
    }
    start() {
        if (this.state === glsp_client_1.ClientState.Running) {
            return this.onStartDeferred.promise;
        }
        this.state = glsp_client_1.ClientState.Starting;
        const timeOut = new Promise((_, reject) => setTimeout(() => {
            reject(new Error('Could not start client. No server is configured'));
        }, this.startupTimeout));
        Promise.race([this.serverDeferred.promise, timeOut])
            .then(server => {
            this._server = server;
            this.state = glsp_client_1.ClientState.Running;
            this.onStartDeferred.resolve();
        })
            .catch(error => {
            this.state = glsp_client_1.ClientState.StartFailed;
            this.onStartDeferred.reject(error);
        });
        return this.onStartDeferred.promise;
    }
    async initializeServer(params) {
        if (!this._initializeResult) {
            this._initializeResult = await this.checkedServer.initialize(params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
        }
        return this._initializeResult;
    }
    get initializeResult() {
        return this._initializeResult;
    }
    initializeClientSession(params) {
        return this.checkedServer.initializeClientSession(params);
    }
    disposeClientSession(params) {
        return this.checkedServer.disposeClientSession(params);
    }
    shutdownServer() {
        this.checkedServer.shutdown();
    }
    async stop() {
        if (this.state === glsp_client_1.ClientState.Stopped || this.state === glsp_client_1.ClientState.Stopping) {
            return this.onStop();
        }
        this.state = glsp_client_1.ClientState.Stopping;
        try {
            if (this._server) {
                this._server.shutdown();
            }
        }
        finally {
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStopDeferred.resolve();
        }
    }
    sendActionMessage(message) {
        this.checkedServer.process(message);
    }
    onActionMessage(handler, clientId) {
        if (!clientId) {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler);
            return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler));
        }
        if (!this.actionMessageHandlers.has(clientId)) {
            this.actionMessageHandlers.set(clientId, [handler]);
        }
        else {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(clientId), handler);
        }
        return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(clientId), handler));
    }
    get currentState() {
        return this.state;
    }
    onStart() {
        return this.onStartDeferred.promise;
    }
    onStop() {
        return this.onStopDeferred.promise;
    }
    get id() {
        return this.options.id;
    }
    checkState() {
        if (this.state !== glsp_client_1.ClientState.Running) {
            throw new Error(`Client with id '${this.id}' is not in 'Running' state`);
        }
    }
    get checkedServer() {
        this.checkState();
        if (!this._server) {
            throw new Error(`No server is configured for GLSPClient with id '${this.id}'`);
        }
        return this._server;
    }
    setStartupTimeout(ms) {
        this.startupTimeout = ms;
    }
}
exports.BaseGLSPClient = BaseGLSPClient;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPClient = exports.ClientState = exports.ApplicationIdProvider = void 0;
/********************************************************************************
 * Copyright (c) 2020-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/index.js");
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
class ApplicationIdProvider {
    static get() {
        if (!ApplicationIdProvider._applicationId) {
            ApplicationIdProvider._applicationId = uuid.v4();
        }
        return ApplicationIdProvider._applicationId;
    }
}
exports.ApplicationIdProvider = ApplicationIdProvider;
var ClientState;
(function (ClientState) {
    /**
     * The client has been created.
     */
    ClientState[ClientState["Initial"] = 0] = "Initial";
    /**
     * `Start` has been called on the client and the start process is still on-going.
     */
    ClientState[ClientState["Starting"] = 1] = "Starting";
    /**
     * The client failed to complete the start process.
     */
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    /**
     * The client was successfully started and is now running.
     */
    ClientState[ClientState["Running"] = 3] = "Running";
    /**
     * `Stop` has been called on the client and the stop process is still on-going.
     */
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    /**
     * The client stopped and disposed the server connection. Thus, action messages can no longer be sent.
     */
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
    /**
     * An error was encountered while connecting to the server. No action messages can be sent.
     */
    ClientState[ClientState["ServerError"] = 6] = "ServerError";
})(ClientState || (exports.ClientState = ClientState = {}));
var GLSPClient;
(function (GLSPClient) {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function isOptions(object) {
        return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, 'id');
    }
    GLSPClient.isOptions = isOptions;
    GLSPClient.protocolVersion = '1.0.0';
})(GLSPClient || (exports.GLSPClient = GLSPClient = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPClientProxy = exports.GLSPServerListener = exports.GLSPServer = void 0;
exports.GLSPServer = Symbol('GLSPServer');
exports.GLSPServerListener = Symbol('GLSPServerListener');
exports.GLSPClientProxy = Symbol('GLSPClientProxy');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonrpcClientProxy = exports.BaseJsonrpcGLSPClient = void 0;
/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const event_1 = __webpack_require__(/*! ../../utils/event */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/event.js");
const glsp_client_1 = __webpack_require__(/*! ../glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js");
const glsp_jsonrpc_client_1 = __webpack_require__(/*! ./glsp-jsonrpc-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js");
class BaseJsonrpcGLSPClient {
    get onServerInitialized() {
        return this.onServerInitializedEmitter.event;
    }
    get onActionMessageNotification() {
        return this.onActionMessageNotificationEmitter.event;
    }
    constructor(options) {
        this.onServerInitializedEmitter = new event_1.Emitter();
        this.onActionMessageNotificationEmitter = new event_1.Emitter();
        Object.assign(this, options);
        this.state = glsp_client_1.ClientState.Initial;
    }
    shutdownServer() {
        this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ShutdownNotification);
    }
    async initializeServer(params) {
        if (!this._initializeResult) {
            this._initializeResult = await this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
        }
        return this._initializeResult;
    }
    get initializeResult() {
        return this._initializeResult;
    }
    initializeClientSession(params) {
        return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, params);
    }
    disposeClientSession(params) {
        return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, params);
    }
    onActionMessage(handler, clientId) {
        return this.onActionMessageNotification(msg => {
            if (!clientId || msg.clientId === clientId) {
                handler(msg);
            }
        });
    }
    sendActionMessage(message) {
        this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
    }
    get checkedConnection() {
        if (!this.isConnectionActive()) {
            throw new Error(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ClientNotReadyMsg);
        }
        return this.resolvedConnection;
    }
    async start() {
        if (this.state === glsp_client_1.ClientState.Running) {
            return;
        }
        try {
            this.state = glsp_client_1.ClientState.Starting;
            const connection = await this.resolveConnection();
            connection.listen();
            this.resolvedConnection = connection;
            this.state = glsp_client_1.ClientState.Running;
        }
        catch (error) {
            glsp_jsonrpc_client_1.JsonrpcGLSPClient.error('Failed to start connection to server', error);
            this.state = glsp_client_1.ClientState.StartFailed;
        }
    }
    stop() {
        if (!this.connectionPromise) {
            this.state = glsp_client_1.ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === glsp_client_1.ClientState.Stopping && this.onStop) {
            return this.onStop;
        }
        this.state = glsp_client_1.ClientState.Stopping;
        return (this.onStop = this.resolveConnection().then(connection => {
            connection.dispose();
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStop = undefined;
            this.onActionMessageNotificationEmitter.dispose();
            this.connectionPromise = undefined;
            this.resolvedConnection = undefined;
        }));
    }
    resolveConnection() {
        if (!this.connectionPromise) {
            this.connectionPromise = this.doCreateConnection();
        }
        return this.connectionPromise;
    }
    async doCreateConnection() {
        const connection = typeof this.connectionProvider === 'function' ? await this.connectionProvider() : this.connectionProvider;
        connection.onError(data => this.handleConnectionError(data[0], data[1], data[2]));
        connection.onClose(() => this.handleConnectionClosed());
        connection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, msg => this.onActionMessageNotificationEmitter.fire(msg));
        return connection;
    }
    handleConnectionError(error, message, count) {
        glsp_jsonrpc_client_1.JsonrpcGLSPClient.error('Connection to server is erroring. Shutting down server.', error);
        this.stop();
        this.state = glsp_client_1.ClientState.ServerError;
    }
    handleConnectionClosed() {
        if (this.state === glsp_client_1.ClientState.Stopping || this.state === glsp_client_1.ClientState.Stopped) {
            return;
        }
        try {
            if (this.resolvedConnection) {
                this.resolvedConnection.dispose();
                this.connectionPromise = undefined;
                this.resolvedConnection = undefined;
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        glsp_jsonrpc_client_1.JsonrpcGLSPClient.error('Connection to server got closed. Server will not be restarted.');
        this.state = glsp_client_1.ClientState.ServerError;
    }
    isConnectionActive() {
        return this.state === glsp_client_1.ClientState.Running && !!this.resolvedConnection;
    }
    get currentState() {
        return this.state;
    }
}
exports.BaseJsonrpcGLSPClient = BaseJsonrpcGLSPClient;
/**
 * Default {@link GLSPClientProxy} implementation for jsonrpc-based client-server communication with typescript based servers.
 */
let JsonrpcClientProxy = class JsonrpcClientProxy {
    initialize(clientConnection, enableLogging = false) {
        this.clientConnection = clientConnection;
        this.enableLogging = enableLogging;
    }
    process(message) {
        var _a;
        if (this.enableLogging) {
            console.log(`Send action '${message.action.kind}' to client '${message.clientId}'`);
        }
        (_a = this.clientConnection) === null || _a === void 0 ? void 0 : _a.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
    }
};
exports.JsonrpcClientProxy = JsonrpcClientProxy;
exports.JsonrpcClientProxy = JsonrpcClientProxy = __decorate([
    (0, inversify_1.injectable)()
], JsonrpcClientProxy);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonrpcGLSPClient = void 0;
/********************************************************************************
 * Copyright (c) 2020-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/node/main.js");
const glsp_client_1 = __webpack_require__(/*! ../glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js");
var JsonrpcGLSPClient;
(function (JsonrpcGLSPClient) {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function isOptions(object) {
        return glsp_client_1.GLSPClient.isOptions(object) && 'connectionProvider' in object;
    }
    JsonrpcGLSPClient.isOptions = isOptions;
    JsonrpcGLSPClient.ActionMessageNotification = new vscode_jsonrpc_1.NotificationType('process');
    JsonrpcGLSPClient.InitializeRequest = new vscode_jsonrpc_1.RequestType('initialize');
    JsonrpcGLSPClient.InitializeClientSessionRequest = new vscode_jsonrpc_1.RequestType('initializeClientSession');
    JsonrpcGLSPClient.DisposeClientSessionRequest = new vscode_jsonrpc_1.RequestType('disposeClientSession');
    JsonrpcGLSPClient.ShutdownNotification = new vscode_jsonrpc_1.NotificationType0('shutdown');
    JsonrpcGLSPClient.ClientNotReadyMsg = 'JsonrpcGLSPClient is not ready yet';
    function error(message, ...optionalParams) {
        console.error(`[JsonrpcGLSPClient] ${message}`, optionalParams);
    }
    JsonrpcGLSPClient.error = error;
})(JsonrpcGLSPClient || (exports.JsonrpcGLSPClient = JsonrpcGLSPClient = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureClientConnection = void 0;
const glsp_jsonrpc_client_1 = __webpack_require__(/*! ./glsp-jsonrpc-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js");
/**
 * Configure the given client connection to forward the requests and notifications to the given {@link GLSPServer} instance.
 * @param clientConnection JSON-RPC client connection.
 * @param glspServer The GLSP Server which should react to requests & notifications.
 */
function configureClientConnection(clientConnection, glspServer) {
    clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest.method, (params) => glspServer.initialize(params));
    clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, (params) => glspServer.initializeClientSession(params));
    clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, (params) => glspServer.disposeClientSession(params));
    clientConnection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message => glspServer.process(message));
    clientConnection.listen();
}
exports.configureClientConnection = configureClientConnection;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.listen = exports.createWebSocketConnection = exports.WebSocketMessageWriter = exports.WebSocketMessageReader = exports.wrap = void 0;
// based on https://github.com/TypeFox/monaco-languageclient/blob/vwj-2.0.1/packages/vscode-ws-jsonrpc/src/socket/reader.ts
/* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/node/main.js");
/**
 * Creates a {@link WebSocketWrapper} for the given plain WebSocket
 * @param socket The socket to wrap
 */
function wrap(socket) {
    return {
        send: content => socket.send(content),
        onMessage: cb => (socket.onmessage = event => cb(event.data)),
        onClose: cb => (socket.onclose = event => cb(event.code, event.reason)),
        onError: cb => (socket.onerror = event => {
            if ('error' in event) {
                cb(event.error);
            }
        }),
        dispose: () => socket.close()
    };
}
exports.wrap = wrap;
/**
 * A `vscode-jsonrpc` {@link MessageReader} that reads messages from an underlying {@link WebSocketWrapper}.
 */
class WebSocketMessageReader extends vscode_jsonrpc_1.AbstractMessageReader {
    constructor(socket) {
        super();
        this.socket = socket;
        this.state = 'initial';
        this.eventQueue = [];
        this.socket.onMessage(message => this.handleMessage(message));
        this.socket.onError(error => this.fireError(error));
        this.socket.onClose(() => this.fireClose());
    }
    listen(callback) {
        if (this.state === 'initial') {
            this.state = 'listening';
            this.callback = callback;
            this.eventQueue.forEach(event => {
                if (event.message) {
                    this.handleMessage(event.message);
                }
                else if (event.error) {
                    this.fireError(event.error);
                }
                else {
                    this.fireClose();
                }
            });
            this.eventQueue = [];
        }
        return vscode_jsonrpc_1.Disposable.create(() => {
            this.callback = undefined;
            this.eventQueue = [];
        });
    }
    handleMessage(message) {
        if (this.state === 'initial') {
            this.eventQueue.push({ message });
        }
        else if (this.state === 'listening') {
            const data = JSON.parse(message);
            this.callback(data);
        }
    }
    fireError(error) {
        if (this.state === 'initial') {
            this.eventQueue.push({ error });
        }
        else if (this.state === 'listening') {
            super.fireError(error);
        }
    }
    fireClose() {
        if (this.state === 'initial') {
            this.eventQueue.push({});
        }
        else if (this.state === 'listening') {
            super.fireClose();
        }
        this.state = 'closed';
    }
}
exports.WebSocketMessageReader = WebSocketMessageReader;
/**
 * A `vscode-jsonrpc` {@link MessageReader} that writes messages to an underlying {@link WebSocketWrapper}.
 */
class WebSocketMessageWriter extends vscode_jsonrpc_1.AbstractMessageWriter {
    constructor(socket) {
        super();
        this.socket = socket;
        this.errorCount = 0;
    }
    end() {
        /** no-op */
    }
    async write(msg) {
        try {
            const content = JSON.stringify(msg);
            this.socket.send(content);
        }
        catch (e) {
            this.errorCount++;
            this.fireError(e, msg, this.errorCount);
        }
    }
}
exports.WebSocketMessageWriter = WebSocketMessageWriter;
/**
 * Create a `vscode-jsonrpc` {@link MessageConnection} on top of a given {@link WebSocketWrapper}.
 */
function createWebSocketConnection(socket, logger) {
    const reader = new WebSocketMessageReader(socket);
    const writer = new WebSocketMessageWriter(socket);
    return (0, vscode_jsonrpc_1.createMessageConnection)(reader, writer, logger);
}
exports.createWebSocketConnection = createWebSocketConnection;
/**
 * Creates a new {@link MessageConnection} on top of the given websocket on open.
 * @param webSocket The target webSocket
 * @param onConnection Optional callback that is invoked after the connection has been created
 * @param logger Optional connection logger
 * @returns A promise of the created connection
 */
function listen(webSocket, onConnection, logger) {
    return new Promise(resolve => {
        webSocket.onopen = () => {
            const socket = wrap(webSocket);
            const connection = createWebSocketConnection(socket, logger);
            onConnection === null || onConnection === void 0 ? void 0 : onConnection(connection);
            resolve(connection);
        };
    });
}
exports.listen = listen;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/worker-connection-provider.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/worker-connection-provider.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPWebWorkerProvider = void 0;
/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const browser_1 = __webpack_require__(/*! vscode-jsonrpc/browser */ "../../node_modules/vscode-jsonrpc/browser.js");
class GLSPWebWorkerProvider {
    constructor(url) {
        this.url = url;
    }
    createWebWorker(url) {
        return new Worker(url);
    }
    listen(handler) {
        var _a, _b;
        this.worker = this.createWebWorker(this.url);
        const wwConnection = (0, browser_1.createMessageConnection)(new browser_1.BrowserMessageReader(this.worker), new browser_1.BrowserMessageWriter(this.worker));
        (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn('GLSPWebWorkerProvider Initializing!');
        (_b = handler.onConnection) === null || _b === void 0 ? void 0 : _b.call(handler, wwConnection);
        return wwConnection;
    }
}
exports.GLSPWebWorkerProvider = GLSPWebWorkerProvider;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPWebSocketProvider = exports.GLSPConnectionHandler = void 0;
const websocket_connection_1 = __webpack_require__(/*! ./websocket-connection */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js");
exports.GLSPConnectionHandler = Symbol('GLSPConnectionHandler');
class GLSPWebSocketProvider {
    constructor(url, options) {
        this.url = url;
        this.reconnectAttempts = 0;
        this.options = {
            // default values
            reconnecting: true,
            reconnectAttempts: Infinity,
            reconnectDelay: 1000
        };
        this.options = Object.assign(this.options, options);
    }
    createWebSocket(url) {
        return new WebSocket(url);
    }
    listen(handler, isReconnecting = false) {
        this.webSocket = this.createWebSocket(this.url);
        this.webSocket.onerror = () => {
            var _a;
            (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.error('GLSPWebSocketProvider Connection to server errored. Please make sure that the server is running!');
            clearInterval(this.reconnectTimer);
            this.webSocket.close();
        };
        return new Promise(resolve => {
            this.webSocket.onopen = () => {
                var _a, _b, _c, _d;
                clearInterval(this.reconnectTimer);
                const wrappedSocket = (0, websocket_connection_1.wrap)(this.webSocket);
                const wsConnection = (0, websocket_connection_1.createWebSocketConnection)(wrappedSocket, handler.logger);
                this.webSocket.onclose = () => {
                    var _a, _b;
                    const { reconnecting, reconnectAttempts, reconnectDelay } = this.options;
                    if (reconnecting) {
                        if (this.reconnectAttempts >= reconnectAttempts) {
                            (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.error('GLSPWebSocketProvider WebSocket reconnect failed - maximum number reconnect attempts ' +
                                `(${reconnectAttempts}) was exceeded!`);
                        }
                        else {
                            this.reconnectTimer = setInterval(() => {
                                var _a;
                                (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn('GLSPWebSocketProvider reconnecting...');
                                this.listen(handler, true);
                                this.reconnectAttempts++;
                            }, reconnectDelay);
                        }
                    }
                    else {
                        (_b = handler.logger) === null || _b === void 0 ? void 0 : _b.error('GLSPWebSocketProvider WebSocket will not reconnect - closing the connection now!');
                    }
                };
                if (isReconnecting) {
                    (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn('GLSPWebSocketProvider Reconnecting!');
                    (_b = handler.onReconnect) === null || _b === void 0 ? void 0 : _b.call(handler, wsConnection);
                }
                else {
                    (_c = handler.logger) === null || _c === void 0 ? void 0 : _c.warn('GLSPWebSocketProvider Initializing!');
                    (_d = handler.onConnection) === null || _d === void 0 ? void 0 : _d.call(handler, wsConnection);
                }
                resolve(wsConnection);
            };
        });
    }
}
exports.GLSPWebSocketProvider = GLSPWebSocketProvider;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/di/container-configuration.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/di/container-configuration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveContainerConfiguration = exports.initializeContainer = void 0;
const array_util_1 = __webpack_require__(/*! ../utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
const feature_module_1 = __webpack_require__(/*! ./feature-module */ "../../node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js");
/**
 * Initializes a container with the given {@link ContainerConfiguration}. The container configuration
 * consists of the set of {@link ContainerModule}s that should be loaded in the container.
 * In addition, for more fine-grained control {@link ModuleConfiguration}s can be passed as part fo the container configuration
 * Module loading is distinct,this means each module will only get loaded once even if it is configured multiple times.
  @param containerConfigurations
 *          Custom modules to be loaded in addition to the default modules and/or default modules that should be excluded.
  @returns The initialized container.
 */
function initializeContainer(container, ...containerConfigurations) {
    const modules = resolveContainerConfiguration(...containerConfigurations);
    container.load(...modules);
    return container;
}
exports.initializeContainer = initializeContainer;
/**
 * Processes the given container configurations and returns the corresponding set of {@link ContainerModule}s.
 * Container configurations are processed in the order they are passed. If a module is configured to be removed
 * it can be added again in a later configuration. This also means in case of `replace` configurations that affect the same feature id
 * the last configuration wins.
 * @param containerConfigurations The container configurations to resolve
 * @throws An error if featureModule ids are not unique in the resolved module array
 * @returns an Array of resolved container modules
 */
function resolveContainerConfiguration(...containerConfigurations) {
    const modules = [];
    containerConfigurations.forEach(config => {
        if (isContainerModule(config)) {
            (0, array_util_1.distinctAdd)(modules, config);
        }
        else {
            if (config.remove) {
                (0, array_util_1.remove)(modules, ...(0, array_util_1.asArray)(config.remove));
            }
            if (config.add) {
                (0, array_util_1.distinctAdd)(modules, ...(0, array_util_1.asArray)(config.add));
            }
            if (config.replace) {
                (0, array_util_1.asArray)(config.replace).forEach(replace => {
                    const existingIndex = modules.findIndex(m => m instanceof feature_module_1.FeatureModule && m.featureId === replace.featureId);
                    if (existingIndex >= 0) {
                        modules[existingIndex] = replace;
                    }
                    else {
                        console.warn(`Could not find module to replace with feature id ${replace.featureId.toString()}.` +
                            'Adding replacement module to the end of the resolved configurations.');
                        (0, array_util_1.distinctAdd)(modules, replace);
                    }
                });
            }
        }
    });
    // Check for duplicate feature ids in resolved modules
    const featureIds = new Set();
    const duplicates = [];
    modules.forEach(module => {
        if (module instanceof feature_module_1.FeatureModule) {
            if (featureIds.has(module.featureId)) {
                duplicates.push(module);
            }
            else {
                featureIds.add(module.featureId);
            }
        }
    });
    if (duplicates.length > 0) {
        const culprits = duplicates.map(m => m.featureId.toString()).join(', ');
        throw new Error(`Could not resolve container configuration. Non-unique feature ids found in container configuration: ${culprits}`);
    }
    return modules;
}
exports.resolveContainerConfiguration = resolveContainerConfiguration;
/**
 * The container modules might originate form different inversify contexts (e.g. `inversify` vs. `@theia/core/shared/inversify`).
 * If this is the case an instanceof check can return  false negative.
 * => use a simple typeguard instead.
 */
function isContainerModule(config) {
    return (0, type_util_1.hasNumberProp)(config, 'id') && (0, type_util_1.hasFunctionProp)(config, 'registry');
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeatureModule = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const array_util_1 = __webpack_require__(/*! ../utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
/**
 * A `FeatureModule` is a specialized {@link ContainerModule} that can declare dependencies to other {@link FeatureModule}.
 * A feature module will only be loaded into a container if all of its required modules haven been loaded before. T
 * Each feature module binds its `featureId` be default. This enables querying of existing container to check wether a
 * feature module has been loaded into this container.
 */
class FeatureModule extends inversify_1.ContainerModule {
    constructor(registry, options = {}) {
        var _a;
        super((bind, unbind, isBound, ...rest) => {
            if (this.configure(bind, isBound)) {
                registry(bind, unbind, isBound, ...rest);
                this.debugLog(`Loading of feature module with id '${this.featureId.toString()}' completed`);
            }
        });
        this.featureId = (_a = options.featureId) !== null && _a !== void 0 ? _a : this.createFeatureId();
        this.requires = options.requires;
    }
    createFeatureId() {
        return Symbol(this.id);
    }
    /**
     * Configures the feature module i.e. checks if the requirements are met.
     * If this is the case the {@link FeatureModule.featureId} will be bound and the module will be loaded
     * @param bind container bind function
     * @param isBound container isBound function
     * @returns `true` if all requirements are met and the module is loaded. `false` otherwise
     */
    configure(bind, isBound) {
        this.debugLog(`Trying to load feature module with id '${this.featureId.toString()}'`);
        if (this.isLoaded({ isBound })) {
            const message = `Could not load feature module. Another module with id '${this.featureId.toString()}' is already loaded`;
            this.debugLog(message);
            throw new Error(message);
        }
        if (this.checkRequirements(isBound)) {
            this.debugLog(`Requirements are met, continue loading of feature module with id '${this.featureId.toString()}'`);
            bind(this.featureId).toConstantValue(this.featureId);
            return true;
        }
        return false;
    }
    debugLog(message, ...optionalParams) {
        if (FeatureModule.DEBUG_LOG_ENABLED) {
            console.log(message, ...optionalParams);
        }
    }
    /**
     * Checks if all required {@link FeatureModule}s are already loaded/bound in the container.
     * @param isBound The `isBound` property of the module callback. Used to check the required modules.
     * @returns `true` if all requirements are met, `false` otherwise
     */
    checkRequirements(isBound) {
        var _a;
        const requires = (0, array_util_1.asArray)((_a = this.requires) !== null && _a !== void 0 ? _a : []);
        if (requires.length === 0) {
            return true;
        }
        const missing = requires.filter(module => !module.isLoaded({ isBound }));
        if (missing.length > 0) {
            this.debugLog(
            // eslint-disable-next-line max-len
            `Could not load feature module. Required modules are not loaded. Feature ids: ${missing.map(m => m.featureId.toString()).join(', ')}`);
            return false;
        }
        return true;
    }
    isLoaded(context) {
        return context.isBound(this.featureId);
    }
}
exports.FeatureModule = FeatureModule;
/**
 * Global flag to enable/disable additional debug log output when loading feature modules
 * Default is `false`.
 */
FeatureModule.DEBUG_LOG_ENABLED = false;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/di/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/di/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
__exportStar(__webpack_require__(/*! ./container-configuration */ "../../node_modules/@eclipse-glsp/protocol/lib/di/container-configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./feature-module */ "../../node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js"), exports);
__exportStar(__webpack_require__(/*! ./inversify-util */ "../../node_modules/@eclipse-glsp/protocol/lib/di/inversify-util.js"), exports);
__exportStar(__webpack_require__(/*! ./lazy-injector */ "../../node_modules/@eclipse-glsp/protocol/lib/di/lazy-injector.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/di/inversify-util.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/di/inversify-util.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindAsService = exports.lazyBind = exports.bindOrRebind = void 0;
/**
 * Checks wether the given service identifier is already bound in the given context
 * then either calls  the `bind` or `rebind` function respectively.
 *
 * As this is just a convenience function
 * ```ts
 * bindOrRebind({bind,isBound,rebind}, MyService).to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (isBound(MyService)) {
 *    rebind(MyService).to(SomeOtherService);
 * } else {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` or `rebind` function
 */
function bindOrRebind(context, serviceIdentifier) {
    if (context.isBound(serviceIdentifier)) {
        return context.rebind(serviceIdentifier);
    }
    return context.bind(serviceIdentifier);
}
exports.bindOrRebind = bindOrRebind;
/**
 * Only binds the given service identifier if it's not already bound in the given context.
 *
 * As this is just a convenience function
 * ```ts
 * lazyBind({bind,isBound}, MyService)?.to(SomeOtherService);
 * ```
 * is equivalent to:
 * ```
 * if (!isBound(MyService)) {
 *    bind(MyService).to(SomeOtherService);
 * }
 * ```
 * @param context The binding context
 * @param serviceIdentifier The service identifier
 * @returns The result of the `bind` function or `undefined` if the service was already bound
 */
function lazyBind(context, serviceIdentifier) {
    if (context.isBound(serviceIdentifier)) {
        return undefined;
    }
    return context.bind(serviceIdentifier);
}
exports.lazyBind = lazyBind;
/**
 * Binds the given service identifier to the given target service in the given context.
 * In addition, the target service is bound to itself in singleton scope. This ensures
 * that services can be rebound individually even if they are multi-injected.
 *
 * As this is just a convenience function
 * ```ts
 * bindAsService(bind,SomeOtherService,MyServiceImpl);
 * ```
 * is equivalent to:
 * ```ts
 * bind(MyServiceImpl).toSelf.inSingletonScope():
 * bind(SomeOtherService).toService(MyServiceImpl);
 * ```
 * @param serviceIdentifier
 * @param toServiceIdentifier
 */
function bindAsService(context, serviceIdentifier, targetService) {
    const bind = typeof context === 'object' ? context.bind.bind(context) : context;
    bind(targetService).toSelf().inSingletonScope();
    bind(serviceIdentifier).toService(targetService);
}
exports.bindAsService = bindAsService;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/di/lazy-injector.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/di/lazy-injector.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindLazyInjector = exports.DefaultLazyInjector = exports.LazyInjector = void 0;
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const error_msgs_1 = __webpack_require__(/*! inversify/lib/constants/error_msgs */ "../../node_modules/inversify/lib/constants/error_msgs.js");
exports.LazyInjector = Symbol('LazyInjector');
/**
 * Default implementation of the {@link LazyInjector} interface. This implementation
 * will be bound when using the {@link bindLazyInjector} function.
 */
class DefaultLazyInjector {
    constructor(container) {
        this.container = container;
        this.cache = new Map();
    }
    get(serviceIdentifier) {
        const service = this.getOptional(serviceIdentifier);
        if (service === undefined) {
            throw new Error(error_msgs_1.NOT_REGISTERED + (0, inversify_1.getServiceIdentifierAsString)(serviceIdentifier));
        }
        return service;
    }
    getOptional(serviceIdentifier) {
        if (this.cache.has(serviceIdentifier)) {
            return this.cache.get(serviceIdentifier);
        }
        const service = this.container.isBound(serviceIdentifier) ? this.container.get(serviceIdentifier) : undefined;
        this.cache.set(serviceIdentifier, service);
        return service;
    }
    getAll(serviceIdentifier) {
        if (this.cache.has(serviceIdentifier)) {
            return this.cache.get(serviceIdentifier);
        }
        const services = this.container.isBound(serviceIdentifier) ? this.container.getAll(serviceIdentifier) : [];
        this.cache.set(serviceIdentifier, services);
        return services;
    }
}
exports.DefaultLazyInjector = DefaultLazyInjector;
function bindLazyInjector(context) {
    const bind = typeof context === 'object' ? context.bind.bind(context) : context;
    bind(exports.LazyInjector).toDynamicValue(ctx => new DefaultLazyInjector(ctx.container));
}
exports.bindLazyInjector = bindLazyInjector;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
__exportStar(__webpack_require__(/*! ./action-protocol/base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/client-notification */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/clipboard */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/contexts */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/edge-modification */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-creation */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-hover */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-navigation */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-selection */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-text-editing */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-type-hints */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/element-validation */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/model-data */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/model-edit-mode */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/model-layout */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/model-saving */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/node-modification */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/tool-palette */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/types */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/undo-redo */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js"), exports);
__exportStar(__webpack_require__(/*! ./action-protocol/viewport */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/base-glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/glsp-server */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/base-jsonrpc-glsp-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/glsp-jsonrpc-client */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/glsp-jsonrpc-server */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/websocket-connection */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/worker-connection-provider */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/worker-connection-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/jsonrpc/ws-connection-provider */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./client-server-protocol/types */ "../../node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js"), exports);
__exportStar(__webpack_require__(/*! ./model/default-types */ "../../node_modules/@eclipse-glsp/protocol/lib/model/default-types.js"), exports);
__exportStar(__webpack_require__(/*! ./model/model-schema */ "../../node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js"), exports);
__exportStar(__webpack_require__(/*! ./re-exports */ "../../node_modules/@eclipse-glsp/protocol/lib/re-exports.js"), exports);
__exportStar(__webpack_require__(/*! ./sprotty-actions */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js"), exports);
__exportStar(__webpack_require__(/*! ./sprotty-geometry-bounds */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-bounds.js"), exports);
__exportStar(__webpack_require__(/*! ./sprotty-geometry-dimension */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js"), exports);
__exportStar(__webpack_require__(/*! ./sprotty-geometry-point */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/disposable */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/event */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/event.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/geometry-movement */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-movement.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/geometry-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/geometry-vector */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/math-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/model/default-types.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/model/default-types.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultTypes = void 0;
/**
 * The default types for graphical model elements available in GLSP.
 */
var DefaultTypes;
(function (DefaultTypes) {
    // HTML elements
    DefaultTypes.HTML = 'html';
    // generic types
    DefaultTypes.FOREIGN_OBJECT = 'foreign-object';
    DefaultTypes.PRE_RENDERED = 'pre-rendered';
    DefaultTypes.SHAPE_PRE_RENDERED = 'shape-pre-rendered';
    // SVG elements
    DefaultTypes.SVG = 'svg';
    // graph types
    DefaultTypes.GRAPH = 'graph';
    DefaultTypes.NODE = 'node';
    DefaultTypes.COMPARTMENT = 'comp';
    DefaultTypes.COMPARTMENT_HEADER = 'comp:header';
    DefaultTypes.EDGE = 'edge';
    DefaultTypes.PORT = 'port';
    DefaultTypes.ROUTING_POINT = 'routing-point';
    DefaultTypes.VOLATILE_ROUTING_POINT = `volatile-${DefaultTypes.ROUTING_POINT}`;
    DefaultTypes.LABEL = 'label';
    // UI elements
    DefaultTypes.BUTTON = 'button';
    DefaultTypes.BUTTON_EXPAND = 'button:expand';
    DefaultTypes.ISSUE_MARKER = 'marker';
    // shapes
    DefaultTypes.NODE_CIRCLE = 'node:circle';
    DefaultTypes.NODE_RECTANGLE = 'node:rectangle';
    DefaultTypes.NODE_DIAMOND = 'node:diamond';
})(DefaultTypes || (exports.DefaultTypes = DefaultTypes = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGModelElementSchema = void 0;
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
/** Serializable representation of GModel elements. This is the transfer format
 * used to exchange model information between client and server. Both the client and
 * server have a deserialization mechanism in place to convert a GModelElementSchema
 * into the corresponding class-based model (or EMF-based in case of the Java Server).
 *
 * To ensure sprotty compatibility all types are just aliases of the corresponding Sprotty SModel API element.
 */
function isGModelElementSchema(object) {
    return typeof object === 'object' && (0, type_util_1.hasStringProp)(object, 'type') && (0, type_util_1.hasStringProp)(object, 'id');
}
exports.isGModelElementSchema = isGModelElementSchema;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/re-exports.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/re-exports.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSubType = exports.getBasicType = exports.findElement = exports.cloneModel = exports.applyBounds = exports.isZoomable = exports.isScrollable = void 0;
/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var model_1 = __webpack_require__(/*! sprotty-protocol/lib/model */ "../../node_modules/sprotty-protocol/lib/model.js");
Object.defineProperty(exports, "isScrollable", ({ enumerable: true, get: function () { return model_1.isScrollable; } }));
Object.defineProperty(exports, "isZoomable", ({ enumerable: true, get: function () { return model_1.isZoomable; } }));
__exportStar(__webpack_require__(/*! sprotty-protocol/lib/utils/async */ "../../node_modules/sprotty-protocol/lib/utils/async.js"), exports);
__exportStar(__webpack_require__(/*! sprotty-protocol/lib/utils/geometry */ "../../node_modules/sprotty-protocol/lib/utils/geometry.js"), exports);
__exportStar(__webpack_require__(/*! sprotty-protocol/lib/utils/json */ "../../node_modules/sprotty-protocol/lib/utils/json.js"), exports);
var model_utils_1 = __webpack_require__(/*! sprotty-protocol/lib/utils/model-utils */ "../../node_modules/sprotty-protocol/lib/utils/model-utils.js");
Object.defineProperty(exports, "applyBounds", ({ enumerable: true, get: function () { return model_utils_1.applyBounds; } }));
Object.defineProperty(exports, "cloneModel", ({ enumerable: true, get: function () { return model_utils_1.cloneModel; } }));
Object.defineProperty(exports, "findElement", ({ enumerable: true, get: function () { return model_utils_1.findElement; } }));
Object.defineProperty(exports, "getBasicType", ({ enumerable: true, get: function () { return model_utils_1.getBasicType; } }));
Object.defineProperty(exports, "getSubType", ({ enumerable: true, get: function () { return model_utils_1.getSubType; } }));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewportResult = exports.SetViewportAction = exports.SetBoundsAction = exports.SelectionResult = exports.OpenAction = exports.MoveAction = exports.HoverFeedbackAction = exports.GetViewportAction = exports.GetSelectionAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.BringToFrontAction = void 0;
const actions_1 = __webpack_require__(/*! sprotty-protocol/lib/actions */ "../../node_modules/sprotty-protocol/lib/actions.js");
Object.defineProperty(exports, "BringToFrontAction", ({ enumerable: true, get: function () { return actions_1.BringToFrontAction; } }));
Object.defineProperty(exports, "CollapseExpandAction", ({ enumerable: true, get: function () { return actions_1.CollapseExpandAction; } }));
Object.defineProperty(exports, "CollapseExpandAllAction", ({ enumerable: true, get: function () { return actions_1.CollapseExpandAllAction; } }));
Object.defineProperty(exports, "GetSelectionAction", ({ enumerable: true, get: function () { return actions_1.GetSelectionAction; } }));
Object.defineProperty(exports, "GetViewportAction", ({ enumerable: true, get: function () { return actions_1.GetViewportAction; } }));
Object.defineProperty(exports, "HoverFeedbackAction", ({ enumerable: true, get: function () { return actions_1.HoverFeedbackAction; } }));
Object.defineProperty(exports, "MoveAction", ({ enumerable: true, get: function () { return actions_1.MoveAction; } }));
Object.defineProperty(exports, "OpenAction", ({ enumerable: true, get: function () { return actions_1.OpenAction; } }));
Object.defineProperty(exports, "SelectionResult", ({ enumerable: true, get: function () { return actions_1.SelectionResult; } }));
Object.defineProperty(exports, "SetBoundsAction", ({ enumerable: true, get: function () { return actions_1.SetBoundsAction; } }));
Object.defineProperty(exports, "SetViewportAction", ({ enumerable: true, get: function () { return actions_1.SetViewportAction; } }));
Object.defineProperty(exports, "ViewportResult", ({ enumerable: true, get: function () { return actions_1.ViewportResult; } }));
const base_protocol_1 = __webpack_require__(/*! ./action-protocol/base-protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js");
const type_util_1 = __webpack_require__(/*! ./utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
actions_1.CollapseExpandAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAction.KIND) && (0, type_util_1.hasArrayProp)(object, 'expandIds') && (0, type_util_1.hasArrayProp)(object, 'collapseIds');
actions_1.CollapseExpandAllAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAllAction.KIND) && (0, type_util_1.hasBooleanProp)(object, 'expand');
actions_1.GetSelectionAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetSelectionAction.KIND);
actions_1.GetViewportAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetViewportAction.KIND);
actions_1.HoverFeedbackAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.HoverFeedbackAction.KIND) && (0, type_util_1.hasStringProp)(object, 'mouseoverElement') && (0, type_util_1.hasBooleanProp)(object, 'mouseIsOver');
actions_1.MoveAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.MoveAction.KIND) &&
    (0, type_util_1.hasArrayProp)(object, 'moves') &&
    (0, type_util_1.hasBooleanProp)(object, 'animate') &&
    (0, type_util_1.hasBooleanProp)(object, 'finished');
actions_1.OpenAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.OpenAction.KIND) && (0, type_util_1.hasStringProp)(object, 'elementId');
actions_1.SelectionResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SelectionResult.KIND) && (0, type_util_1.hasArrayProp)(object, 'selectedElementsIDs');
actions_1.SetBoundsAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetBoundsAction.KIND) && (0, type_util_1.hasObjectProp)(object, 'bounds');
actions_1.SetViewportAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetViewportAction.KIND) &&
    (0, type_util_1.hasStringProp)(object, 'elementId') &&
    (0, type_util_1.hasObjectProp)(object, 'newViewport') &&
    (0, type_util_1.hasBooleanProp)(object, 'animate');
actions_1.ViewportResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.ViewportResult.KIND) && (0, type_util_1.hasObjectProp)(object, 'viewport') && (0, type_util_1.hasObjectProp)(object, 'canvasBounds');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-bounds.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-bounds.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bounds = void 0;
const geometry_1 = __webpack_require__(/*! sprotty-protocol/lib/utils/geometry */ "../../node_modules/sprotty-protocol/lib/utils/geometry.js");
Object.defineProperty(exports, "Bounds", ({ enumerable: true, get: function () { return geometry_1.Bounds; } }));
const sprotty_geometry_dimension_1 = __webpack_require__(/*! ./sprotty-geometry-dimension */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js");
const sprotty_geometry_point_1 = __webpack_require__(/*! ./sprotty-geometry-point */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js");
const type_util_1 = __webpack_require__(/*! ./utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
geometry_1.Bounds.ZERO = Object.freeze({
    x: 0,
    y: 0,
    width: 0,
    height: 0
});
geometry_1.Bounds.is = (bounds) => type_util_1.AnyObject.is(bounds) &&
    (0, type_util_1.hasNumberProp)(bounds, 'x') &&
    (0, type_util_1.hasNumberProp)(bounds, 'y') &&
    (0, type_util_1.hasNumberProp)(bounds, 'width') &&
    (0, type_util_1.hasNumberProp)(bounds, 'height');
geometry_1.Bounds.isValid = (bounds) => bounds !== undefined && sprotty_geometry_dimension_1.Dimension.isValid(bounds) && sprotty_geometry_point_1.Point.isValid(bounds);
geometry_1.Bounds.encompasses = (outer, inner) => geometry_1.Bounds.includes(outer, geometry_1.Bounds.topLeft(inner)) && geometry_1.Bounds.includes(outer, geometry_1.Bounds.bottomRight(inner));
geometry_1.Bounds.overlap = (one, other, touch) => {
    const oneTopLeft = geometry_1.Bounds.topLeft(one);
    const oneBottomRight = geometry_1.Bounds.bottomRight(one);
    const otherTopLeft = geometry_1.Bounds.topLeft(other);
    const otherBottomRight = geometry_1.Bounds.bottomRight(other);
    return touch
        ? oneTopLeft.x <= otherBottomRight.x &&
            otherTopLeft.x <= oneBottomRight.x &&
            oneBottomRight.y >= otherTopLeft.y &&
            otherBottomRight.y >= oneTopLeft.y
        : oneTopLeft.x < otherBottomRight.x &&
            otherTopLeft.x < oneBottomRight.x &&
            oneBottomRight.y > otherTopLeft.y &&
            otherBottomRight.y > oneTopLeft.y;
};
geometry_1.Bounds.equals = (left, right, eps) => sprotty_geometry_point_1.Point.equals(left, right, eps) && sprotty_geometry_dimension_1.Dimension.equals(left, right, eps);
geometry_1.Bounds.left = (bounds) => bounds.x;
geometry_1.Bounds.centerX = (bounds) => bounds.x + (bounds.width >= 0 ? bounds.width * 0.5 : 0);
geometry_1.Bounds.right = (bounds) => bounds.x + bounds.width;
geometry_1.Bounds.top = (bounds) => bounds.y;
geometry_1.Bounds.middle = (bounds) => bounds.y + (bounds.height >= 0 ? bounds.height * 0.5 : 0);
geometry_1.Bounds.centerY = geometry_1.Bounds.middle;
geometry_1.Bounds.bottom = (bounds) => bounds.y + bounds.height;
geometry_1.Bounds.topLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.topCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.topRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.middleLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.middleCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.middleRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.bottomLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.bottomCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.bottomRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.isAbove = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) <= geometry_1.Bounds.top(rightBounds);
geometry_1.Bounds.isBelow = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) >= geometry_1.Bounds.top(rightBounds);
geometry_1.Bounds.isBefore = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) < geometry_1.Bounds.left(rightBounds);
geometry_1.Bounds.isAfter = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) >= geometry_1.Bounds.left(rightBounds);
geometry_1.Bounds.sortBy = (rankFunc, ...bounds) => bounds.sort((left, right) => rankFunc(left) - rankFunc(right));
geometry_1.Bounds.from = (topLeft, bottomRight) => ({
    ...topLeft,
    width: bottomRight.x - topLeft.x,
    height: bottomRight.y - topLeft.y
});
geometry_1.Bounds.position = geometry_1.Bounds.topLeft;
geometry_1.Bounds.dimension = (bounds) => ({ width: bounds.width, height: bounds.height });
geometry_1.Bounds.move = geometry_1.Bounds.translate;
geometry_1.Bounds.resize = (bounds, delta) => ({
    ...bounds,
    width: bounds.width + delta.width,
    height: bounds.height + delta.height
});


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dimension = void 0;
const geometry_1 = __webpack_require__(/*! sprotty-protocol/lib/utils/geometry */ "../../node_modules/sprotty-protocol/lib/utils/geometry.js");
Object.defineProperty(exports, "Dimension", ({ enumerable: true, get: function () { return geometry_1.Dimension; } }));
const math_util_1 = __webpack_require__(/*! ./utils/math-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js");
const type_util_1 = __webpack_require__(/*! ./utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
geometry_1.Dimension.ZERO = Object.freeze({
    width: 0,
    height: 0
});
geometry_1.Dimension.is = (dimension) => type_util_1.AnyObject.is(dimension) && (0, type_util_1.hasNumberProp)(dimension, 'width') && (0, type_util_1.hasNumberProp)(dimension, 'height');
geometry_1.Dimension.center = (d) => ({ x: d.width * 0.5, y: d.height * 0.5 });
geometry_1.Dimension.add = (d, a) => ({ width: d.width + a.width, height: d.height + a.height });
geometry_1.Dimension.subtract = (d, a) => ({ width: d.width - a.width, height: d.height - a.height });
geometry_1.Dimension.multiplyMeasure = (d, m) => ({ width: d.width * m, height: d.height * m });
geometry_1.Dimension.divideMeasure = (d, m) => ({ width: d.width / m, height: d.height / m });
geometry_1.Dimension.map = (dimension, callbackfn) => ({
    ...dimension,
    width: callbackfn(dimension.width, 'width'),
    height: callbackfn(dimension.height, 'height')
});
geometry_1.Dimension.equals = (left, right, eps) => (0, math_util_1.equalUpTo)(left.width, right.width, eps) && (0, math_util_1.equalUpTo)(left.height, right.height, eps);
geometry_1.Dimension.fromPoint = (point) => ({ width: point.x, height: point.y });
geometry_1.Dimension.area = (dimension) => dimension.width * dimension.height;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Point = void 0;
const geometry_1 = __webpack_require__(/*! sprotty-protocol/lib/utils/geometry */ "../../node_modules/sprotty-protocol/lib/utils/geometry.js");
Object.defineProperty(exports, "Point", ({ enumerable: true, get: function () { return geometry_1.Point; } }));
const geometry_vector_1 = __webpack_require__(/*! ./utils/geometry-vector */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js");
const math_util_1 = __webpack_require__(/*! ./utils/math-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js");
const type_util_1 = __webpack_require__(/*! ./utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
geometry_1.Point.is = (point) => type_util_1.AnyObject.is(point) && (0, type_util_1.hasNumberProp)(point, 'x') && (0, type_util_1.hasNumberProp)(point, 'y');
geometry_1.Point.isOrigin = (point) => geometry_1.Point.equals(point, geometry_1.Point.ORIGIN);
geometry_1.Point.isValid = (point) => point !== undefined && !isNaN(point.x) && !isNaN(point.y);
geometry_1.Point.abs = (point) => geometry_1.Point.map(point, Math.abs);
geometry_1.Point.divideScalar = (point, scalar) => geometry_1.Point.map(point, coordinate => coordinate / scalar);
geometry_1.Point.multiplyScalar = (point, scalar) => geometry_1.Point.map(point, coordinate => coordinate * scalar);
geometry_1.Point.map = (point, callbackfn) => ({
    ...point,
    x: callbackfn(point.x, 'x'),
    y: callbackfn(point.y, 'y')
});
geometry_1.Point.snapToGrid = (point, grid, gridOrigin) => {
    if (gridOrigin) {
        // move point relative to grid origin and then restore after snapping
        const relative = geometry_1.Point.subtract(point, gridOrigin);
        const snapped = geometry_1.Point.snapToGrid(relative, grid);
        return geometry_1.Point.add(gridOrigin, snapped);
    }
    else {
        return { x: Math.round(point.x / grid.x) * grid.x, y: Math.round(point.y / grid.y) * grid.y };
    }
};
geometry_1.Point.vector = (from, to) => geometry_1.Point.subtract(to, from);
geometry_1.Point.move = (from, to) => {
    const vector = geometry_1.Point.vector(from, to);
    const direction = geometry_vector_1.Vector.direction(vector);
    return { from, to, vector, direction };
};
geometry_1.Point.moveTowards = (from, vector) => {
    const to = geometry_1.Point.add(from, vector);
    const dir = geometry_vector_1.Vector.direction(vector);
    return { from, to, vector, direction: dir };
};
geometry_1.Point.equals = (one, other, eps) => (0, math_util_1.equalUpTo)(one.x, other.x, eps) && (0, math_util_1.equalUpTo)(one.y, other.y, eps);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayOf = exports.partition = exports.isArrayMatching = exports.isStringArray = exports.isArrayOfPrimitive = exports.isArrayOfClass = exports.isArrayOfType = exports.distinctAdd = exports.asArray = exports.flatPush = exports.remove = exports.pluck = exports.last = exports.first = void 0;
function first(array, n) {
    if (n) {
        return array.filter((_, index) => index < n);
    }
    return array[0];
}
exports.first = first;
function last(array, n) {
    if (n) {
        return array.filter((_, index) => array.length - index <= n);
    }
    return array[array.length - 1];
}
exports.last = last;
/**
 * Plucks (i.e. extracts) the property value that corresponds to the given key from all objects of the array.
 * @param array The array which should be plucked.
 * @param key  The key of the property that should be extracted.
 * @returns A new array containing the plugged property for each element of the array.
 */
function pluck(array, key) {
    return array.map(element => element[key]);
}
exports.pluck = pluck;
/**
 * Removes the given values from the given array (if present).
 * @param array The array to execute the remove operation on.
 * @param values The values that should be removed from the array.
 */
function remove(array, ...values) {
    values.forEach(value => {
        const index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
        }
    });
}
exports.remove = remove;
/**
 * Push an array of values to the given array. The values can either be single objects of a concrete type `T`
 * or can also be nested arrays of T. If nested arrays are passed the they will be destructured (i.e. flattened)
 * so that they can be pushed to the given array.
 * @param array The array to push to.
 * @param toPush The values of {@link MaybeArray}s that should be pushed.
 */
function flatPush(array, toPush) {
    toPush.forEach(value => (Array.isArray(value) ? array.push(...value) : array.push(value)));
}
exports.flatPush = flatPush;
/**
 * Helper function to convert a {@link MaybeArray} into an array.
 * @param maybe The MaybeArray to convert
 * @returns The corresponding array
 */
function asArray(maybe) {
    if (Array.isArray(maybe)) {
        return maybe;
    }
    return [maybe];
}
exports.asArray = asArray;
/**
 * Adds the given values to the given array. The add operation is executed distinct meaning
 * a value will not be pushed to the array if its already present in the array.
 * @param array The array to push to.
 * @param values The values that should be added distinctively.
 */
function distinctAdd(array, ...values) {
    values.forEach(value => {
        if (!array.includes(value)) {
            array.push(value);
        }
    });
}
exports.distinctAdd = distinctAdd;
/**
 * A typeguard function to check wether a given object is an array of a specific type `T`. As it checks the type of each individual
 * array element this guard check is expensive and should only be used in cases where complete type-safety is required.
 * @param object The object to check.
 * @param typeGuard A typeguard to check the type of the individual elements.
 * @param supportEmpty A flag to determine wether empty arrays should pass the typeguard check.
 * @returns A type predicate indicating wether the given object has passed the type guard check.
 */
function isArrayOfType(object, typeGuard, supportEmpty = false) {
    return isArrayMatching(object, element => typeGuard(element), supportEmpty);
}
exports.isArrayOfType = isArrayOfType;
/**
 * A typeguard function to check wether a given object is an array of a class`T`. As it checks the wether each individual element
 * is an instance of the given class this  guard check is expensive and should only be used in cases where complete type-safety is required.
 * @param object The object to check.
 * @param constructor The constructor for the class under test.
 * @param supportEmpty A flag to determine wether empty arrays should pass the typeguard check.
 * @returns A type predicate indicating wether the given object has passed the type guard check.
 */
function isArrayOfClass(object, constructor, supportEmpty = false) {
    return isArrayMatching(object, element => element instanceof constructor, supportEmpty);
}
exports.isArrayOfClass = isArrayOfClass;
/**
 * A typeguard function to check wether a given object is an array of a {@link PrimitiveType} `T. As it checks the type of each individual
 * array element this guard check is expensive and should only be used in cases where complete type-safety is required.
 * @param object The object to check.
 * @param primitiveType The expected primitive type of the elements.
 * @param supportEmpty A flag to determine wether empty arrays should pass the typeguard check.
 * @returns A type predicate indicating wether the given object has passed the type guard check.
 */
function isArrayOfPrimitive(object, primitiveType, supportEmpty = false) {
    return isArrayMatching(object, element => typeof element === primitiveType, supportEmpty);
}
exports.isArrayOfPrimitive = isArrayOfPrimitive;
/**
 * A typeguard function to check wether a given object is an array of a strings. As it checks the type of each individual
 * array element this guard check is expensive and should only be used in cases where complete type-safety is required.
 * @param object The object to check.
 * @param supportEmpty A flag to determine wether empty arrays should pass the typeguard check.
 * @returns A type predicate indicating wether the given object has passed the type guard check.
 */
function isStringArray(object, supportEmpty = false) {
    return isArrayOfPrimitive(object, 'string', supportEmpty);
}
exports.isStringArray = isStringArray;
/**
 * A typeguard function to check wether a given object is an array where each element matches the given predicate.
 * @param object The object to check.
 * @param predicate The predicate to test with.
 * @param supportEmpty A flag to determine wether empty arrays be matched by the predicate..
 * @returns `true` if the given object is an array and all elements match the given predicate. `false` otherwise.
 */
function isArrayMatching(object, predicate, supportEmpty = false) {
    return Array.isArray(object) && object.every(predicate) && (supportEmpty || object.length > 0);
}
exports.isArrayMatching = isArrayMatching;
function partition(source, matchGuard) {
    const match = [];
    const rest = [];
    source.forEach(element => {
        if (matchGuard(element)) {
            match.push(element);
        }
        else {
            rest.push(element);
        }
    });
    return { match, rest };
}
exports.partition = partition;
/**
 * Helper function to create an array of values without any undefined values.
 * @param values The values to create the array from.
 * @returns The array of values without any undefined values.
 */
function arrayOf(...values) {
    return values.filter(element => element !== undefined);
}
exports.arrayOf = arrayOf;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisposableCollection = exports.Disposable = void 0;
const array_util_1 = __webpack_require__(/*! ../utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
const type_util_1 = __webpack_require__(/*! ../utils/type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
var Disposable;
(function (Disposable) {
    function is(value) {
        return type_util_1.AnyObject.is(value) && (0, type_util_1.hasFunctionProp)(value, 'dispose');
    }
    Disposable.is = is;
    /**
     * Creates a new empty i.e. no-op {@link Disposable}.
     * @returns the newly created disposable
     */
    function empty() {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        return { dispose: () => { } };
    }
    Disposable.empty = empty;
    /**
     * Creates a new {@link Disposable} that delegates to the given callback.
     * @param cb The callback that should be invoked on dispose
     * @returns the newly created disposable
     */
    function create(cb) {
        return { dispose: cb };
    }
    Disposable.create = create;
})(Disposable || (exports.Disposable = Disposable = {}));
/**
 * Reusable base class to manage a collection of {@link Disposable}s.
 */
class DisposableCollection {
    constructor(...toDispose) {
        this.disposables = [];
        toDispose.forEach(d => this.push(d));
        this.errorHandler = err => console.error(err);
    }
    dispose() {
        var _a, _b;
        if (this.disposed) {
            return;
        }
        try {
            while (!this.disposed) {
                (_a = this.disposables.pop()) === null || _a === void 0 ? void 0 : _a.dispose();
            }
        }
        catch (err) {
            (_b = this.errorHandler) === null || _b === void 0 ? void 0 : _b.call(this, err);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    push(...disposables) {
        const toAdd = (0, array_util_1.isArrayOfType)(disposables, Disposable.is) ? disposables : disposables.map(Disposable.create);
        this.disposables.push(...toAdd);
        return Disposable.create(() => (0, array_util_1.remove)(this.disposables, ...toAdd));
    }
    get isDisposed() {
        return this.disposed;
    }
    /**
     * Removes all disposables in this collection WITHOUT triggering their disposal behavior.
     */
    clear() {
        this.disposables.length = 0;
    }
}
exports.DisposableCollection = DisposableCollection;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/event.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/event.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = void 0;
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const jsonrpc = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/node/main.js");
class Emitter extends jsonrpc.Emitter {
    constructor(options = {}) {
        super(options);
    }
    /**
     * The even that is managed by this emitter.
     * Intended for the public to allow to subscribe to the emitter`s events.
     */
    get event() {
        return super.event;
    }
    /**
     * Fires and event and notifies all registered listeners
     */
    fire(event) {
        super.fire(event);
    }
}
exports.Emitter = Emitter;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-movement.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-movement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Movement = void 0;
const sprotty_geometry_point_1 = __webpack_require__(/*! ../sprotty-geometry-point */ "../../node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js");
const geometry_vector_1 = __webpack_require__(/*! ./geometry-vector */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js");
const type_util_1 = __webpack_require__(/*! ./type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
/**
 * A collection of utility functions for working with movements.

 */
var Movement;
(function (Movement) {
    /**
     * The zero movement. It has from and to set to the origin and the vector set to zero.
     */
    Movement.ZERO = Object.freeze({
        from: sprotty_geometry_point_1.Point.ORIGIN,
        to: sprotty_geometry_point_1.Point.ORIGIN,
        vector: geometry_vector_1.Vector.ZERO,
        direction: []
    });
    /**
     * A type guard that checks if the given object is a movement.
     * @param obj the object to check
     * @returns true if the object is a movement, false otherwise
     */
    function is(obj) {
        return (type_util_1.AnyObject.is(obj) &&
            (0, type_util_1.hasObjectProp)(obj, 'from') &&
            sprotty_geometry_point_1.Point.is(obj.from) &&
            (0, type_util_1.hasObjectProp)(obj, 'to') &&
            sprotty_geometry_point_1.Point.is(obj.to) &&
            (0, type_util_1.hasObjectProp)(obj, 'vector') &&
            geometry_vector_1.Vector.is(obj.to) &&
            (0, type_util_1.hasObjectProp)(obj, 'direction'));
    }
    Movement.is = is;
    /**
     * Checks if the given movement is stationary, i.e. the starting point and end point are equal and the vector is zero.
     * @param movement the movement to check
     * @returns true if the movement is stationary, false otherwise
     */
    function isStationary(movement) {
        return geometry_vector_1.Vector.isZero(movement.vector);
    }
    Movement.isStationary = isStationary;
    /**
     * Checks if the given movement is zero, i.e., all values are zero.
     * @param movement the movement to check
     * @returns true if the movement is zero, false otherwise
     */
    function isZero(movement) {
        return Movement.equals(movement, Movement.ZERO);
    }
    Movement.isZero = isZero;
    /**
     * Checks if two movements are equal. Two movements are equal if their starting points, end points, and vectors are equal.
     * @param left the left movement
     * @param right the right movement
     * @returns true if the movements are equal, false otherwise
     */
    function equals(left, right) {
        return sprotty_geometry_point_1.Point.equals(left.from, right.from) && sprotty_geometry_point_1.Point.equals(left.to, right.to) && geometry_vector_1.Vector.equals(left.vector, right.vector);
    }
    Movement.equals = equals;
})(Movement || (exports.Movement = Movement = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Direction = void 0;
/**
 * A direction in 2D space.
 */
exports.Direction = {
    Left: 'left',
    Right: 'right',
    Up: 'up',
    Down: 'down'
};


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector = void 0;
const geometry_util_1 = __webpack_require__(/*! ./geometry-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js");
const type_util_1 = __webpack_require__(/*! ./type-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js");
/**
 * A collection of utility functions for working with vectors.
 */
var Vector;
(function (Vector) {
    /**
     * The zero vector. It has x and y set to 0.
     */
    Vector.ZERO = Object.freeze({
        x: 0,
        y: 0
    });
    /**
     * Compute the absolute value of the vector.
     * @param vector the vector to compute the absolute value of
     * @returns the absolute value of the vector
     */
    function abs(vector) {
        return { x: Math.abs(vector.x), y: Math.abs(vector.y) };
    }
    Vector.abs = abs;
    /**
     * Computes the sum of two vectors.
     * @param vector the vector to add to
     * @param addend the vector to add
     * @returns the sum of the two vectors
     */
    function add(vector, addend) {
        return { x: vector.x + addend.x, y: vector.y + addend.y };
    }
    Vector.add = add;
    /**
     * Check if two vectors are equal.
     * @param left the left vector
     * @param right the right vector
     * @returns true if the vectors are equal, false otherwise
     */
    function equals(left, right) {
        return left.x === right.x && left.y === right.y;
    }
    Vector.equals = equals;
    /**
     * Check if a vector is valid. A vector is valid if it is not undefined and both x and y are numbers.
     * @param vector the vector to check
     * @returns true if the vector is valid, false otherwise
     */
    function isValid(vector) {
        return vector !== undefined && !isNaN(vector.x) && !isNaN(vector.y);
    }
    Vector.isValid = isValid;
    /**
     * Computes the magnitude of a vector defined as the square root of the sum of the squares of the x and y components.
     * @param point the vector to compute the magnitude of
     * @returns the magnitude of the vector
     */
    function magnitude(point) {
        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
    }
    Vector.magnitude = magnitude;
    /**
     * Maps each component of the vector to a new value given by the callback function.
     * @param vector the vector to map
     * @param callbackfn the function to map the components
     * @returns the mapped vector
     */
    function map(vector, callbackfn) {
        return {
            ...vector,
            x: callbackfn(vector.x, 'x'),
            y: callbackfn(vector.y, 'y')
        };
    }
    Vector.map = map;
    /**
     * Computes the normalized vector of a given vector.
     * The normalized vector has the same direction as the original vector but a magnitude of 1.
     *
     * @param vector the vector to normalize
     * @returns the normalized vector
     */
    function normalize(vector) {
        const mag = magnitude(vector);
        if (mag === 0 || mag === 1) {
            return Vector.ZERO;
        }
        return {
            x: vector.x / mag,
            y: vector.y / mag
        };
    }
    Vector.normalize = normalize;
    /**
     * Check if a vector is the zero vector.
     * @param vector the vector to check
     * @returns true if the vector is the zero vector, false otherwise
     */
    function isZero(vector) {
        return Vector.equals(vector, Vector.ZERO);
    }
    Vector.isZero = isZero;
    /**
     * Type guard to check if a value is a vector.
     * @param vector the value to check
     * @returns true if the value is a vector, false otherwise
     */
    function is(vector) {
        return type_util_1.AnyObject.is(vector) && (0, type_util_1.hasNumberProp)(vector, 'x') && (0, type_util_1.hasNumberProp)(vector, 'y');
    }
    Vector.is = is;
    /**
     * Divides each component of the vector by a scalar.
     *
     * @param vector the vector to divide
     * @param scalar the scalar to divide by
     * @returns the divided vector
     */
    function divide(vector, scalar) {
        return Vector.map(vector, coordinate => coordinate / scalar);
    }
    Vector.divide = divide;
    /**
     * Multiplies each component of the vector by a scalar.
     *
     * @param vector the vector to multiply
     * @param scalar the scalar to multiply by
     * @returns the multiplied vector
     */
    function multiply(vector, scalar) {
        return Vector.map(vector, coordinate => coordinate * scalar);
    }
    Vector.multiply = multiply;
    /**
     * Subtracts the subtrahend from the vector.
     *
     * @param vector the vector to subtract from
     * @param subtrahend the vector to subtract
     * @returns the subtracted vector
     */
    function subtract(vector, subtrahend) {
        return { x: vector.x - subtrahend.x, y: vector.y - subtrahend.y };
    }
    Vector.subtract = subtract;
    /**
     * Reverse the direction of a vector.
     * @param vector the vector to reverse
     * @returns the reversed vector
     */
    function reverse(vector) {
        return { x: -vector.x, y: -vector.y };
    }
    Vector.reverse = reverse;
    /**
     * Computes the direction of a vector
     * @param vector the vector to compute the direction of
     * @returns the direction of the vector
     */
    function direction(vector) {
        const directions = [];
        if (vector.x < 0) {
            directions.push(geometry_util_1.Direction.Left);
        }
        else if (vector.x > 0) {
            directions.push(geometry_util_1.Direction.Right);
        }
        if (vector.y < 0) {
            directions.push(geometry_util_1.Direction.Up);
        }
        else if (vector.y > 0) {
            directions.push(geometry_util_1.Direction.Down);
        }
        return directions;
    }
    Vector.direction = direction;
    /**
     * Computes a vector that is the minimum of all given vectors.
     * @returns the minimum vector
     */
    function min(...vectors) {
        return {
            x: Math.min(...vectors.map(vector => vector.x)),
            y: Math.min(...vectors.map(vector => vector.y))
        };
    }
    Vector.min = min;
    /**
     * Computes a vector that is the maximum of all given vectors.
     * @returns the maximum vector
     */
    function max(...vectors) {
        return {
            x: Math.max(...vectors.map(vector => vector.x)),
            y: Math.max(...vectors.map(vector => vector.y))
        };
    }
    Vector.max = max;
    /**
     * Computes a vector that is the average of all given vectors.
     * @returns the average vector
     */
    function avg(...vectors) {
        if (vectors.length === 0) {
            return Vector.ZERO;
        }
        return {
            x: vectors.reduce((prev, cur) => prev + cur.x, 0) / vectors.length,
            y: vectors.reduce((prev, cur) => prev + cur.y, 0) / vectors.length
        };
    }
    Vector.avg = avg;
})(Vector || (exports.Vector = Vector = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 Axon Ivy AG and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equalUpTo = void 0;
function equalUpTo(one, other, epsilon = Number.EPSILON) {
    return Math.abs(one - other) <= epsilon;
}
exports.equalUpTo = equalUpTo;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasArrayProp = exports.hasFunctionProp = exports.hasObjectProp = exports.hasNumberProp = exports.hasBooleanProp = exports.hasStringProp = exports.call = exports.toTypeGuard = exports.typeGuardOr = exports.typeGuard = exports.AnyObject = void 0;
var AnyObject;
(function (AnyObject) {
    /**
     * Type guard to check wether a given object is of type {@link AnyObject}.
     * @param object The object to check.
     * @returns The given object as {@link AnyObject} or `false`.
     */
    function is(object) {
        // eslint-disable-next-line no-null/no-null
        return object !== null && typeof object === 'object';
    }
    AnyObject.is = is;
})(AnyObject || (exports.AnyObject = AnyObject = {}));
/** Utility function to combine two type guards */
function typeGuard(one, other) {
    return (element) => one(element) && other(element);
}
exports.typeGuard = typeGuard;
/** Utility function to combine two type guards with an OR */
function typeGuardOr(one, other) {
    return (element) => one(element) || other(element);
}
exports.typeGuardOr = typeGuardOr;
/**
 * Utility function that create a typeguard function for a given class constructor.
 * Essentially this wraps an instance of check as typeguard function.
 * @param constructor The constructor of the class for which the typeguard should be created.
 * @returns The typeguard for this class.
 */
function toTypeGuard(constructor) {
    return (element) => element instanceof constructor;
}
exports.toTypeGuard = toTypeGuard;
function call(maybeFun, ...args) {
    return typeof maybeFun === 'function' ? maybeFun(...args) : maybeFun;
}
exports.call = call;
/**
 * Validates whether the given object has a property of type `string` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `string`.
 */
function hasStringProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? typeof property === 'string' : optional;
}
exports.hasStringProp = hasStringProp;
/**
 * Validates whether the given object has a property of type `boolean` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `boolean`.
 */
function hasBooleanProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? typeof property === 'boolean' : optional;
}
exports.hasBooleanProp = hasBooleanProp;
/**
 * Validates whether the given object has a property of type `number` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `number`.
 */
function hasNumberProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? typeof property === 'number' : optional;
}
exports.hasNumberProp = hasNumberProp;
/**
 * Validates whether the given object has a property of type `object` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `object`.
 */
function hasObjectProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? AnyObject.is(property) : optional;
}
exports.hasObjectProp = hasObjectProp;
/**
 * Validates whether the given object has a property of type `function` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `function`.
 */
function hasFunctionProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? typeof property === 'function' : optional;
}
exports.hasFunctionProp = hasFunctionProp;
/**
 * Validates whether the given object has a property of type `Array` with the given key.
 * @param object The object that should be validated
 * @param propertyKey The key of the property
 * @param optional Flag to indicate wether the property can be optional i.e. also return true if the given key is undefined
 * @returns `true` if the object has property with matching key of type `Array`.
 */
function hasArrayProp(object, propertyKey, optional = false) {
    const property = object[propertyKey];
    return property !== undefined ? Array.isArray(property) : optional;
}
exports.hasArrayProp = hasArrayProp;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__["default"])
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/max.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/nil.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1.js");
/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1ToV6.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v5.js");
/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6.js");
/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6ToV1.js");
/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v7.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/version.js");















/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/max.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/max.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/md5.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/md5.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ "node:crypto");
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }
  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/native.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/native.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ "node:crypto");
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)
});

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/nil.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/nil.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js");

function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }
  let v;
  const arr = new Uint8Array(16);

  // Parse ########-....-....-....-............
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff;

  // Parse ........-####-....-....-............
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff;

  // Parse ........-....-####-....-............
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff;

  // Parse ........-....-....-####-............
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff;

  // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/regex.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/regex.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/rng.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/rng.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ "node:crypto");
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/sha1.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/sha1.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ "node:crypto");
/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }
  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js");


/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  //
  // Note to future-self: No, you can't remove the `toLowerCase()` call.
  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");



// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;
let _clockseq;

// Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node;
  let clockseq = options.clockseq;

  // v1 only: Use cached `node` and `clockseq` values
  if (!options._v6) {
    if (!node) {
      node = _nodeId;
    }
    if (clockseq == null) {
      clockseq = _clockseq;
    }
  }

  // Handle cases where we need entropy.  We do this lazily to minimize issues
  // related to insufficient system entropy.  See #189
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    // Randomize node
    if (node == null) {
      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];

      // v1 only: cache node value for reuse
      if (!_nodeId && !options._v6) {
        // per RFC4122 4.5: Set MAC multicast bit (v1 only)
        node[0] |= 0x01; // Set multicast bit

        _nodeId = node;
      }
    }

    // Randomize clockseq
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      if (_clockseq === undefined && !options._v6) {
        _clockseq = clockseq;
      }
    }
  }

  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is
  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  let msecs = options.msecs !== undefined ? options.msecs : Date.now();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ v1ToV6)
/* harmony export */ });
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");



/**
 * Convert a v1 UUID to a v6 UUID
 *
 * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6
 * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg
 * (string or Uint8Array)
 */
function v1ToV6(uuid) {
  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;
}

// Do the field transformation needed for v1 -> v6
function _v1ToV6(v1Bytes, randomize = false) {
  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v3.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v3.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/md5.js");


const v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v35.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v35.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DNS: () => (/* binding */ DNS),
/* harmony export */   URL: () => (/* binding */ URL),
/* harmony export */   "default": () => (/* binding */ v35)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js");


function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }
    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }

    // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);
  }

  // Function#name is not settable on some platforms (#270)
  try {
    generateUUID.name = name;
  } catch (err) {}

  // For CommonJS default export support
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v4.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v4.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/native.js");
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");



function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v5.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v5.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/sha1.js");


const v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ v6)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1.js");
/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v1ToV6.js");




/**
 *
 * @param {object} options
 * @param {Uint8Array=} buf
 * @param {number=} offset
 * @returns
 */
function v6(options = {}, buf, offset = 0) {
  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit
  // with slightly different behavior around how the clock_seq and node fields
  // are randomized, which is why we call v1 with _v6: true.
  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    ...options,
    _v6: true
  }, new Uint8Array(16));

  // Reorder the fields to v6 layout.
  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);

  // Return as a byte array if requested
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);
}

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ v6ToV1)
/* harmony export */ });
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/parse.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");



/**
 * Convert a v6 UUID to a v1 UUID
 *
 * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6
 * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg
 * (string or Uint8Array)
 */
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid) : uuid;
  const v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;
}

// Do the field transformation needed for v6 -> v1
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v7.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/v7.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/stringify.js");



/**
 * UUID V7 - Unix Epoch time-based UUID
 *
 * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This
 * implementation of V7 is based on the accepted, though not yet approved,
 * revisions.
 *
 * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique
 * IDentifiers (UUIDs)

 *
 * Sample V7 value:
 * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value
 *
 * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:
 *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1
 *
 *   0                   1                   2                   3 0 1 2 3 4 5 6
 *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                          unix_ts_ms                           |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |          unix_ts_ms           |  ver  |        seq_hi         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |var|               seq_low               |        rand         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                             rand                              |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit
 * seq_low, and randomly initialized upon timestamp change. 31 bit counter size
 * was selected as any bitwise operations in node are done as _signed_ 32 bit
 * ints. we exclude the sign bit.
 */

let _seqLow = null;
let _seqHigh = null;
let _msecs = 0;
function v7(options, buf, offset) {
  options = options || {};

  // initialize buffer and pointer
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);

  // rnds is Uint8Array(16) filled with random bytes
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

  // milliseconds since unix epoch, 1970-01-01 00:00
  const msecs = options.msecs !== undefined ? options.msecs : Date.now();

  // seq is user provided 31 bit counter
  let seq = options.seq !== undefined ? options.seq : null;

  // initialize local seq high/low parts
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;

  // check if clock has advanced and user has not provided msecs
  if (msecs > _msecs && options.msecs === undefined) {
    _msecs = msecs;

    // unless user provided seq, reset seq parts
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }

  // if we have a user provided seq
  if (seq !== null) {
    // trim provided seq to 31 bits of value, avoiding overflow
    if (seq > 0x7fffffff) {
      seq = 0x7fffffff;
    }

    // split provided seq into high/low parts
    seqHigh = seq >>> 19 & 0xfff;
    seqLow = seq & 0x7ffff;
  }

  // randomly initialize seq
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 0x7f;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 0x3f; // pad for var
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }

  // increment seq if within msecs window
  if (msecs + 10000 > _msecs && seq === null) {
    if (++seqLow > 0x7ffff) {
      seqLow = 0;
      if (++seqHigh > 0xfff) {
        seqHigh = 0;

        // increment internal _msecs. this allows us to continue incrementing
        // while staying monotonic. Note, once we hit 10k milliseconds beyond system
        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)
        _msecs++;
      }
    }
  } else {
    // resetting; we have advanced more than
    // 10k milliseconds beyond system clock
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;

  // [bytes 0-5] 48 bits of local timestamp
  b[i++] = _msecs / 0x10000000000 & 0xff;
  b[i++] = _msecs / 0x100000000 & 0xff;
  b[i++] = _msecs / 0x1000000 & 0xff;
  b[i++] = _msecs / 0x10000 & 0xff;
  b[i++] = _msecs / 0x100 & 0xff;
  b[i++] = _msecs & 0xff;

  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi
  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;

  // [byte 7] remaining 8 bits of seq_hi
  b[i++] = seqHigh & 0xff;

  // [byte 8] - variant (2 bits), first 6 bits seq_low
  b[i++] = seqLow >>> 13 & 0x3f | 0x80;

  // [byte 9] 8 bits seq_low
  b[i++] = seqLow >>> 5 & 0xff;

  // [byte 10] remaining 5 bits seq_low, 3 bits random
  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;

  // [bytes 11-15] always random
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/regex.js");

function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/version.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/version.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/@eclipse-glsp/protocol/node_modules/uuid/dist/esm-node/validate.js");

function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.respond = exports.DefaultActionDispatcher = exports.ActionDispatcher = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const promise_queue_1 = __webpack_require__(/*! ../utils/promise-queue */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/promise-queue.js");
const action_handler_registry_1 = __webpack_require__(/*! ./action-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js");
const client_action_handler_1 = __webpack_require__(/*! ./client-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/client-action-handler.js");
exports.ActionDispatcher = Symbol('ActionDispatcher');
let DefaultActionDispatcher = class DefaultActionDispatcher {
    constructor() {
        this.actionQueue = new promise_queue_1.PromiseQueue();
        this.postUpdateQueue = [];
    }
    dispatch(action) {
        // Dont queue actions that are just delegated to the client
        if (this.clientActionForwarder.shouldForwardToClient(action)) {
            return this.doDispatch(action);
        }
        return this.actionQueue.enqueue(() => this.doDispatch(action));
    }
    async doDispatch(action) {
        this.logger.debug('Dispatch action:', action.kind);
        const handledOnClient = this.clientActionForwarder.handle(action);
        const actionHandlers = this.actionHandlerRegistry.get(action.kind);
        if (!handledOnClient && actionHandlers.length === 0) {
            throw new glsp_server_error_1.GLSPServerError(`No handler registered for action kind: ${action.kind}`);
        }
        const responses = [];
        for (const handler of actionHandlers) {
            const response = await this.executeHandler(handler, action);
            responses.push(...response);
        }
        if (this.postUpdateQueue.length > 0 && (protocol_1.UpdateModelAction.is(action) || protocol_1.SetModelAction.is(action))) {
            responses.push(...this.postUpdateQueue);
            this.postUpdateQueue = [];
        }
        await this.dispatchResponses(responses);
    }
    async executeHandler(handler, request) {
        const responseActions = await handler.execute(request);
        return responseActions.map(action => respond(request, action));
    }
    dispatchResponses(actions) {
        if (actions.length === 0) {
            return Promise.resolve();
        }
        const responseQueue = new promise_queue_1.PromiseQueue();
        const responses = actions.map(action => responseQueue.enqueue(() => this.doDispatch(action)));
        return Promise.all(responses).then(() => Promise.resolve());
    }
    dispatchAll(...actions) {
        if (actions.length === 0) {
            return Promise.resolve();
        }
        const flat = [];
        (0, protocol_1.flatPush)(flat, actions);
        return Promise.all(flat.map(action => this.dispatch(action))).then(() => Promise.resolve());
    }
    dispatchAfterNextUpdate(...actions) {
        if (actions.length !== 0) {
            (0, protocol_1.flatPush)(this.postUpdateQueue, actions);
        }
    }
    dispose() {
        this.actionQueue.clear();
    }
};
exports.DefaultActionDispatcher = DefaultActionDispatcher;
__decorate([
    (0, inversify_1.inject)(action_handler_registry_1.ActionHandlerRegistry),
    __metadata("design:type", action_handler_registry_1.ActionHandlerRegistry)
], DefaultActionDispatcher.prototype, "actionHandlerRegistry", void 0);
__decorate([
    (0, inversify_1.inject)(client_action_handler_1.ClientActionForwarder),
    __metadata("design:type", client_action_handler_1.ClientActionForwarder)
], DefaultActionDispatcher.prototype, "clientActionForwarder", void 0);
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], DefaultActionDispatcher.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.ClientId),
    __metadata("design:type", String)
], DefaultActionDispatcher.prototype, "clientId", void 0);
exports.DefaultActionDispatcher = DefaultActionDispatcher = __decorate([
    (0, inversify_1.injectable)()
], DefaultActionDispatcher);
/**
 * Transfers the {@link RequestAction.requestId id} from request to response if applicable.
 *
 * @param request  potential {@link RequestAction}
 * @param response potential {@link ResponseAction}
 * @returns given response action with id set if applicable
 */
function respond(request, response) {
    if (protocol_1.RequestAction.is(request) && protocol_1.ResponseAction.is(response)) {
        response.responseId = request.requestId;
    }
    return response;
}
exports.respond = respond;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionHandlerRegistryInitializer = exports.ActionHandlerRegistry = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js");
const action_handler_1 = __webpack_require__(/*! ./action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler.js");
/**
 * An action handler registry keeps track of registered action handlers for a certain action.
 */
let ActionHandlerRegistry = class ActionHandlerRegistry extends registry_1.MultiRegistry {
    registerHandler(handler) {
        return handler.actionKinds.forEach(kind => this.register(kind, handler));
    }
    /**
     * Retrieve all registered {@link ActionHandler}s that can handle the given action.
     * The resulting list is ordered descending using {@link ActionHandler.getPriority}.
     *
     * @param action The action
     * @returns A list of all registered handlers that can handle the given action.
     */
    get(key) {
        const result = super.get(key);
        return result.sort((a, b) => { var _a, _b; return (_a = a.priority) !== null && _a !== void 0 ? _a : 0 - ((_b = b.priority) !== null && _b !== void 0 ? _b : 0); });
    }
};
exports.ActionHandlerRegistry = ActionHandlerRegistry;
exports.ActionHandlerRegistry = ActionHandlerRegistry = __decorate([
    (0, inversify_1.injectable)()
], ActionHandlerRegistry);
let ActionHandlerRegistryInitializer = class ActionHandlerRegistryInitializer {
    constructor() {
        this.handlerConstructors = [];
    }
    initialize(_args) {
        const handlers = this.handlerConstructors.map(constructor => this.factory(constructor));
        handlers.forEach(handler => this.registry.registerHandler(handler));
    }
};
exports.ActionHandlerRegistryInitializer = ActionHandlerRegistryInitializer;
__decorate([
    (0, inversify_1.inject)(action_handler_1.ActionHandlerFactory),
    __metadata("design:type", Function)
], ActionHandlerRegistryInitializer.prototype, "factory", void 0);
__decorate([
    (0, inversify_1.inject)(action_handler_1.ActionHandlerConstructor),
    (0, inversify_1.optional)(),
    __metadata("design:type", Array)
], ActionHandlerRegistryInitializer.prototype, "handlerConstructors", void 0);
__decorate([
    (0, inversify_1.inject)(ActionHandlerRegistry),
    __metadata("design:type", ActionHandlerRegistry)
], ActionHandlerRegistryInitializer.prototype, "registry", void 0);
exports.ActionHandlerRegistryInitializer = ActionHandlerRegistryInitializer = __decorate([
    (0, inversify_1.injectable)()
], ActionHandlerRegistryInitializer);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionHandlerFactory = exports.ActionHandlerConstructor = exports.ActionHandler = void 0;
exports.ActionHandler = Symbol('ActionHandler');
exports.ActionHandlerConstructor = Symbol('ActionHandlerConstructor');
exports.ActionHandlerFactory = Symbol('ActionHandlerFactory');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/actions/client-action-handler.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/actions/client-action-handler.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientActionForwarder = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const client_action_1 = __webpack_require__(/*! ../protocol/client-action */ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/client-action.js");
/**
 * Component responsible for forwarding actions that are (also) handled by the
 * client
 */
let ClientActionForwarder = class ClientActionForwarder {
    constructor(actionKinds) {
        this.actionKinds = actionKinds;
    }
    /**
     * Processes the given action and checks wether it is a
     * `clientAction` i.e. an action that should be forwarded to
     * the client to be handled there. If the check is successful
     * the action is wrapped in an {@link ActionMessage} and sent to the client.
     *
     * @param action The action to check and forward
     * @return `true` if the action was forwarded to the client, `false` otherwise
     */
    handle(action) {
        if (this.shouldForwardToClient(action)) {
            const message = { action, clientId: this.clientId };
            this.glspClient.process(message);
            return true;
        }
        return false;
    }
    shouldForwardToClient(action) {
        if (client_action_1.ClientAction.is(action)) {
            return false;
        }
        return this.actionKinds.has(action.kind) || protocol_1.ResponseAction.is(action);
    }
};
exports.ClientActionForwarder = ClientActionForwarder;
__decorate([
    (0, inversify_1.inject)(protocol_1.GLSPClientProxy),
    __metadata("design:type", Object)
], ClientActionForwarder.prototype, "glspClient", void 0);
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.ClientId),
    __metadata("design:type", String)
], ClientActionForwarder.prototype, "clientId", void 0);
exports.ClientActionForwarder = ClientActionForwarder = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(service_identifiers_1.ClientActionKinds)),
    __metadata("design:paramtypes", [Set])
], ClientActionForwarder);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/actions/global-action-provider.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/actions/global-action-provider.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGlobalActionProvider = exports.GlobalActionProvider = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const client_session_module_1 = __webpack_require__(/*! ../di/client-session-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/client-session-module.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const client_session_initializer_1 = __webpack_require__(/*! ../session/client-session-initializer */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js");
const action_handler_registry_1 = __webpack_require__(/*! ./action-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js");
exports.GlobalActionProvider = Symbol('GlobalActionProvider');
let DefaultGlobalActionProvider = class DefaultGlobalActionProvider {
    constructor(serverContainer, diagramModules) {
        this.actionKinds = new Map();
        diagramModules.forEach((modules, diagramType) => {
            const container = this.createDiagramContainer(serverContainer, modules);
            const initializers = container.getAll(client_session_initializer_1.ClientSessionInitializer);
            initializers.forEach(service => service.initialize());
            this.loadActionKinds(diagramType, container);
            container.unbindAll();
        });
    }
    createDiagramContainer(serverContainer, modules) {
        const container = serverContainer.createChild();
        const clientSessionModule = (0, client_session_module_1.createClientSessionModule)({
            clientId: 'tempId',
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            glspClient: { process: () => { } },
            clientActionKinds: []
        });
        container.load(...modules, clientSessionModule);
        return container;
    }
    loadActionKinds(diagramType, diagramContainer) {
        var _a;
        const handlerRegistry = diagramContainer.get(action_handler_registry_1.ActionHandlerRegistry);
        const diagramServerActions = (_a = this.actionKinds.get(diagramType)) !== null && _a !== void 0 ? _a : [];
        handlerRegistry.getAll().forEach(handler => (0, protocol_1.distinctAdd)(diagramServerActions, ...handler.actionKinds));
        this.actionKinds.set(diagramType, diagramServerActions);
    }
};
exports.DefaultGlobalActionProvider = DefaultGlobalActionProvider;
exports.DefaultGlobalActionProvider = DefaultGlobalActionProvider = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(service_identifiers_1.InjectionContainer)),
    __param(1, (0, inversify_1.inject)(service_identifiers_1.DiagramModules)),
    __metadata("design:paramtypes", [inversify_1.Container,
        Map])
], DefaultGlobalActionProvider);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultCommandStack = exports.CommandStack = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const command_1 = __webpack_require__(/*! ./command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command.js");
exports.CommandStack = Symbol('CommandStack');
let DefaultCommandStack = class DefaultCommandStack {
    constructor() {
        this.commands = [];
        /**
         * The current position within the command list from which the next execute, undo, or redo, will be performed.
         */
        this.top = -1;
        /**
         * The current position within the command list when {@link DefaultCommandStack.saveIsDone} is called.
         */
        this.saveIndex = -1;
    }
    async execute(command) {
        try {
            await command.execute();
        }
        catch (error) {
            this.handleError(error);
        }
        // Clear the command list past the top (i.e. the old redo list)
        this.commands = this.commands.slice(0, this.top + 1);
        this.commands.push(command);
        ++this.top;
        // if the saveIndex points to the old redo list we can never reach a state again
        // where save is not necessary. => ensure that `isDirty` always returns true
        if (this.saveIndex >= this.top) {
            this.saveIndex = -2;
        }
    }
    async undo() {
        if (this.canUndo()) {
            const command = this.commands[this.top--];
            try {
                await command.undo();
            }
            catch (error) {
                this.handleError(error);
            }
        }
    }
    canUndo() {
        return this.top !== -1 //
            ? command_1.Command.canUndo(this.commands[this.top])
            : false;
    }
    async redo() {
        if (this.canRedo()) {
            const command = this.commands[++this.top];
            try {
                await command.redo();
            }
            catch (error) {
                this.handleError(error);
            }
        }
    }
    canRedo() {
        return this.top < this.commands.length - 1;
    }
    get isDirty() {
        return this.saveIndex !== this.top;
    }
    saveIsDone() {
        this.saveIndex = this.top;
    }
    flush() {
        this.commands = [];
        this.top = -1;
        this.saveIndex = -1;
    }
    handleError(error) {
        // if an error occurred during the command execution the stack might be in an erroneous state => we have to flush the command stack
        this.flush();
        this.logger.error('An error occurred during command execution. CommandStack will be flushed!', error);
        throw error;
    }
};
exports.DefaultCommandStack = DefaultCommandStack;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], DefaultCommandStack.prototype, "logger", void 0);
exports.DefaultCommandStack = DefaultCommandStack = __decorate([
    (0, inversify_1.injectable)()
], DefaultCommandStack);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/command/command.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/command/command.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompoundCommand = exports.Command = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
var Command;
(function (Command) {
    function canUndo(command) {
        var _a, _b;
        return (_b = (_a = command.canUndo) === null || _a === void 0 ? void 0 : _a.call(command)) !== null && _b !== void 0 ? _b : true;
    }
    Command.canUndo = canUndo;
})(Command || (exports.Command = Command = {}));
/**
 * A command that comprises a sequence of subcommands.
 */
class CompoundCommand {
    constructor(...commands) {
        this.commands = [];
        (0, protocol_1.flatPush)(this.commands, commands);
    }
    async execute() {
        const alreadyExecuted = [];
        try {
            for (const command of this.commands) {
                await command.execute();
                alreadyExecuted.unshift(command);
            }
        }
        catch (err) {
            for (const command of alreadyExecuted) {
                if (Command.canUndo(command)) {
                    await command.undo();
                }
                else {
                    break;
                }
            }
            throw err;
        }
    }
    async undo() {
        const alreadyUndone = [];
        try {
            for (const command of [...this.commands].reverse()) {
                await command.undo();
                alreadyUndone.unshift(command);
            }
        }
        catch (err) {
            for (const command of alreadyUndone) {
                await command.redo();
            }
            throw err;
        }
    }
    async redo() {
        const alreadyRedone = [];
        try {
            for (const command of this.commands) {
                await command.redo();
                alreadyRedone.unshift(command);
            }
        }
        catch (err) {
            for (const command of alreadyRedone) {
                await command.undo();
            }
            throw err;
        }
    }
    canUndo() {
        return this.commands.every(Command.canUndo);
    }
}
exports.CompoundCommand = CompoundCommand;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelRecordingCommand = exports.AbstractRecordingCommand = void 0;
const jsonPatch = __webpack_require__(/*! fast-json-patch */ "../../node_modules/fast-json-patch/index.mjs");
/**
 * An abstract implementation for {@link Command} that should records changes made to a JSON object during execution.
 * These changes are recorded in the form of json patches.
 */
class AbstractRecordingCommand {
    async execute() {
        var _a;
        const beforeState = this.deepClone(await this.getJsonObject());
        await this.doExecute();
        const afterState = await this.getJsonObject();
        this.undoPatch = jsonPatch.compare(afterState, beforeState);
        this.redoPatch = jsonPatch.compare(beforeState, afterState);
        await ((_a = this.postChange) === null || _a === void 0 ? void 0 : _a.call(this, afterState));
    }
    applyPatch(object, patch) {
        return jsonPatch.applyPatch(object, patch, false, true);
    }
    /**
     * Captures the original state of the JSON object before executing the command routine.
     * This implementation cannot clone circular structures as it relies on `JSON.stringify`.
     * @param object The object that should be cloned
     * @returns A deep clone of the given object
     */
    deepClone(object) {
        return jsonPatch.deepClone(object);
    }
    async undo() {
        var _a;
        if (this.undoPatch) {
            const result = this.applyPatch(await this.getJsonObject(), this.undoPatch);
            await ((_a = this.postChange) === null || _a === void 0 ? void 0 : _a.call(this, result.newDocument));
        }
    }
    async redo() {
        var _a;
        if (this.redoPatch) {
            const result = this.applyPatch(await this.getJsonObject(), this.redoPatch);
            await ((_a = this.postChange) === null || _a === void 0 ? void 0 : _a.call(this, result.newDocument));
        }
    }
    canUndo() {
        return !!this.undoPatch && !!this.redoPatch;
    }
}
exports.AbstractRecordingCommand = AbstractRecordingCommand;
/**
 * Simple base implementation of {@link AbstractRecordingCommand} that allows recording of changes made
 * to the `GModelRoot` ({@link ModelState.root}) during the given `doExecute` function
 */
class GModelRecordingCommand extends AbstractRecordingCommand {
    constructor(modelState, serializer, doExecute) {
        super();
        this.modelState = modelState;
        this.serializer = serializer;
        this.doExecute = doExecute;
    }
    getJsonObject() {
        return this.serializer.createSchema(this.modelState.root);
    }
    postChange(newModel) {
        const newRoot = this.serializer.createRoot(newModel);
        this.modelState.updateRoot(newRoot);
    }
}
exports.GModelRecordingCommand = GModelRecordingCommand;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/command/undo-redo-action-handler.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/command/undo-redo-action-handler.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UndoRedoActionHandler = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const model_submission_handler_1 = __webpack_require__(/*! ../features/model/model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js");
const command_stack_1 = __webpack_require__(/*! ./command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js");
let UndoRedoActionHandler = class UndoRedoActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.UndoAction.KIND, protocol_1.RedoAction.KIND];
    }
    execute(action) {
        if (protocol_1.UndoAction.is(action)) {
            return this.undo();
        }
        else if (protocol_1.RedoAction.is(action)) {
            return this.redo();
        }
        return [];
    }
    async undo() {
        if (this.commandStack.canUndo()) {
            await this.commandStack.undo();
            return this.modelSubmissionHandler.submitModel('undo');
        }
        return [];
    }
    async redo() {
        if (this.commandStack.canRedo()) {
            await this.commandStack.redo();
            return this.modelSubmissionHandler.submitModel('redo');
        }
        return [];
    }
};
exports.UndoRedoActionHandler = UndoRedoActionHandler;
__decorate([
    (0, inversify_1.inject)(command_stack_1.CommandStack),
    __metadata("design:type", Object)
], UndoRedoActionHandler.prototype, "commandStack", void 0);
__decorate([
    (0, inversify_1.inject)(model_submission_handler_1.ModelSubmissionHandler),
    __metadata("design:type", model_submission_handler_1.ModelSubmissionHandler)
], UndoRedoActionHandler.prototype, "modelSubmissionHandler", void 0);
exports.UndoRedoActionHandler = UndoRedoActionHandler = __decorate([
    (0, inversify_1.injectable)()
], UndoRedoActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isConstructor = exports.ServiceTarget = exports.ConstantValueTarget = exports.applyOptionalBindingTarget = exports.applyBindingTarget = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
/**
 * Collection of utility types and functions to enable flexible service binding with dedicated
 * binding methods in the GLSP DI modules
 */
/**
 * Binds the given service identifier to the given {@link BindingTarget}. If the service identifier is
 * a {@link Constructor} and the target is the same constructor the service identifier will be bound to itself.
 * @param bind The inversify bind function (typically provided from a GLSP DI module)
 * @param serviceIdentifier The service identifier that should be bound.
 * @param target The binding target.
 * @returns The corresponding {@link interfaces.BindingInWhenOnSyntax}.
 */
function applyBindingTarget(context, serviceIdentifier, target) {
    if (isConstructor(target)) {
        // If service identifier and target are the same constructor => self binding
        return serviceIdentifier === target //
            ? context.bind(serviceIdentifier).toSelf()
            : context.bind(serviceIdentifier).to(target);
    }
    else if (ServiceTarget.is(target)) {
        if (!context.isBound(target.service)) {
            const autoBind = target.autoBind === undefined || target.autoBind === true;
            if (autoBind && isConstructor(target.service)) {
                context.bind(target.service).toSelf().inSingletonScope();
            }
            else {
                throw new Error(`The target service ${target.service.toString()} is not bound!. Cannot apply target binding`);
            }
        }
        context.bind(serviceIdentifier).toService(target.service);
        return NoOPSyntax.serviceSyntax(serviceIdentifier, target);
    }
    else if (ConstantValueTarget.is(target)) {
        const whenOnSyntax = context.bind(serviceIdentifier).toConstantValue(target.constantValue);
        return NoOPSyntax.constantValueSyntax(serviceIdentifier, whenOnSyntax);
    }
    else {
        return context.bind(serviceIdentifier).toDynamicValue(_context => target.dynamicValue(_context));
    }
}
exports.applyBindingTarget = applyBindingTarget;
function applyOptionalBindingTarget(context, serviceIdentifier, target) {
    if (target) {
        return applyBindingTarget(context, serviceIdentifier, target);
    }
    return undefined;
}
exports.applyOptionalBindingTarget = applyOptionalBindingTarget;
var ConstantValueTarget;
(function (ConstantValueTarget) {
    function is(object) {
        return protocol_1.AnyObject.is(object) && 'constantValue' in object;
    }
    ConstantValueTarget.is = is;
})(ConstantValueTarget || (exports.ConstantValueTarget = ConstantValueTarget = {}));
var ServiceTarget;
(function (ServiceTarget) {
    function is(object) {
        return protocol_1.AnyObject.is(object) && 'service' in object;
    }
    ServiceTarget.is = is;
})(ServiceTarget || (exports.ServiceTarget = ServiceTarget = {}));
/**
 * No-op binding syntax definitions for `constantValue` and `toService` bindings.
 * Using this no-op syntaxes allows the {@link applyBindingTarget} function to return a {@link interfaces.BindingInWhenOnSyntax}
 * independently of the actual {@link BindingTarget}.
 */
var NoOPSyntax;
(function (NoOPSyntax) {
    function constantValueSyntax(serviceIdentifier, syntax) {
        const noOpReturn = (scope) => {
            console.warn(`${serviceIdentifier.toString()} has been bound to 'constantValue'. Binding in ${scope} scope has no effect.` +
                'Constant value bindings are effectively Singleton bindings.');
            return syntax;
        };
        return {
            ...syntax,
            inSingletonScope: () => noOpReturn('Singleton'),
            inRequestScope: () => noOpReturn('Request'),
            inTransientScope: () => noOpReturn('Transient')
        };
    }
    NoOPSyntax.constantValueSyntax = constantValueSyntax;
    function serviceSyntax(serviceIdentifier, target) {
        const noOpReturn = () => {
            const errorMsg = `${serviceIdentifier.toString()} has been bound to 'service'.` +
                "Using 'in','when' or 'on' bindings after" +
                "a 'toService' binding is not possible.";
            const error = new Error(errorMsg);
            error.name = 'NoOpInvocation';
            throw error;
        };
        const syntax = {
            onActivation: noOpReturn,
            onDeactivation: noOpReturn,
            when: noOpReturn,
            whenAnyAncestorIs: noOpReturn,
            whenAnyAncestorMatches: noOpReturn,
            whenAnyAncestorNamed: noOpReturn,
            whenAnyAncestorTagged: noOpReturn,
            whenInjectedInto: noOpReturn,
            whenNoAncestorIs: noOpReturn,
            whenNoAncestorMatches: noOpReturn,
            whenNoAncestorNamed: noOpReturn,
            whenNoAncestorTagged: noOpReturn,
            whenParentNamed: noOpReturn,
            whenParentTagged: noOpReturn,
            whenTargetIsDefault: noOpReturn,
            whenTargetNamed: noOpReturn,
            whenTargetTagged: noOpReturn,
            inRequestScope: noOpReturn,
            inSingletonScope: () => {
                if (ServiceTarget.is(target)) {
                    // toService bindings are essentially singleTons.
                    // We don't throw an error in this case.
                    return syntax;
                }
                return noOpReturn();
            },
            inTransientScope: noOpReturn
        };
        return syntax;
    }
    NoOPSyntax.serviceSyntax = serviceSyntax;
})(NoOPSyntax || (NoOPSyntax = {}));
function isConstructor(object) {
    return typeof object === 'function' && !!object.prototype && !!object.prototype.constructor;
}
exports.isConstructor = isConstructor;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/client-session-module.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/client-session-module.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createClientSessionModule = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const di_1 = __webpack_require__(/*! @eclipse-glsp/protocol/lib/di */ "../../node_modules/@eclipse-glsp/protocol/lib/di/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ./service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
/**
 * Creates the DI module that binds client session specific configuration
 */
function createClientSessionModule(options) {
    return new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, di_1.bindOrRebind)(context, service_identifiers_1.ClientId).toConstantValue(options.clientId);
        bind(protocol_1.GLSPClientProxy).toConstantValue(options.glspClient);
        bind(service_identifiers_1.ClientActionKinds).toConstantValue(new Set(options.clientActionKinds));
    });
}
exports.createClientSessionModule = createClientSessionModule;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/diagram-module.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/diagram-module.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagramModule = void 0;
const action_dispatcher_1 = __webpack_require__(/*! ../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
const action_handler_1 = __webpack_require__(/*! ../actions/action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler.js");
const action_handler_registry_1 = __webpack_require__(/*! ../actions/action-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js");
const client_action_handler_1 = __webpack_require__(/*! ../actions/client-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/client-action-handler.js");
const command_stack_1 = __webpack_require__(/*! ../command/command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js");
const undo_redo_action_handler_1 = __webpack_require__(/*! ../command/undo-redo-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/command/undo-redo-action-handler.js");
const diagram_configuration_1 = __webpack_require__(/*! ../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
const command_palette_action_provider_1 = __webpack_require__(/*! ../features/contextactions/command-palette-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/command-palette-action-provider.js");
const context_actions_provider_registry_1 = __webpack_require__(/*! ../features/contextactions/context-actions-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider-registry.js");
const context_menu_item_provider_1 = __webpack_require__(/*! ../features/contextactions/context-menu-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-menu-item-provider.js");
const request_context_actions_handler_1 = __webpack_require__(/*! ../features/contextactions/request-context-actions-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/request-context-actions-handler.js");
const tool_palette_item_provider_1 = __webpack_require__(/*! ../features/contextactions/tool-palette-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/tool-palette-item-provider.js");
const context_edit_validator_registry_1 = __webpack_require__(/*! ../features/directediting/context-edit-validator-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator-registry.js");
const label_edit_validator_1 = __webpack_require__(/*! ../features/directediting/label-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js");
const request_edit_validation_handler_1 = __webpack_require__(/*! ../features/directediting/request-edit-validation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/request-edit-validation-handler.js");
const computed_bounds_action_handler_1 = __webpack_require__(/*! ../features/layout/computed-bounds-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/computed-bounds-action-handler.js");
const layout_engine_1 = __webpack_require__(/*! ../features/layout/layout-engine */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js");
const layout_operation_handler_1 = __webpack_require__(/*! ../features/layout/layout-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-operation-handler.js");
const gmodel_factory_1 = __webpack_require__(/*! ../features/model/gmodel-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js");
const gmodel_index_1 = __webpack_require__(/*! ../features/model/gmodel-index */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-index.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../features/model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const model_state_1 = __webpack_require__(/*! ../features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const model_submission_handler_1 = __webpack_require__(/*! ../features/model/model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js");
const request_model_action_handler_1 = __webpack_require__(/*! ../features/model/request-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/request-model-action-handler.js");
const save_model_action_handler_1 = __webpack_require__(/*! ../features/model/save-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/save-model-action-handler.js");
const source_model_storage_1 = __webpack_require__(/*! ../features/model/source-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js");
const navigation_target_provider_registry_1 = __webpack_require__(/*! ../features/navigation/navigation-target-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider-registry.js");
const navigation_target_resolver_1 = __webpack_require__(/*! ../features/navigation/navigation-target-resolver */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolver.js");
const request_navigation_targets_action_handler_1 = __webpack_require__(/*! ../features/navigation/request-navigation-targets-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/request-navigation-targets-action-handler.js");
const resolve_navigation_targets_action_handler_1 = __webpack_require__(/*! ../features/navigation/resolve-navigation-targets-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/resolve-navigation-targets-action-handler.js");
const popup_model_factory_1 = __webpack_require__(/*! ../features/popup/popup-model-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/popup-model-factory.js");
const request_popup_model_action_handler_1 = __webpack_require__(/*! ../features/popup/request-popup-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/request-popup-model-action-handler.js");
const progress_service_1 = __webpack_require__(/*! ../features/progress/progress-service */ "../../node_modules/@eclipse-glsp/server/lib/common/features/progress/progress-service.js");
const edge_creation_checker_1 = __webpack_require__(/*! ../features/type-hints/edge-creation-checker */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/edge-creation-checker.js");
const request_check_edge_action_handler_1 = __webpack_require__(/*! ../features/type-hints/request-check-edge-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-check-edge-action-handler.js");
const request_type_hints_action_handler_1 = __webpack_require__(/*! ../features/type-hints/request-type-hints-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-type-hints-action-handler.js");
const model_validator_1 = __webpack_require__(/*! ../features/validation/model-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js");
const request_markers_handler_1 = __webpack_require__(/*! ../features/validation/request-markers-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/request-markers-handler.js");
const compound_operation_handler_1 = __webpack_require__(/*! ../operations/compound-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/compound-operation-handler.js");
const operation_action_handler_1 = __webpack_require__(/*! ../operations/operation-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-action-handler.js");
const operation_handler_1 = __webpack_require__(/*! ../operations/operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
const operation_handler_registry_1 = __webpack_require__(/*! ../operations/operation-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js");
const client_session_initializer_1 = __webpack_require__(/*! ../session/client-session-initializer */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js");
const binding_target_1 = __webpack_require__(/*! ./binding-target */ "../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js");
const glsp_module_1 = __webpack_require__(/*! ./glsp-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/glsp-module.js");
const multi_binding_1 = __webpack_require__(/*! ./multi-binding */ "../../node_modules/@eclipse-glsp/server/lib/common/di/multi-binding.js");
const service_identifiers_1 = __webpack_require__(/*! ./service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
/**
 * The diagram module is the central configuration artifact for configuring a client session specific injector. For each
 * session that is initialized by a {@link GLSPServer} a new client session injector is created. The diagram module
 * provides the base bindings necessary to provide diagram implementation (i.e. diagram language). In addition to the
 * diagram specific bindings, session specific bindings like the {@link ModelState} are configured
 *
 * Client session injectors are child injectors of a server injector and therefore inherit the bindings from
 * {@link ServerModule}.
 *
 * The following bindings are provided:
 * - {@link DiagramType}
 * - {@link ClientId}
 * - {@link DiagramConfiguration}
 * - {@link GModelSerializer}
 * - {@link ModelState}
 * - {@link GModelIndex}
 * - {@link SourceModelStorage}
 * - {@link GModelFactory}
 * - {@link ModelSubmissionHandler}
 * - {@link ModelValidator} as optional binding
 * - {@link LabelEditValidator} as optional binding
 * - {@link ToolPaletteItemProvider}as optional binding
 * - {@link CommandPaletteActionProvider}as optional binding
 * - {@link ContextMenuItemProvider} as optional binding
 * - {@link ContextActionsProviders} as {@link ClassMultiBinding<ContextActionsProvider>} (empty)
 * - {@link ContextActionsProviderRegistry}
 * - {@link ActionDispatcher}
 * - {@link ProgressService}
 * - {@link ClientActionKinds} as {@link InstanceMultiBinding<string>}
 * - {@link ActionHandler} as {@link InstanceMultiBinding<ActionHandlerConstructor>}
 * - {@link ActionHandlerFactory}
 * - {@link ActionHandlerRegistry}
 * - {@link OperationHandler} as {@link InstanceMultiBinding<OperationHandlerConstructor>}
 * - {@link OperationHandlerFactory}
 * - {@link OperationHandlerRegistry}
 * - {@link Operations}
 * - {@link CommandStack}
 * - {@link NavigationTargetResolver} as optional binding
 *   {@link NavigationTargetProvider} as {@link ClassMultiBinding<NavigationTargetProvider>} (empty)
 * - {@link NavigationTargetProviderRegistry}
 * - {@link ContextEditValidatorRegistry}
 * - {@link ContextEditValidators} as {@link ClassMultiBinding<ContextActionsProvider>} (empty)
 * - {@link ClientSessionInitializer} as {@link ClassMultiBinding<ClientSessionInitializer>}
 * - {@link PopupModelFactory}  as optional binding
 * - {@link LayoutEngine}  as optional binding
 * - {@link EdgeCreationChecker}  as optional binding
 */
class DiagramModule extends glsp_module_1.GLSPModule {
    configure(bind, unbind, isBound, rebind) {
        var _a, _b, _c, _d;
        const context = { bind, isBound };
        // Configurations
        (0, binding_target_1.applyBindingTarget)(context, service_identifiers_1.DiagramType, this.bindDiagramType());
        (0, binding_target_1.applyBindingTarget)(context, service_identifiers_1.ClientId, this.bindClientId());
        (0, binding_target_1.applyBindingTarget)(context, diagram_configuration_1.DiagramConfiguration, this.bindDiagramConfiguration()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, client_action_handler_1.ClientActionForwarder, this.bindClientActionForwarder()).inSingletonScope();
        // Model-related bindings
        (0, binding_target_1.applyBindingTarget)(context, gmodel_serializer_1.GModelSerializer, this.bindGModelSerializer()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, model_state_1.ModelState, this.bindModelState()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, gmodel_index_1.GModelIndex, this.bindGModelIndex()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, source_model_storage_1.SourceModelStorage, this.bindSourceModelStorage()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, gmodel_factory_1.GModelFactory, this.bindGModelFactory());
        (0, binding_target_1.applyBindingTarget)(context, model_submission_handler_1.ModelSubmissionHandler, this.bindModelSubmissionHandler()).inSingletonScope();
        // Model Validation
        (0, binding_target_1.applyOptionalBindingTarget)(context, model_validator_1.ModelValidator, this.bindModelValidator());
        (0, binding_target_1.applyOptionalBindingTarget)(context, label_edit_validator_1.LabelEditValidator, this.bindLabelEditValidator());
        // Context action providers
        (0, binding_target_1.applyOptionalBindingTarget)(context, tool_palette_item_provider_1.ToolPaletteItemProvider, this.bindToolPaletteItemProvider());
        (0, binding_target_1.applyOptionalBindingTarget)(context, command_palette_action_provider_1.CommandPaletteActionProvider, this.bindCommandPaletteActionProvider());
        (0, binding_target_1.applyOptionalBindingTarget)(context, context_menu_item_provider_1.ContextMenuItemProvider, this.bindContextMenuItemProvider());
        this.configureMultiBinding(new multi_binding_1.MultiBinding(service_identifiers_1.ContextActionsProviders), binding => this.configureContextActionProviders(binding));
        (0, binding_target_1.applyBindingTarget)(context, context_actions_provider_registry_1.ContextActionsProviderRegistry, this.bindContextActionsProviderRegistry()).inSingletonScope();
        // Action & operation related bindings
        (0, binding_target_1.applyBindingTarget)(context, action_dispatcher_1.ActionDispatcher, this.bindActionDispatcher()).inSingletonScope();
        this.configureMultiBinding(new multi_binding_1.InstanceMultiBinding(action_handler_1.ActionHandlerConstructor), binding => this.configureActionHandlers(binding));
        (0, binding_target_1.applyBindingTarget)(context, action_handler_1.ActionHandlerFactory, this.bindActionHandlerFactory());
        (0, binding_target_1.applyBindingTarget)(context, action_handler_registry_1.ActionHandlerRegistry, this.bindActionHandlerRegistry()).inSingletonScope();
        this.configureMultiBinding(new multi_binding_1.InstanceMultiBinding(operation_handler_1.OperationHandlerConstructor), binding => this.configureOperationHandlers(binding));
        (0, binding_target_1.applyBindingTarget)(context, operation_handler_registry_1.OperationHandlerRegistry, this.bindOperationHandlerRegistry()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, operation_handler_1.OperationHandlerFactory, this.bindOperationHandlerFactory());
        (0, binding_target_1.applyBindingTarget)(context, service_identifiers_1.Operations, this.bindOperations()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, command_stack_1.CommandStack, this.bindCommandStack()).inSingletonScope();
        // Navigation
        (_a = (0, binding_target_1.applyOptionalBindingTarget)(context, navigation_target_resolver_1.NavigationTargetResolver, this.bindNavigationTargetResolver())) === null || _a === void 0 ? void 0 : _a.inSingletonScope();
        this.configureMultiBinding(new multi_binding_1.MultiBinding(service_identifiers_1.NavigationTargetProviders), binding => this.configureNavigationTargetProviders(binding));
        (0, binding_target_1.applyBindingTarget)(context, navigation_target_provider_registry_1.NavigationTargetProviderRegistry, this.bindNavigationTargetProviderRegistry()).inSingletonScope();
        // Context edit
        (0, binding_target_1.applyBindingTarget)(context, context_edit_validator_registry_1.ContextEditValidatorRegistry, this.bindContextEditValidatorRegistry()).inSingletonScope();
        this.configureMultiBinding(new multi_binding_1.MultiBinding(service_identifiers_1.ContextEditValidators), binding => this.configureContextEditValidators(binding));
        // Misc
        this.configureMultiBinding(new multi_binding_1.MultiBinding(client_session_initializer_1.ClientSessionInitializer), binding => this.configureClientSessionInitializers(binding));
        (0, binding_target_1.applyBindingTarget)(context, progress_service_1.ProgressService, this.bindProgressService()).inSingletonScope();
        (_b = (0, binding_target_1.applyOptionalBindingTarget)(context, popup_model_factory_1.PopupModelFactory, this.bindPopupModelFactory())) === null || _b === void 0 ? void 0 : _b.inSingletonScope();
        (_c = (0, binding_target_1.applyOptionalBindingTarget)(context, layout_engine_1.LayoutEngine, this.bindLayoutEngine())) === null || _c === void 0 ? void 0 : _c.inSingletonScope();
        (_d = (0, binding_target_1.applyOptionalBindingTarget)(context, edge_creation_checker_1.EdgeCreationChecker, this.bindEdgeCreationChecker())) === null || _d === void 0 ? void 0 : _d.inSingletonScope();
    }
    configureClientSessionInitializers(binding) {
        binding.add(action_handler_registry_1.ActionHandlerRegistryInitializer);
        binding.add(operation_handler_registry_1.OperationHandlerRegistryInitializer);
    }
    configureActionHandlers(binding) {
        binding.add(request_model_action_handler_1.RequestModelActionHandler);
        binding.add(request_context_actions_handler_1.RequestContextActionsHandler);
        binding.add(request_type_hints_action_handler_1.RequestTypeHintsActionHandler);
        binding.add(operation_action_handler_1.OperationActionHandler);
        binding.add(request_check_edge_action_handler_1.RequestCheckEdgeActionHandler);
        binding.add(request_markers_handler_1.RequestMarkersHandler);
        binding.add(request_popup_model_action_handler_1.RequestPopupModelActionHandler);
        binding.add(request_edit_validation_handler_1.RequestEditValidationHandler);
        binding.add(request_navigation_targets_action_handler_1.RequestNavigationTargetsActionHandler);
        binding.add(resolve_navigation_targets_action_handler_1.ResolveNavigationTargetsActionHandler);
        binding.add(save_model_action_handler_1.SaveModelActionHandler);
        binding.add(undo_redo_action_handler_1.UndoRedoActionHandler);
        binding.add(computed_bounds_action_handler_1.ComputedBoundsActionHandler);
    }
    bindDiagramType() {
        return { constantValue: this.diagramType };
    }
    bindClientId() {
        return { constantValue: DiagramModule.FALLBACK_CLIENT_ID };
    }
    bindGModelSerializer() {
        return gmodel_serializer_1.DefaultGModelSerializer;
    }
    bindClientActionForwarder() {
        return client_action_handler_1.ClientActionForwarder;
    }
    bindGModelIndex() {
        return gmodel_index_1.GModelIndex;
    }
    bindActionDispatcher() {
        return action_dispatcher_1.DefaultActionDispatcher;
    }
    bindActionHandlerRegistry() {
        return action_handler_registry_1.ActionHandlerRegistry;
    }
    bindOperationHandlerRegistry() {
        return operation_handler_registry_1.OperationHandlerRegistry;
    }
    bindModelSubmissionHandler() {
        return model_submission_handler_1.ModelSubmissionHandler;
    }
    bindNavigationTargetProviderRegistry() {
        return navigation_target_provider_registry_1.DefaultNavigationTargetProviderRegistry;
    }
    bindContextEditValidatorRegistry() {
        return context_edit_validator_registry_1.DefaultContextEditValidatorRegistry;
    }
    bindActionHandlerFactory() {
        return { dynamicValue: ctx => constructor => ctx.container.resolve(constructor) };
    }
    bindOperationHandlerFactory() {
        return { dynamicValue: ctx => constructor => ctx.container.resolve(constructor) };
    }
    bindOperations() {
        return {
            dynamicValue: context => context.container
                .get(operation_handler_1.OperationHandlerConstructor)
                .map(constructor => new constructor().operationType)
        };
    }
    bindCommandStack() {
        return command_stack_1.DefaultCommandStack;
    }
    configureOperationHandlers(binding) {
        binding.add(compound_operation_handler_1.CompoundOperationHandler);
        binding.add(layout_operation_handler_1.LayoutOperationHandler);
    }
    bindProgressService() {
        return progress_service_1.DefaultProgressService;
    }
    configureContextActionProviders(binding) {
        // empty as default
    }
    configureContextEditValidators(binding) {
        // empty as default
    }
    configureNavigationTargetProviders(binding) {
        // empty as default
    }
    bindContextActionsProviderRegistry() {
        return context_actions_provider_registry_1.ContextActionsProviderRegistry;
    }
    // Optional bindings
    bindModelValidator() {
        return undefined;
    }
    bindLabelEditValidator() {
        return undefined;
    }
    bindToolPaletteItemProvider() {
        return tool_palette_item_provider_1.DefaultToolPaletteItemProvider;
    }
    bindCommandPaletteActionProvider() {
        return undefined;
    }
    bindContextMenuItemProvider() {
        return undefined;
    }
    bindNavigationTargetResolver() {
        return undefined;
    }
    bindPopupModelFactory() {
        return undefined;
    }
    bindLayoutEngine() {
        return undefined;
    }
    bindEdgeCreationChecker() {
        return undefined;
    }
}
exports.DiagramModule = DiagramModule;
DiagramModule.FALLBACK_CLIENT_ID = 'FallbackClientId';


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/glsp-module.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/glsp-module.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPModule = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
/**
 * Common super class for GLSP {@link ContainerModule}s.
 */
let GLSPModule = class GLSPModule extends inversify_1.ContainerModule {
    constructor() {
        super((bind, unbind, isBound, rebind) => {
            this.context = { bind, unbind, isBound, rebind };
            this.configure(bind, unbind, isBound, rebind);
        });
    }
    /**
     * Configuration method for multibound values. The passed configurator is typically a submethod of this module. This
     * means
     * that subclasses can customize the {@link MultiBinding} object before the actual {@link MultiBinding} is created.
     *
     * @param <T>          Type of the {@link MultiBinding}
     * @param binding      The multi binding configuration object
     * @param configurator The consumer that should be used to configure the given {@link MultiBinding}
     */
    configureMultiBinding(binding, configurator) {
        configurator(binding);
        binding.applyBindings(this.context);
    }
};
exports.GLSPModule = GLSPModule;
GLSPModule.CLIENT_ACTIONS = 'ClientActions';
exports.GLSPModule = GLSPModule = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], GLSPModule);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/multi-binding.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/multi-binding.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceMultiBinding = exports.MultiBinding = exports.AbstractMultiBinding = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const binding_target_1 = __webpack_require__(/*! ./binding-target */ "../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js");
/**
 * A helper class used in `GLSPModules` to ease the configuration of multi-injected service identifiers.
 * Instead of directly binding to the service identifier a new multi binding object can be created. This object
 * should then be passed to a overridable configuration-function (i.e. configure(binding:V)=>void). This gives subclasses of the
 * `GLSPModule` the chance to manipulate the binding configuration using the provided manipulation methods (e.g. add,remove, rebind).
 * Once the configuration is finished the binding can be finalized using the {@link AbstractMultiBinding.applyBindings} method.
 */
class AbstractMultiBinding {
    constructor(identifier) {
        this.identifier = identifier;
        this.bindings = [];
    }
    add(newBinding) {
        (0, protocol_1.distinctAdd)(this.bindings, newBinding);
    }
    addAll(...newBindings) {
        const result = [];
        (0, protocol_1.flatPush)(result, newBindings);
        result.forEach(newBinding => this.add(newBinding));
    }
    remove(toRemove) {
        (0, protocol_1.remove)(this.bindings, toRemove);
    }
    removeAll(toRemove) {
        return toRemove.forEach(binding => this.remove(binding));
    }
    rebind(oldBinding, newBinding) {
        this.remove(oldBinding);
        this.add(newBinding);
    }
    contains(binding) {
        return this.bindings.includes(binding);
    }
    getAll() {
        return this.bindings;
    }
}
exports.AbstractMultiBinding = AbstractMultiBinding;
/**
 * Implementation of {@link AbstractMultiBinding} for multi-injected values that using an arbitrary {@link BindingTarget}.
 *
 * @typeparam T the base type of {@link BindingTarget}.
 */
class MultiBinding extends AbstractMultiBinding {
    applyBindings(context) {
        this.bindings.forEach(binding => (0, binding_target_1.applyBindingTarget)(context, this.identifier, binding));
    }
}
exports.MultiBinding = MultiBinding;
/**
 * Implementation of {@link AbstractMultiBinding} for multi-injected values that should be bound to concrete instance using the
 * `bind(serviceIdentifier).toConstantValue(MyCustomBinding) syntax.
 *
 * * @typeparam T the type of the instances
 */
class InstanceMultiBinding extends AbstractMultiBinding {
    applyBindings(context) {
        context.bind(this.identifier).toConstantValue(this.bindings);
    }
}
exports.InstanceMultiBinding = InstanceMultiBinding;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/server-module.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/server-module.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerModule = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const global_action_provider_1 = __webpack_require__(/*! ../actions/global-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/global-action-provider.js");
const glsp_server_1 = __webpack_require__(/*! ../protocol/glsp-server */ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/glsp-server.js");
const client_session_factory_1 = __webpack_require__(/*! ../session/client-session-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-factory.js");
const client_session_manager_1 = __webpack_require__(/*! ../session/client-session-manager */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-manager.js");
const binding_target_1 = __webpack_require__(/*! ./binding-target */ "../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js");
const glsp_module_1 = __webpack_require__(/*! ./glsp-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/glsp-module.js");
const multi_binding_1 = __webpack_require__(/*! ./multi-binding */ "../../node_modules/@eclipse-glsp/server/lib/common/di/multi-binding.js");
const service_identifiers_1 = __webpack_require__(/*! ./service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
/**
 * The server module is the central configuration artifact for configuring the server container (i.e. main container). For
 * each application connecting to the server process a new server container is created. The server module provides the
 * base bindings necessary for setting up the base {@link GLSPServer} infrastructure. In addition, it is used to
 * configure the set of {@link DiagramModule}s. Diagram modules are used to create the diagram-session-specific child
 * container when the
 * {@link GLSPServer.initializeClientSession()}
 * method is called.
 *
 * The following bindings are provided:
 *
 * * {@link Map<String, Module>} annotated with `@named("Diagram_Modules")`
 * * {@link GLSPServer}
 * * {@link ClientSessionFactory}
 * * {@link ClientSessionManager}
 * * {@link GlobalActionProvider}
 *
 */
class ServerModule extends glsp_module_1.GLSPModule {
    constructor() {
        super(...arguments);
        this.diagramModules = new Map();
    }
    /**
     * Configure a new {@link DiagramModule} for this server. A diagram module represents the base configuration artifact
     * for configuring a diagram-language-specific client session container. The diagram type provided
     * {@link DiagramModule.diagramType} is used to retrieve the correct diagram module when the {@link GLSPServer}
     * initializes a new client session.
     *
     * @param diagramModule The base diagram module
     * @param additionalModules Additional modules
     * @returns The server module itself. This enables a builder-pattern like chaining of multiple diagram configuration
     *         calls.
     */
    configureDiagramModule(diagramModule, ...additionalModules) {
        const diagramType = diagramModule.diagramType;
        if (this.diagramModules.has(diagramType)) {
            throw new Error(`A module configuration is already present for diagram type: '${diagramType}'`);
        }
        this.diagramModules.set(diagramType, [diagramModule, ...additionalModules]);
        return this;
    }
    configure(bind, unbind, isBound, rebind) {
        const context = this.context;
        (0, binding_target_1.applyBindingTarget)(context, service_identifiers_1.DiagramModules, this.bindDiagramModules());
        (0, binding_target_1.applyBindingTarget)(context, protocol_1.GLSPServer, this.bindGLSPServer()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, client_session_factory_1.ClientSessionFactory, this.bindClientSessionFactory()).inSingletonScope();
        (0, binding_target_1.applyBindingTarget)(context, client_session_manager_1.ClientSessionManager, this.bindClientSessionManager()).inSingletonScope();
        this.configureMultiBinding(new multi_binding_1.MultiBinding(protocol_1.GLSPServerListener), binding => this.configureGLSPServerListeners(binding));
        (0, binding_target_1.applyBindingTarget)(context, global_action_provider_1.GlobalActionProvider, this.bindGlobalActionProvider()).inSingletonScope();
        if (!isBound(service_identifiers_1.InjectionContainer)) {
            (0, binding_target_1.applyBindingTarget)(context, service_identifiers_1.InjectionContainer, this.bindInjectionContainer());
        }
    }
    bindDiagramModules() {
        return { constantValue: this.diagramModules };
    }
    bindGLSPServer() {
        return glsp_server_1.DefaultGLSPServer;
    }
    bindClientSessionFactory() {
        return client_session_factory_1.DefaultClientSessionFactory;
    }
    bindClientSessionManager() {
        return client_session_manager_1.DefaultClientSessionManager;
    }
    bindGlobalActionProvider() {
        return global_action_provider_1.DefaultGlobalActionProvider;
    }
    bindInjectionContainer() {
        return { dynamicValue: context => context.container };
    }
    configureGLSPServerListeners(binding) {
        binding.add({ service: client_session_manager_1.ClientSessionManager });
    }
}
exports.ServerModule = ServerModule;
ServerModule.DIAGRAM_MODULES = 'Diagram_Modules';


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Operations = exports.NavigationTargetProviders = exports.ValidateLabelEditAdapterFactory = exports.ContextEditValidators = exports.ContextActionsProviders = exports.ClientActionKinds = exports.InjectionContainer = exports.DiagramModules = exports.ClientId = exports.DiagramType = void 0;
exports.DiagramType = Symbol('DiagramType');
exports.ClientId = Symbol('ClientId');
exports.DiagramModules = Symbol('DiagramModules');
exports.InjectionContainer = Symbol('InjectionContainer');
exports.ClientActionKinds = Symbol('ClientActionKinds');
exports.ContextActionsProviders = Symbol('ContextActionsProviders');
exports.ContextEditValidators = Symbol('ContextEditValidators');
exports.ValidateLabelEditAdapterFactory = Symbol('ValidateLabelEditAdapterFactory');
exports.NavigationTargetProviders = Symbol('NavigationTargetProviders');
exports.Operations = Symbol('Operations');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagramConfiguration = exports.ServerLayoutKind = void 0;
/**
 * Used to configure whether and when a diagram server should auto-layout the graphical model.
 *
 * The layout is computed with the layout engine configured, so a value other
 * than <code>NONE</code> here makes sense only if such an engine is available.
 */
var ServerLayoutKind;
(function (ServerLayoutKind) {
    /**
     * The server re-layouts the diagram on all changes automatically. Layout
     * information stored in the model will be overwritten.
     */
    ServerLayoutKind[ServerLayoutKind["AUTOMATIC"] = 0] = "AUTOMATIC";
    /**
     * The server re-layouts the diagram only if manually triggered by a
     * <code>LayoutAction</code>. The layout information must be stored in the model
     * and will be overwritten on layout.
     */
    ServerLayoutKind[ServerLayoutKind["MANUAL"] = 1] = "MANUAL";
    /**
     * The server never layouts the diagram. This requires that the layout
     * information is stored in the model.
     */
    ServerLayoutKind[ServerLayoutKind["NONE"] = 2] = "NONE";
})(ServerLayoutKind || (exports.ServerLayoutKind = ServerLayoutKind = {}));
exports.DiagramConfiguration = Symbol('DiagramConfiguration');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/clipboard/request-clipboard-data-action-handler.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/clipboard/request-clipboard-data-action-handler.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestClipboardDataActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
let RequestClipboardDataActionHandler = class RequestClipboardDataActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestClipboardDataAction.KIND];
    }
    execute(action) {
        const schemas = [];
        const index = this.modelState.index;
        const selectedElements = index.getAll(action.editorContext.selectedElementIds);
        const clipboardData = { format: 'application/json' };
        selectedElements.forEach(element => {
            schemas.push(this.modelSerializer.createSchema(element));
        });
        // eslint-disable-next-line no-null/no-null
        clipboardData['application/json'] = JSON.stringify(schemas, undefined, 2);
        return [protocol_1.SetClipboardDataAction.create(clipboardData)];
    }
};
exports.RequestClipboardDataActionHandler = RequestClipboardDataActionHandler;
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], RequestClipboardDataActionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], RequestClipboardDataActionHandler.prototype, "modelSerializer", void 0);
exports.RequestClipboardDataActionHandler = RequestClipboardDataActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestClipboardDataActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/command-palette-action-provider.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/command-palette-action-provider.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandPaletteActionProvider = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
/**
 * A {@link ContextActionsProvider} for CommandPaletteActions.
 */
let CommandPaletteActionProvider = class CommandPaletteActionProvider {
    constructor() {
        this.TEXT = 'text';
        this.INDEX = 'index';
    }
    /**
     * Returns the context id of the provider.
     */
    get contextId() {
        return 'command-palette';
    }
    /**
     * Retrieves the value for the "text" key from the given arguments {@link Args}.
     *
     * @param args The given arguments.
     * @returns The value associated with the "text" key.
     */
    getText(args) {
        return args[this.TEXT] ? args[this.TEXT].toString() : '';
    }
    /**
     * Returns the value of the "index" key from a given {@link Args}.
     *
     * @param args The given arguments.
     * @returns The value associated with the "index" key.
     */
    getIndex(args) {
        return args[this.INDEX] ? args[this.INDEX] : 0.0;
    }
    /**
     * Returns a list of {@link LabeledAction}s for a given {@link EditorContext}.
     *
     * @param editorContext The editorContext for which the actions are returned.
     * @returns A list of {@link LabeledAction}s for a given {@link EditorContext}.
     */
    getActions(editorContext) {
        const actions = [];
        if (this.modelState.isReadonly) {
            return actions;
        }
        const selectedIds = editorContext.selectedElementIds;
        const position = editorContext.lastMousePosition ? editorContext.lastMousePosition : { x: 0, y: 0 };
        const selectedElements = this.modelState.index.getAll(selectedIds);
        return this.getPaletteActions(selectedIds, selectedElements, position, editorContext.args);
    }
};
exports.CommandPaletteActionProvider = CommandPaletteActionProvider;
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], CommandPaletteActionProvider.prototype, "modelState", void 0);
exports.CommandPaletteActionProvider = CommandPaletteActionProvider = __decorate([
    (0, inversify_1.injectable)()
], CommandPaletteActionProvider);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider-registry.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider-registry.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextActionsProviderRegistry = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const registry_1 = __webpack_require__(/*! ../../utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js");
const command_palette_action_provider_1 = __webpack_require__(/*! ./command-palette-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/command-palette-action-provider.js");
const context_menu_item_provider_1 = __webpack_require__(/*! ./context-menu-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-menu-item-provider.js");
const tool_palette_item_provider_1 = __webpack_require__(/*! ./tool-palette-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/tool-palette-item-provider.js");
/**
 * A registry that keeps track of all registered {@link ContextActionsProvider}s.
 */
let ContextActionsProviderRegistry = class ContextActionsProviderRegistry extends registry_1.Registry {
    constructor(contextActionsProvider = [], contextMenuItemProvider, commandPaletteActionProvider, toolPaletteItemProvider) {
        super();
        contextActionsProvider.forEach(provider => this.register(provider.contextId, provider));
        if (contextMenuItemProvider) {
            this.register(contextMenuItemProvider.contextId, contextMenuItemProvider);
        }
        if (commandPaletteActionProvider) {
            this.register(commandPaletteActionProvider.contextId, commandPaletteActionProvider);
        }
        if (toolPaletteItemProvider) {
            this.register(toolPaletteItemProvider.contextId, toolPaletteItemProvider);
        }
    }
};
exports.ContextActionsProviderRegistry = ContextActionsProviderRegistry;
exports.ContextActionsProviderRegistry = ContextActionsProviderRegistry = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(service_identifiers_1.ContextActionsProviders)),
    __param(0, (0, inversify_1.optional)()),
    __param(1, (0, inversify_1.inject)(context_menu_item_provider_1.ContextMenuItemProvider)),
    __param(1, (0, inversify_1.optional)()),
    __param(2, (0, inversify_1.inject)(command_palette_action_provider_1.CommandPaletteActionProvider)),
    __param(2, (0, inversify_1.optional)()),
    __param(3, (0, inversify_1.inject)(tool_palette_item_provider_1.ToolPaletteItemProvider)),
    __param(3, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array, context_menu_item_provider_1.ContextMenuItemProvider,
        command_palette_action_provider_1.CommandPaletteActionProvider,
        tool_palette_item_provider_1.ToolPaletteItemProvider])
], ContextActionsProviderRegistry);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextActionsProvider = void 0;
exports.ContextActionsProvider = Symbol('ContextActionsProvider');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-menu-item-provider.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-menu-item-provider.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextMenuItemProvider = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
/**
 * A {@link ContextActionsProvider} for {@link MenuItem}s.
 */
let ContextMenuItemProvider = class ContextMenuItemProvider {
    /**
     * Returns the context id of the {@link ContextMenuItemProvider}.
     */
    get contextId() {
        return 'context-menu';
    }
    /**
     * Returns a list of {@link LabeledAction}s for a given {@link EditorContext}.
     *
     * @param editorContext The editorContext for which the actions are returned.
     * @returns A list of {@link LabeledAction}s for a given {@link EditorContext}.
     */
    getActions(editorContext) {
        const position = editorContext.lastMousePosition ? editorContext.lastMousePosition : { x: 0, y: 0 };
        return this.getItems(editorContext.selectedElementIds, position, editorContext.args);
    }
};
exports.ContextMenuItemProvider = ContextMenuItemProvider;
exports.ContextMenuItemProvider = ContextMenuItemProvider = __decorate([
    (0, inversify_1.injectable)()
], ContextMenuItemProvider);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/request-context-actions-handler.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/request-context-actions-handler.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestContextActionsHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const context_actions_provider_registry_1 = __webpack_require__(/*! ./context-actions-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider-registry.js");
let RequestContextActionsHandler = class RequestContextActionsHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestContextActions.KIND];
    }
    async execute(action) {
        const editorContext = action.editorContext;
        const actions = [];
        if (this.contextActionsProviderRegistry.get(action.contextId)) {
            const provider = this.contextActionsProviderRegistry.get(action.contextId);
            (await provider.getActions(editorContext)).forEach(returnAction => actions.push(returnAction));
        }
        return [protocol_1.SetContextActions.create(actions, { args: action.editorContext.args })];
    }
};
exports.RequestContextActionsHandler = RequestContextActionsHandler;
__decorate([
    (0, inversify_1.inject)(context_actions_provider_registry_1.ContextActionsProviderRegistry),
    __metadata("design:type", context_actions_provider_registry_1.ContextActionsProviderRegistry)
], RequestContextActionsHandler.prototype, "contextActionsProviderRegistry", void 0);
exports.RequestContextActionsHandler = RequestContextActionsHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestContextActionsHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/tool-palette-item-provider.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/tool-palette-item-provider.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultToolPaletteItemProvider = exports.ToolPaletteItemProvider = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const create_operation_handler_1 = __webpack_require__(/*! ../../operations/create-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/create-operation-handler.js");
const operation_handler_registry_1 = __webpack_require__(/*! ../../operations/operation-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js");
/**
 * A {@link ContextActionsProvider} for {@link PaletteItem}s.
 */
let ToolPaletteItemProvider = class ToolPaletteItemProvider {
    /**
     * Returns the context id of the provider.
     */
    get contextId() {
        return 'tool-palette';
    }
    /**
     * Returns a list of {@link LabeledAction}s for a given {@link EditorContext}.
     *
     * @param editorContext The editorContext for which the actions are returned.
     * @returns A list of {@link LabeledAction}s for a given {@link EditorContext}.
     */
    async getActions(editorContext) {
        return this.getItems(editorContext.args);
    }
};
exports.ToolPaletteItemProvider = ToolPaletteItemProvider;
exports.ToolPaletteItemProvider = ToolPaletteItemProvider = __decorate([
    (0, inversify_1.injectable)()
], ToolPaletteItemProvider);
let DefaultToolPaletteItemProvider = class DefaultToolPaletteItemProvider extends ToolPaletteItemProvider {
    getItems(_args) {
        const handlers = this.operationHandlerRegistry.getAll().filter(create_operation_handler_1.CreateOperationHandler.is);
        this.counter = 0;
        const nodes = this.createPaletteItem(handlers, protocol_1.CreateNodeOperation.KIND);
        const edges = this.createPaletteItem(handlers, protocol_1.CreateEdgeOperation.KIND);
        return [
            { id: 'node-group', label: 'Nodes', actions: [], children: nodes, icon: 'symbol-property', sortString: 'A' },
            { id: 'edge-group', label: 'Edges', actions: [], children: edges, icon: 'symbol-property', sortString: 'B' }
        ];
    }
    createPaletteItem(handlers, kind) {
        return handlers
            .filter(handler => handler.operationType === kind)
            .map(handler => handler.getTriggerActions().map(action => this.create(action, handler.label)))
            .reduce((accumulator, value) => accumulator.concat(value), [])
            .sort((a, b) => a.sortString.localeCompare(b.sortString));
    }
    create(action, label) {
        return { id: `palette-item${this.counter}`, sortString: label.charAt(0), label, actions: [action] };
    }
};
exports.DefaultToolPaletteItemProvider = DefaultToolPaletteItemProvider;
__decorate([
    (0, inversify_1.inject)(operation_handler_registry_1.OperationHandlerRegistry),
    __metadata("design:type", operation_handler_registry_1.OperationHandlerRegistry)
], DefaultToolPaletteItemProvider.prototype, "operationHandlerRegistry", void 0);
exports.DefaultToolPaletteItemProvider = DefaultToolPaletteItemProvider = __decorate([
    (0, inversify_1.injectable)()
], DefaultToolPaletteItemProvider);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator-registry.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator-registry.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultContextEditValidatorRegistry = exports.ContextEditValidatorRegistry = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const registry_1 = __webpack_require__(/*! ../../utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const context_edit_validator_1 = __webpack_require__(/*! ./context-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator.js");
const label_edit_validator_1 = __webpack_require__(/*! ./label-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js");
exports.ContextEditValidatorRegistry = Symbol.for('ContextEditValidatorRegistry');
let DefaultContextEditValidatorRegistry = class DefaultContextEditValidatorRegistry extends registry_1.Registry {
    constructor(modelState, contextEditValidators = [], labelEditValidator) {
        super();
        contextEditValidators.forEach(provider => this.register(provider.contextId, provider));
        if (labelEditValidator) {
            this.register(label_edit_validator_1.LabelEditValidator.CONTEXT_ID, new context_edit_validator_1.ValidateLabelEditAdapter(modelState, labelEditValidator));
        }
    }
};
exports.DefaultContextEditValidatorRegistry = DefaultContextEditValidatorRegistry;
exports.DefaultContextEditValidatorRegistry = DefaultContextEditValidatorRegistry = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(model_state_1.ModelState)),
    __param(1, (0, inversify_1.multiInject)(service_identifiers_1.ContextEditValidators)),
    __param(1, (0, inversify_1.optional)()),
    __param(2, (0, inversify_1.inject)(label_edit_validator_1.LabelEditValidator)),
    __param(2, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Object, Array, label_edit_validator_1.LabelEditValidator])
], DefaultContextEditValidatorRegistry);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidateLabelEditAdapter = exports.ContextEditValidator = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const gmodel_element_1 = __webpack_require__(/*! @eclipse-glsp/graph/lib/gmodel-element */ "../../node_modules/@eclipse-glsp/graph/lib/gmodel-element.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const label_edit_validator_1 = __webpack_require__(/*! ./label-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js");
exports.ContextEditValidator = Symbol('ContextEditValidator');
class ValidateLabelEditAdapter {
    constructor(modelState, labelEditValidator) {
        this.modelState = modelState;
        this.labelEditValidator = labelEditValidator;
    }
    get contextId() {
        return label_edit_validator_1.LabelEditValidator.CONTEXT_ID;
    }
    validate(action) {
        const element = this.modelState.index.get(action.modelElementId);
        if (element instanceof gmodel_element_1.GModelElement) {
            return this.labelEditValidator.validate(action.text, element);
        }
        return { severity: protocol_1.ValidationStatus.Severity.OK };
    }
}
exports.ValidateLabelEditAdapter = ValidateLabelEditAdapter;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LabelEditValidator = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
/**
 * A validator that validates a new label for a given {@link GModelElement}.
 */
let LabelEditValidator = class LabelEditValidator {
};
exports.LabelEditValidator = LabelEditValidator;
LabelEditValidator.CONTEXT_ID = 'label-edit';
exports.LabelEditValidator = LabelEditValidator = __decorate([
    (0, inversify_1.injectable)()
], LabelEditValidator);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/request-edit-validation-handler.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/request-edit-validation-handler.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestEditValidationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ../../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const context_edit_validator_registry_1 = __webpack_require__(/*! ./context-edit-validator-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator-registry.js");
let RequestEditValidationHandler = class RequestEditValidationHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestEditValidationAction.KIND];
    }
    execute(action) {
        const validator = this.contextEditValidatorRegistry.get(action.contextId);
        if (validator) {
            const validationStatus = validator.validate(action);
            return [protocol_1.SetEditValidationResultAction.create(validationStatus)];
        }
        else {
            const message = `No validator registered for the context '${action.contextId}'`;
            this.logger.warn(message);
            return [protocol_1.SetEditValidationResultAction.create({ severity: protocol_1.ValidationStatus.Severity.WARNING, message: message })];
        }
    }
};
exports.RequestEditValidationHandler = RequestEditValidationHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], RequestEditValidationHandler.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(context_edit_validator_registry_1.ContextEditValidatorRegistry),
    __metadata("design:type", Object)
], RequestEditValidationHandler.prototype, "contextEditValidatorRegistry", void 0);
exports.RequestEditValidationHandler = RequestEditValidationHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestEditValidationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/computed-bounds-action-handler.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/layout/computed-bounds-action-handler.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComputedBoundsActionHandler = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const layout_util_1 = __webpack_require__(/*! ../../utils/layout-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const model_submission_handler_1 = __webpack_require__(/*! ../model/model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js");
/**
 * Syncs the bounds computed by the client (i.e. the actual bounds after applying CSS styles) back to the `GModel`.
 * In this default implementation the updated bounds are stored transient. This means they are applied to the graphical model but
 * are not persisted to the source model.
 */
let ComputedBoundsActionHandler = class ComputedBoundsActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.ComputedBoundsAction.KIND];
    }
    execute(action) {
        const model = this.modelState.root;
        if (action.revision === model.revision) {
            this.applyBounds(model, action);
            return this.submissionHandler.submitModelDirectly();
        }
        return [];
    }
    applyBounds(root, action) {
        var _a, _b;
        const index = this.modelState.index;
        action.bounds.forEach(bounds => (0, layout_util_1.applyElementAndBounds)(bounds, index));
        ((_a = action.alignments) !== null && _a !== void 0 ? _a : []).forEach(alignment => (0, layout_util_1.applyAlignment)(alignment, index));
        ((_b = action.routes) !== null && _b !== void 0 ? _b : []).forEach(route => (0, layout_util_1.applyRoute)(route, index));
    }
};
exports.ComputedBoundsActionHandler = ComputedBoundsActionHandler;
__decorate([
    (0, inversify_1.inject)(model_submission_handler_1.ModelSubmissionHandler),
    __metadata("design:type", model_submission_handler_1.ModelSubmissionHandler)
], ComputedBoundsActionHandler.prototype, "submissionHandler", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], ComputedBoundsActionHandler.prototype, "modelState", void 0);
exports.ComputedBoundsActionHandler = ComputedBoundsActionHandler = __decorate([
    (0, inversify_1.injectable)()
], ComputedBoundsActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutEngine = void 0;
exports.LayoutEngine = Symbol('LayoutEngine');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-operation-handler.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-operation-handler.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const recording_command_1 = __webpack_require__(/*! ../../command/recording-command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js");
const diagram_configuration_1 = __webpack_require__(/*! ../../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
const operation_handler_1 = __webpack_require__(/*! ../../operations/operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
const logger_1 = __webpack_require__(/*! ../../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const layout_engine_1 = __webpack_require__(/*! ./layout-engine */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js");
/**
 * The default handler for `{@link LayoutOperation}s. Does invoke the (optional) layout engine
 * if the server is configured for manual layouting. Changes are stored transient in the graphical model and are not
 * persisted in the source model.
 */
let LayoutOperationHandler = class LayoutOperationHandler extends operation_handler_1.OperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.LayoutOperation.KIND;
    }
    createCommand(operation) {
        if (this.diagramConfiguration.layoutKind !== diagram_configuration_1.ServerLayoutKind.MANUAL) {
            return undefined;
        }
        if (!this.layoutEngine) {
            this.logger.warn('Could not execute layout operation. No `LayoutEngine` is bound!');
            return undefined;
        }
        return new recording_command_1.GModelRecordingCommand(this.modelState, this.serializer, () => this.executeOperation(operation));
    }
    async executeOperation(_operation) {
        var _a;
        await ((_a = this.layoutEngine) === null || _a === void 0 ? void 0 : _a.layout());
    }
};
exports.LayoutOperationHandler = LayoutOperationHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], LayoutOperationHandler.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(layout_engine_1.LayoutEngine),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], LayoutOperationHandler.prototype, "layoutEngine", void 0);
__decorate([
    (0, inversify_1.inject)(diagram_configuration_1.DiagramConfiguration),
    __metadata("design:type", Object)
], LayoutOperationHandler.prototype, "diagramConfiguration", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], LayoutOperationHandler.prototype, "serializer", void 0);
exports.LayoutOperationHandler = LayoutOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], LayoutOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelFactoryNullImpl = exports.GModelFactory = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
exports.GModelFactory = Symbol('GModelFactory');
/**
 * GModelFactory to be used if the graph model is already available from the model source.
 */
let GModelFactoryNullImpl = class GModelFactoryNullImpl {
    createModel() {
        // no-op
    }
};
exports.GModelFactoryNullImpl = GModelFactoryNullImpl;
exports.GModelFactoryNullImpl = GModelFactoryNullImpl = __decorate([
    (0, inversify_1.injectable)()
], GModelFactoryNullImpl);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-index.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelIndex = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
/**
 * Is used to index all child elements of a {@link GModelRoot} by their id. Offers a set
 * of query methods to retrieve indexed elements.
 */
let GModelIndex = class GModelIndex {
    constructor() {
        this.idToElement = new Map();
        this.typeToElements = new Map();
    }
    clear() {
        this.idToElement.clear();
        this.typeToElements.clear();
    }
    indexRoot(root) {
        this.clear();
        this.doIndex(root);
    }
    doIndex(element) {
        var _a, _b;
        if (this.idToElement.has(element.id)) {
            throw new glsp_server_error_1.GLSPServerError('Duplicate ID in model: ' + element.id);
        }
        this.idToElement.set(element.id, element);
        const typeSet = (_a = this.typeToElements.get(element.type)) !== null && _a !== void 0 ? _a : [];
        typeSet.push(element);
        this.typeToElements.set(element.type, typeSet);
        ((_b = element.children) !== null && _b !== void 0 ? _b : []).forEach(child => {
            this.doIndex(child);
            // Double check wether the parent reference of the child is set correctly
            if (!child.parent) {
                child.parent = element;
            }
        });
    }
    find(elementId, predicate) {
        const element = this.idToElement.get(elementId);
        if (element && predicate ? predicate(element) : true) {
            return element;
        }
        return undefined;
    }
    findByClass(elementTypeId, constructor) {
        const element = this.find(elementTypeId);
        if (element && element instanceof constructor) {
            return element;
        }
        return undefined;
    }
    /**
     * Returns an optional {@link GModelElement} by its elementId.
     *
     * @param elementId The id of the requested {@link GModelElement}.
     * @returns An optional instance of the {@link GModelElement}.
     */
    get(elementId) {
        return (0, glsp_server_error_1.getOrThrow)(this.find(elementId), `Could not retrieve element with id: '${elementId}'`);
    }
    /**
     * Returns a set of {@link GModelElement} instances by a Collection of elementIds.
     *
     * @param elementIds The ids to request the {@link GModelElement} from an array of elementIds.
     * @returns A set of {@link GModelElement}s.
     */
    getAll(elementIds) {
        return elementIds.map(id => this.idToElement.get(id)).filter(element => element);
    }
    /**
     * Returns all elements of the type constructor contained in the {@link GModelRoot}.
     *
     * @type Type of the elements to be returned.
     * @param constructor The class of which the returned elements should be instances.
     * @returns A set containing the elements of type constructor.
     */
    getAllByClass(constructor) {
        return Array.from(this.idToElement.values()).filter(element => element instanceof constructor);
    }
    /**
     * Returns a list of all {@link GModelElement} ids contained in this instance of the GModelIndex.
     *
     * @returns A list of elementIds.
     */
    allIds() {
        return Array.from(this.idToElement.keys());
    }
    /**
     * Returns all elements of a type {@link GModelRoot}.
     *
     * @param type   Type of the elements to be returned.
     * @returns A set containing the elements of the given type.
     */
    getElements(type) {
        var _a;
        return (_a = this.typeToElements.get(type)) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Returns the current amount of type occurrences in this instance of the GModelIndex.
     *
     * @param eClass The EClass to be counted in this instance of the GModelIndex.
     *
     * @returns The amount of type occurrences.
     */
    typeCount(type) {
        return this.getElements(type).length;
    }
    /**
     * Returns all incoming edges for a node (or port).
     *
     * @param node The node (or port) where the edges are connected.
     *
     * @returns All incoming edges.
     */
    getIncomingEdges(node) {
        return this.getAllEdges().filter(edge => edge.targetId === node.id);
    }
    /**
     * Returns all outgoing edges for a node (or port).
     *
     * @param node The node (or port) where the edges are connected.
     *
     * @returns All outgoing edges.
     */
    getOutgoingEdges(node) {
        return this.getAllEdges().filter(edge => edge.sourceId === node.id);
    }
    /**
     * Returns all edges in the index.
     *
     * @returns All edges in the index.
     */
    getAllEdges() {
        return this.getAllByClass(graph_1.GEdge);
    }
    /**
     * Returns the first element matching the given {@link TypeGuard} starting element with the
     * given id and walking up the parent hierarchy.
     *
     * @param elementId The element to start the search from
     * @param guard The typeguard which the element should match
     * @return The first matching element or `undefined`.
     */
    findParentElement(elementId, guard) {
        const element = this.get(elementId);
        return element ? this._findElement(element, guard) : undefined;
    }
    _findElement(element, guard) {
        if (!element) {
            return undefined;
        }
        if (guard(element)) {
            return element;
        }
        if (element instanceof graph_1.GModelRoot) {
            return undefined;
        }
        return this._findElement(element.parent, guard);
    }
};
exports.GModelIndex = GModelIndex;
exports.GModelIndex = GModelIndex = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], GModelIndex);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGModelSerializer = exports.GModelSerializer = void 0;
/********************************************************************************
 * Copyright (c) 2017-2023 TypeFox and other
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* Derived from sprotty (https://github.com/eclipse/sprotty/blob/master/packages/sprotty/src/base/model/smodel-factory.ts) */
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const diagram_configuration_1 = __webpack_require__(/*! ../../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
const glsp_server_error_1 = __webpack_require__(/*! ../../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
exports.GModelSerializer = Symbol('GModelSerializer');
let DefaultGModelSerializer = class DefaultGModelSerializer {
    constructor() {
        this.reservedKeys = ['children', 'parent', 'index', 'source', 'target'];
    }
    createRoot(schema) {
        const constructor = this.getConfiguredConstructor(schema);
        if (constructor) {
            const element = new constructor();
            if (!(element instanceof graph_1.GModelRoot)) {
                throw new glsp_server_error_1.GLSPServerError(`Element with type '${schema.type}' is expected to be a GModelRoot!`);
            }
            return this.initializeRoot(element, schema);
        }
        throw new glsp_server_error_1.GLSPServerError(`No constructor is configured in DiagramConfiguration for type ${schema.type}`);
    }
    getConfiguredConstructor(schema) {
        let key = schema.type;
        while (!this.diagramConfiguration.typeMapping.has(key)) {
            const i = key.lastIndexOf(':');
            if (i > 0) {
                key = key.substring(0, i);
            }
            else {
                return undefined;
            }
        }
        const constructor = this.diagramConfiguration.typeMapping.get(key);
        if (key !== schema.type) {
            this.diagramConfiguration.typeMapping.set(key, constructor);
        }
        return constructor;
    }
    createElement(schema, parent) {
        const constructor = this.getConfiguredConstructor(schema);
        if (constructor) {
            const element = new constructor();
            if (element instanceof graph_1.GModelRoot) {
                throw new glsp_server_error_1.GLSPServerError(`Element with type '${schema.type}' is a GModelRoot! 'createElement()' is expected to only create child elements!`);
            }
            return this.initializeChild(element, schema, parent);
        }
        throw new glsp_server_error_1.GLSPServerError(`No constructor is configured in DiagramConfiguration for type ${schema.type}`);
    }
    createSchema(element) {
        var _a;
        const schema = {};
        for (const key in element) {
            if (!this.isReserved(element, key)) {
                const value = element[key];
                if (typeof value !== 'function') {
                    schema[key] = value;
                }
            }
        }
        schema['children'] = ((_a = element.children) !== null && _a !== void 0 ? _a : []).map(child => this.createSchema(child));
        return schema;
    }
    initializeRoot(root, schema) {
        this.initializeParent(root, schema);
        return root;
    }
    initializeElement(element, schema) {
        for (const key in schema) {
            if (!this.isReserved(element, key)) {
                const value = schema[key];
                if (typeof value !== 'function') {
                    element[key] = value;
                }
            }
        }
        return element;
    }
    initializeChild(child, schema, parent) {
        this.initializeParent(child, schema);
        if (parent) {
            child.parent = parent;
        }
        return child;
    }
    initializeParent(parent, schema) {
        this.initializeElement(parent, schema);
        if (schema.children) {
            parent.children = schema.children.map(childSchema => this.createElement(childSchema, parent));
        }
        return parent;
    }
    isReserved(element, propertyName) {
        if (this.reservedKeys.indexOf(propertyName) >= 0) {
            return true;
        }
        let obj = element;
        do {
            const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
            if (descriptor !== undefined) {
                return descriptor.get !== undefined;
            }
            obj = Object.getPrototypeOf(obj);
        } while (obj);
        return false;
    }
};
exports.DefaultGModelSerializer = DefaultGModelSerializer;
__decorate([
    (0, inversify_1.inject)(diagram_configuration_1.DiagramConfiguration),
    __metadata("design:type", Object)
], DefaultGModelSerializer.prototype, "diagramConfiguration", void 0);
exports.DefaultGModelSerializer = DefaultGModelSerializer = __decorate([
    (0, inversify_1.injectable)()
], DefaultGModelSerializer);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultModelState = exports.SOURCE_URI_ARG = exports.ModelState = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const gmodel_index_1 = __webpack_require__(/*! ./gmodel-index */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-index.js");
const gmodel_serializer_1 = __webpack_require__(/*! ./gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
exports.ModelState = Symbol('ModelState');
exports.SOURCE_URI_ARG = 'sourceUri';
let DefaultModelState = class DefaultModelState {
    constructor() {
        this.properties = new Map();
        this.editMode = protocol_1.EditMode.EDITABLE;
    }
    set(key, property) {
        this.properties.set(key, property);
    }
    setAll(properties) {
        Object.keys(properties).forEach(key => this.properties.set(key, properties[key]));
    }
    get(key, guard) {
        const result = this.properties.get(key);
        if (!guard) {
            return result;
        }
        return guard(result) ? result : undefined;
    }
    get sourceUri() {
        return this.get(exports.SOURCE_URI_ARG);
    }
    clear(key) {
        this.properties.delete(key);
    }
    get isReadonly() {
        return this.editMode === protocol_1.EditMode.READONLY;
    }
    get root() {
        return this._root;
    }
    set root(root) {
        this._root = root;
    }
    updateRoot(newRoot) {
        if (!newRoot.revision && this.root) {
            newRoot.revision = this.root.revision;
        }
        this.root = newRoot;
        this.index.indexRoot(newRoot);
    }
};
exports.DefaultModelState = DefaultModelState;
__decorate([
    (0, inversify_1.inject)(gmodel_index_1.GModelIndex),
    __metadata("design:type", gmodel_index_1.GModelIndex)
], DefaultModelState.prototype, "index", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], DefaultModelState.prototype, "serializer", void 0);
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.ClientId),
    __metadata("design:type", String)
], DefaultModelState.prototype, "clientId", void 0);
exports.DefaultModelState = DefaultModelState = __decorate([
    (0, inversify_1.injectable)()
], DefaultModelState);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelSubmissionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const command_stack_1 = __webpack_require__(/*! ../../command/command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js");
const diagram_configuration_1 = __webpack_require__(/*! ../../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
const layout_engine_1 = __webpack_require__(/*! ../layout/layout-engine */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js");
const model_validator_1 = __webpack_require__(/*! ../validation/model-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js");
const gmodel_factory_1 = __webpack_require__(/*! ./gmodel-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js");
const gmodel_serializer_1 = __webpack_require__(/*! ./gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const model_state_1 = __webpack_require__(/*! ./model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
/**
 * Helper class that provides utility methods to handle model updates i.e.
 * submit a new model to the client. In addition, to the core model update action this class
 * also takes care of related behavior like dirty state handling, validation and client/server side layouting.
 * Note that the submissions handler is only responsible for deriving the set of actions that comprise a model update
 * but does not actually dispatch them. The returned actions should be either manually dispatched
 * to the `ActionDispatcher`, or simply returned as the result of an
 * `ActionHandler.execute` method.
 */
let ModelSubmissionHandler = class ModelSubmissionHandler {
    /**
     * Returns a list of actions to submit the initial revision of the client-side model, based on the injected
     * {@link ModelState}. Typically this method is invoked by the {@link RequestModelActionHandler} when the diagram
     * is (re)loaded.
     * <p>
     * These actions are not processed by this {@link ModelSubmissionHandler}, but should be either manually dispatched
     * to the {@link ActionDispatcher}, or simply returned as the result of an
     * {@link ActionHandler#execute(Action)} method.
     * </p>
     *
     * @param requestAction The {@link RequestModelAction} that triggere the initial model update
     * @return A list of actions to be processed in order to submit the intial model.
     *
     */
    submitInitialModel(requestAction) {
        /*
         * In the default update action flow a `RequestModelAction` does not directly trigger a `SetModelAction` response
         * (RequestModelAction (C) -> RequestBoundsAction (S) -> ComputedBoundsAction (C) -> SetModelACtion (S)
         * Therefore we temporarily store the action later retrival
         */
        this.requestModelAction = requestAction;
        return this.submitModel();
    }
    /**
     * Returns a list of actions to update the client-side model, based on the injected {@link ModelState}
     *
     * These actions are not processed by this {@link ModelSubmissionHandler}, but should be either manually dispatched
     * to the `ActionDispatcher`, or simply returned as the result of an `ActionHandler.execute()` method.
     *
     * @param reason The optional reason that caused the model update.
     * @returns A list of actions to be processed in order to submit the model.
     */
    submitModel(reason) {
        this.modelFactory.createModel();
        const revision = this.requestModelAction ? 0 : this.modelState.root.revision + 1;
        this.modelState.root.revision = revision;
        if (this.diagramConfiguration.needsClientLayout) {
            const root = this.serializeGModel();
            return [protocol_1.RequestBoundsAction.create(root), protocol_1.SetDirtyStateAction.create(this.commandStack.isDirty, { reason })];
        }
        return this.submitModelDirectly(reason);
    }
    /**
     * Returns a list of actions to directly update the client-side model without any server- or client-side layouting.
     *
     * Typically `ActionHandler`s don't invoke this method but use {@link submitModel()}
     * instead, as this is only used to eventually submit the model on the client directly after all layouting is already
     * performed before. The only foreseen caller of this method is `ComputedBoundsActionHandler`.
     *
     * These actions are not processed by this {@link ModelSubmissionHandler}, but should be either manually dispatched
     * to the `ActionDispatcher`, or simply returned as the result of an
     * `ActionHandler.execute()` method.
     *
     * @param reason The optional reason that caused the model update.
     * @returns A list of actions to be processed in order to submit the model.
     */
    async submitModelDirectly(reason) {
        if (this.diagramConfiguration.layoutKind === diagram_configuration_1.ServerLayoutKind.AUTOMATIC && this.layoutEngine) {
            await this.layoutEngine.layout();
        }
        const root = this.serializeGModel();
        const result = [];
        result.push(this.requestModelAction
            ? this.createSetModeAction(root)
            : protocol_1.UpdateModelAction.create(root, { animate: this.diagramConfiguration.animatedUpdate }));
        if (!this.diagramConfiguration.needsClientLayout) {
            result.push(protocol_1.SetDirtyStateAction.create(this.commandStack.isDirty, { reason }));
        }
        if (this.validator) {
            const markers = await this.validator.validate([this.modelState.root], protocol_1.MarkersReason.LIVE);
            result.push(protocol_1.SetMarkersAction.create(markers, { reason: protocol_1.MarkersReason.LIVE }));
        }
        return result;
    }
    createSetModeAction(newRoot) {
        var _a, _b;
        const responseId = (_b = (_a = this.requestModelAction) === null || _a === void 0 ? void 0 : _a.requestId) !== null && _b !== void 0 ? _b : '';
        const response = protocol_1.SetModelAction.create(newRoot, { responseId });
        this.requestModelAction = undefined;
        return response;
    }
    serializeGModel() {
        return this.serializer.createSchema(this.modelState.root);
    }
};
exports.ModelSubmissionHandler = ModelSubmissionHandler;
__decorate([
    (0, inversify_1.inject)(diagram_configuration_1.DiagramConfiguration),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "diagramConfiguration", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "serializer", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_factory_1.GModelFactory),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "modelFactory", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(layout_engine_1.LayoutEngine),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "layoutEngine", void 0);
__decorate([
    (0, inversify_1.inject)(command_stack_1.CommandStack),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "commandStack", void 0);
__decorate([
    (0, inversify_1.inject)(model_validator_1.ModelValidator),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], ModelSubmissionHandler.prototype, "validator", void 0);
exports.ModelSubmissionHandler = ModelSubmissionHandler = __decorate([
    (0, inversify_1.injectable)()
], ModelSubmissionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/request-model-action-handler.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/request-model-action-handler.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestModelActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const action_dispatcher_1 = __webpack_require__(/*! ../../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
const client_options_util_1 = __webpack_require__(/*! ../../utils/client-options-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/client-options-util.js");
const logger_1 = __webpack_require__(/*! ../../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const progress_service_1 = __webpack_require__(/*! ../progress/progress-service */ "../../node_modules/@eclipse-glsp/server/lib/common/features/progress/progress-service.js");
const model_state_1 = __webpack_require__(/*! ./model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const model_submission_handler_1 = __webpack_require__(/*! ./model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js");
const source_model_storage_1 = __webpack_require__(/*! ./source-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js");
let RequestModelActionHandler = class RequestModelActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestModelAction.KIND];
    }
    async execute(action) {
        var _a;
        this.logger.debug('Execute RequestModelAction:', action);
        this.modelState.setAll((_a = action.options) !== null && _a !== void 0 ? _a : {});
        const isReconnecting = client_options_util_1.ClientOptionsUtil.isReconnecting(action.options);
        const progress = this.reportModelLoading('Model loading in progress');
        if (isReconnecting) {
            await this.handleReconnect(action);
        }
        else {
            await this.sourceModelStorage.loadSourceModel(action);
        }
        this.reportModelLoadingFinished(progress);
        return this.submissionHandler.submitInitialModel(action);
    }
    async handleReconnect(action) {
        var _a;
        const oldModelRoot = this.modelState.root;
        if (oldModelRoot) {
            // decrease revision by one, as each submit will increase it by one;
            // the next save would produce warning that source model was changed otherwise
            this.modelState.root.revision = ((_a = this.modelState.root.revision) !== null && _a !== void 0 ? _a : 0) - 1;
        }
        else {
            await this.sourceModelStorage.loadSourceModel(action);
        }
    }
    reportModelLoading(message) {
        this.actionDispatcher.dispatch(protocol_1.StatusAction.create(message, { severity: 'INFO' }));
        return this.progressService.start(message);
    }
    reportModelLoadingFinished(monitor) {
        this.actionDispatcher.dispatch(protocol_1.StatusAction.create('', { severity: 'NONE' }));
        monitor.end();
    }
};
exports.RequestModelActionHandler = RequestModelActionHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], RequestModelActionHandler.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(source_model_storage_1.SourceModelStorage),
    __metadata("design:type", Object)
], RequestModelActionHandler.prototype, "sourceModelStorage", void 0);
__decorate([
    (0, inversify_1.inject)(action_dispatcher_1.ActionDispatcher),
    __metadata("design:type", Object)
], RequestModelActionHandler.prototype, "actionDispatcher", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], RequestModelActionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(model_submission_handler_1.ModelSubmissionHandler),
    __metadata("design:type", model_submission_handler_1.ModelSubmissionHandler)
], RequestModelActionHandler.prototype, "submissionHandler", void 0);
__decorate([
    (0, inversify_1.inject)(progress_service_1.ProgressService),
    __metadata("design:type", Object)
], RequestModelActionHandler.prototype, "progressService", void 0);
exports.RequestModelActionHandler = RequestModelActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestModelActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/save-model-action-handler.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/save-model-action-handler.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SaveModelActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const command_stack_1 = __webpack_require__(/*! ../../command/command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js");
const source_model_storage_1 = __webpack_require__(/*! ./source-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js");
let SaveModelActionHandler = class SaveModelActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.SaveModelAction.KIND];
    }
    async execute(action) {
        await this.sourceModelStorage.saveSourceModel(action);
        this.commandStack.saveIsDone();
        return [protocol_1.SetDirtyStateAction.create(this.commandStack.isDirty, { reason: 'save' })];
    }
};
exports.SaveModelActionHandler = SaveModelActionHandler;
__decorate([
    (0, inversify_1.inject)(command_stack_1.CommandStack),
    __metadata("design:type", Object)
], SaveModelActionHandler.prototype, "commandStack", void 0);
__decorate([
    (0, inversify_1.inject)(source_model_storage_1.SourceModelStorage),
    __metadata("design:type", Object)
], SaveModelActionHandler.prototype, "sourceModelStorage", void 0);
exports.SaveModelActionHandler = SaveModelActionHandler = __decorate([
    (0, inversify_1.injectable)()
], SaveModelActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceModelStorage = void 0;
exports.SourceModelStorage = Symbol('SourceModelStorage');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/json-opener-options.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/json-opener-options.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinePosition = exports.TextSelection = exports.JsonOpenerOptions = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
class JsonOpenerOptions {
    constructor(selection) {
        if (selection) {
            this.selection = selection;
        }
    }
    toString() {
        return `JsonOpenerOptions [selection=${this.selection}]`;
    }
    toJson() {
        return JsonOpenerOptions.toJson(this);
    }
    static toJson(options) {
        return JSON.stringify(options);
    }
    static fromJson(options) {
        const parsed = JSON.parse(options);
        return parsed instanceof JsonOpenerOptions ? parsed : undefined;
    }
}
exports.JsonOpenerOptions = JsonOpenerOptions;
class TextSelection {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toString() {
        return `TextSelection [start=${this.start}, end=${this.end}]`;
    }
}
exports.TextSelection = TextSelection;
class LinePosition {
    constructor(line, character) {
        this.line = line;
        this.character = character;
    }
    toString() {
        return `LinePosition [line=${this.line}, character=${this.character}]`;
    }
}
exports.LinePosition = LinePosition;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider-registry.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider-registry.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultNavigationTargetProviderRegistry = exports.NavigationTargetProviderRegistry = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const registry_1 = __webpack_require__(/*! ../../utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js");
exports.NavigationTargetProviderRegistry = Symbol('NavigationTargetProviderRegistry');
let DefaultNavigationTargetProviderRegistry = class DefaultNavigationTargetProviderRegistry extends registry_1.Registry {
    constructor(navigationTargetProviders = []) {
        super();
        navigationTargetProviders.forEach(provider => this.register(provider.targetTypeId, provider));
    }
};
exports.DefaultNavigationTargetProviderRegistry = DefaultNavigationTargetProviderRegistry;
exports.DefaultNavigationTargetProviderRegistry = DefaultNavigationTargetProviderRegistry = __decorate([
    __param(0, (0, inversify_1.multiInject)(service_identifiers_1.NavigationTargetProviders)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], DefaultNavigationTargetProviderRegistry);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationTargetProvider = void 0;
exports.NavigationTargetProvider = Symbol('NavigationTargetProviders');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolution.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolution.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationTargetResolution = void 0;
class NavigationTargetResolution {
    constructor(elementIds, args) {
        this.elementIds = elementIds;
        this.args = args;
    }
}
exports.NavigationTargetResolution = NavigationTargetResolution;
NavigationTargetResolution.EMPTY = new NavigationTargetResolution([]);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolver.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolver.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationTargetResolver = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
let NavigationTargetResolver = class NavigationTargetResolver {
    constructor() {
        this.INFO = 'info';
        this.WARNING = 'warning';
        this.ERROR = 'error';
    }
    createArgs() {
        return {};
    }
    createArgsWithInfo(message) {
        const args = this.createArgs();
        this.addInfo(message, args);
        return args;
    }
    createArgsWithWarning(message) {
        const args = this.createArgs();
        this.addWarning(message, args);
        return args;
    }
    createArgsWithError(message) {
        const args = this.createArgs();
        this.addError(message, args);
        return args;
    }
    addInfo(message, args) {
        args[this.INFO] = message;
    }
    addWarning(message, args) {
        args[this.WARNING] = message;
    }
    addError(message, args) {
        args[this.ERROR] = message;
    }
};
exports.NavigationTargetResolver = NavigationTargetResolver;
exports.NavigationTargetResolver = NavigationTargetResolver = __decorate([
    (0, inversify_1.injectable)()
], NavigationTargetResolver);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/request-navigation-targets-action-handler.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/request-navigation-targets-action-handler.js ***!
  \***************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestNavigationTargetsActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const inject_1 = __webpack_require__(/*! inversify/lib/annotation/inject */ "../../node_modules/inversify/lib/annotation/inject.js");
const navigation_target_provider_registry_1 = __webpack_require__(/*! ./navigation-target-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider-registry.js");
let RequestNavigationTargetsActionHandler = class RequestNavigationTargetsActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestNavigationTargetsAction.KIND];
    }
    execute(action) {
        const editorContext = action.editorContext;
        const allTargets = [];
        const provider = this.navigationTargetProviderRegistry.get(action.targetTypeId);
        if (provider) {
            const targets = provider.getTargets(editorContext);
            targets.forEach(target => allTargets.push(target));
        }
        return [protocol_1.SetNavigationTargetsAction.create(allTargets, { args: editorContext.args })];
    }
};
exports.RequestNavigationTargetsActionHandler = RequestNavigationTargetsActionHandler;
__decorate([
    (0, inject_1.inject)(navigation_target_provider_registry_1.NavigationTargetProviderRegistry),
    __metadata("design:type", Object)
], RequestNavigationTargetsActionHandler.prototype, "navigationTargetProviderRegistry", void 0);
exports.RequestNavigationTargetsActionHandler = RequestNavigationTargetsActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestNavigationTargetsActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/resolve-navigation-targets-action-handler.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/resolve-navigation-targets-action-handler.js ***!
  \***************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResolveNavigationTargetsActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ../../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const navigation_target_resolver_1 = __webpack_require__(/*! ./navigation-target-resolver */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolver.js");
let ResolveNavigationTargetsActionHandler = class ResolveNavigationTargetsActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.ResolveNavigationTargetAction.KIND];
    }
    async execute(action) {
        if (!this.navigationTargetResolver) {
            this.logger.warn('Could not resolve navigation target. No implementation for: NavigationTargetResolver has been bound');
            return [];
        }
        const target = action.navigationTarget;
        const resolution = await this.navigationTargetResolver.resolve(target);
        return [protocol_1.SetResolvedNavigationTargetAction.create(resolution.elementIds, { args: resolution.args })];
    }
};
exports.ResolveNavigationTargetsActionHandler = ResolveNavigationTargetsActionHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], ResolveNavigationTargetsActionHandler.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(navigation_target_resolver_1.NavigationTargetResolver),
    (0, inversify_1.optional)(),
    __metadata("design:type", navigation_target_resolver_1.NavigationTargetResolver)
], ResolveNavigationTargetsActionHandler.prototype, "navigationTargetResolver", void 0);
exports.ResolveNavigationTargetsActionHandler = ResolveNavigationTargetsActionHandler = __decorate([
    (0, inversify_1.injectable)()
], ResolveNavigationTargetsActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/popup-model-factory.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/popup/popup-model-factory.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupModelFactory = void 0;
exports.PopupModelFactory = Symbol('PopupModelFactory');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/request-popup-model-action-handler.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/popup/request-popup-model-action-handler.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestPopupModelActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const logger_1 = __webpack_require__(/*! ../../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const popup_model_factory_1 = __webpack_require__(/*! ./popup-model-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/popup-model-factory.js");
let RequestPopupModelActionHandler = class RequestPopupModelActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestPopupModelAction.KIND];
    }
    execute(action) {
        if (this.popupModelFactory) {
            const hoverElement = this.modelState.index.find(action.elementId);
            if (hoverElement) {
                const popupModel = this.popupModelFactory.createPopupModel(hoverElement, action);
                if (popupModel) {
                    const modelSchema = this.modelSerializer.createSchema(popupModel);
                    return [protocol_1.SetPopupModelAction.create(modelSchema)];
                }
                return [];
            }
            throw new glsp_server_error_1.GLSPServerError(`Could not process 'RequestPopupModelAction'. Hover element with id ${action.elementId} not found`);
        }
        this.logger.warn('Could not process `RequestPopupModelAction`. No `PopupModelFactory` is bound');
        return [];
    }
};
exports.RequestPopupModelActionHandler = RequestPopupModelActionHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], RequestPopupModelActionHandler.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(popup_model_factory_1.PopupModelFactory),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], RequestPopupModelActionHandler.prototype, "popupModelFactory", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], RequestPopupModelActionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], RequestPopupModelActionHandler.prototype, "modelSerializer", void 0);
exports.RequestPopupModelActionHandler = RequestPopupModelActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestPopupModelActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/progress/progress-service.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/progress/progress-service.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultProgressService = exports.ProgressService = void 0;
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const action_dispatcher_1 = __webpack_require__(/*! ../../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
exports.ProgressService = Symbol('ProgressService');
let DefaultProgressService = class DefaultProgressService {
    start(title, options) {
        const progressId = uuid.v4();
        this.actionDispatcher.dispatch(protocol_1.StartProgressAction.create({ progressId, title, ...options }));
        return {
            update: updateOptions => this.actionDispatcher.dispatch(protocol_1.UpdateProgressAction.create(progressId, updateOptions)),
            end: () => this.actionDispatcher.dispatch(protocol_1.EndProgressAction.create(progressId))
        };
    }
};
exports.DefaultProgressService = DefaultProgressService;
__decorate([
    (0, inversify_1.inject)(action_dispatcher_1.ActionDispatcher),
    __metadata("design:type", Object)
], DefaultProgressService.prototype, "actionDispatcher", void 0);
exports.DefaultProgressService = DefaultProgressService = __decorate([
    (0, inversify_1.injectable)()
], DefaultProgressService);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/edge-creation-checker.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/edge-creation-checker.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EdgeCreationChecker = void 0;
exports.EdgeCreationChecker = Symbol('EdgeCreationChecker');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-check-edge-action-handler.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-check-edge-action-handler.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestCheckEdgeActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const diagram_configuration_1 = __webpack_require__(/*! ../../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
const glsp_server_error_1 = __webpack_require__(/*! ../../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const edge_creation_checker_1 = __webpack_require__(/*! ./edge-creation-checker */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/edge-creation-checker.js");
let RequestCheckEdgeActionHandler = class RequestCheckEdgeActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestCheckEdgeAction.KIND];
    }
    execute(action) {
        const hasDynamicHint = this.diagramConfiguration.edgeTypeHints.some(hint => hint.elementTypeId === action.edgeType && hint.dynamic);
        const { edgeType, sourceElementId, targetElementId } = action;
        const isValid = this.edgeCreationChecker && hasDynamicHint ? this.validate(action) : true;
        return [protocol_1.CheckEdgeResultAction.create({ edgeType, isValid, sourceElementId, targetElementId })];
    }
    validate(action) {
        const sourceElement = (0, glsp_server_error_1.getOrThrow)(this.modelState.index.get(action.sourceElementId), 'Invalid `RequestCheckEdgeTargetAction`!. Could not find a source element with id: ' + action.sourceElementId);
        const targetElement = action.targetElementId ? this.modelState.index.get(action.targetElementId) : undefined;
        if (action.targetElementId && !targetElement) {
            throw new glsp_server_error_1.GLSPServerError('Invalid `RequestCheckEdgeTargetAction`! Could not find a target element with id: ' + action.targetElementId);
        }
        return targetElement
            ? this.edgeCreationChecker.isValidTarget(action.edgeType, sourceElement, targetElement)
            : this.edgeCreationChecker.isValidSource(action.edgeType, sourceElement);
    }
};
exports.RequestCheckEdgeActionHandler = RequestCheckEdgeActionHandler;
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], RequestCheckEdgeActionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(diagram_configuration_1.DiagramConfiguration),
    __metadata("design:type", Object)
], RequestCheckEdgeActionHandler.prototype, "diagramConfiguration", void 0);
__decorate([
    (0, inversify_1.inject)(edge_creation_checker_1.EdgeCreationChecker),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], RequestCheckEdgeActionHandler.prototype, "edgeCreationChecker", void 0);
exports.RequestCheckEdgeActionHandler = RequestCheckEdgeActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestCheckEdgeActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-type-hints-action-handler.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-type-hints-action-handler.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestTypeHintsActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const diagram_configuration_1 = __webpack_require__(/*! ../../diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js");
let RequestTypeHintsActionHandler = class RequestTypeHintsActionHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestTypeHintsAction.KIND];
    }
    execute(action) {
        return [
            protocol_1.SetTypeHintsAction.create({
                shapeHints: this.diagramConfiguration.shapeTypeHints,
                edgeHints: this.diagramConfiguration.edgeTypeHints
            })
        ];
    }
};
exports.RequestTypeHintsActionHandler = RequestTypeHintsActionHandler;
__decorate([
    (0, inversify_1.inject)(diagram_configuration_1.DiagramConfiguration),
    __metadata("design:type", Object)
], RequestTypeHintsActionHandler.prototype, "diagramConfiguration", void 0);
exports.RequestTypeHintsActionHandler = RequestTypeHintsActionHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestTypeHintsActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractModelValidator = exports.ModelValidator = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
exports.ModelValidator = Symbol('ModelValidator');
let AbstractModelValidator = class AbstractModelValidator {
    validate(elements, reason) {
        const markers = [];
        for (const element of elements) {
            if (protocol_1.MarkersReason.LIVE === reason) {
                markers.push(...this.doLiveValidation(element));
            }
            else if (protocol_1.MarkersReason.BATCH === reason) {
                markers.push(...this.doBatchValidation(element));
            }
            else {
                markers.push(...this.doValidationForCustomReason(element));
            }
            if (element.children) {
                markers.push(...this.validate(element.children, reason));
            }
        }
        return markers;
    }
    /**
     * Perform the live validation rules for the given <code>element</code>.
     *
     * This will be invoked on start and after each operation for all elements.
     * Thus, the validation should be rather inexpensive.
     * There is no need to traverse through the children in this method as {@link #validate(List, String)} will invoke
     * this method for all children anyway.
     *
     * @param element The element to validate.
     * @return A list of {@link Marker}s for the validated {@link GModelElement}.
     */
    doLiveValidation(element) {
        return [];
    }
    /**
     * Perform the batch validation rules for the given <code>element</code>.
     *
     * <p>
     * This will be invoked on demand by the client.
     * Thus, the validation can include more expensive validation rules.
     * There is no need to traverse through the children in this method as {@link #validate(List, String)} will invoke
     * this method for all children anyway.
     * </p>
     *
     * @param element The element to validate.
     * @return A list of {@link Marker}s for the validated {@link GModelElement}.
     */
    doBatchValidation(element) {
        return [];
    }
    /**
     * Perform a validation for a custom <code>reason</code> with the given <code>element</code>.
     *
     * <p>
     * GLSP editors may add custom reasons for triggering a validation, other than <code>live</code> and
     * <code>batch</code>.
     * Validation requests that are not live or batch validations will be handled by this method.
     * There is no need to traverse through the children in this method as {@link #validate(List, String)} will invoke
     * this method for all children anyway.
     * </p>
     *
     * @param element The element to validate.
     * @return A list of {@link Marker}s for the validated {@link GModelElement}.
     */
    doValidationForCustomReason(element) {
        return [];
    }
};
exports.AbstractModelValidator = AbstractModelValidator;
exports.AbstractModelValidator = AbstractModelValidator = __decorate([
    (0, inversify_1.injectable)()
], AbstractModelValidator);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/request-markers-handler.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/features/validation/request-markers-handler.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestMarkersHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const model_state_1 = __webpack_require__(/*! ../model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const model_validator_1 = __webpack_require__(/*! ./model-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js");
let RequestMarkersHandler = class RequestMarkersHandler {
    constructor() {
        this.actionKinds = [protocol_1.RequestMarkersAction.KIND];
    }
    async execute(action) {
        var _a;
        let elementIDs = action.elementsIDs;
        if (!this.validator) {
            throw new glsp_server_error_1.GLSPServerError('Cannot compute markers! No implementation for ModelValidator has been bound');
        }
        if (!elementIDs || elementIDs.length === 0 || (elementIDs.length === 1 && elementIDs[0] === 'EMPTY')) {
            elementIDs = [this.modelState.root.id];
        }
        const modelElements = this.modelState.index.getAll(elementIDs);
        const markers = await this.validator.validate(modelElements, (_a = action.reason) !== null && _a !== void 0 ? _a : protocol_1.MarkersReason.BATCH);
        return [protocol_1.SetMarkersAction.create(markers)];
    }
};
exports.RequestMarkersHandler = RequestMarkersHandler;
__decorate([
    (0, inversify_1.inject)(model_validator_1.ModelValidator),
    (0, inversify_1.optional)(),
    __metadata("design:type", Object)
], RequestMarkersHandler.prototype, "validator", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], RequestMarkersHandler.prototype, "modelState", void 0);
exports.RequestMarkersHandler = RequestMarkersHandler = __decorate([
    (0, inversify_1.injectable)()
], RequestMarkersHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/apply-label-edit-operation-handler.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/apply-label-edit-operation-handler.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelApplyLabelEditOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelApplyLabelEditOperationHandler = class GModelApplyLabelEditOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.ApplyLabelEditOperation.KIND;
    }
    createCommand(operation) {
        const label = (0, glsp_server_error_1.getOrThrow)(this.modelState.index.findByClass(operation.labelId, graph_1.GLabel), 'Element with provided ID cannot be found or is not a GLabel');
        return label.text !== operation.text //
            ? this.commandOf(() => (label.text = operation.text))
            : undefined;
    }
};
exports.GModelApplyLabelEditOperationHandler = GModelApplyLabelEditOperationHandler;
exports.GModelApplyLabelEditOperationHandler = GModelApplyLabelEditOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelApplyLabelEditOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-bounds-operation-handler.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-bounds-operation-handler.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelChangeBoundsOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
/**
 * Applies {@link ChangeBoundsOperation} directly to the GModel.
 */
let GModelChangeBoundsOperationHandler = class GModelChangeBoundsOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.ChangeBoundsOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => this.executeChangeBounds(operation));
    }
    executeChangeBounds(operation) {
        for (const element of operation.newBounds) {
            this.changeElementBounds(element.elementId, element.newSize, element.newPosition);
        }
    }
    changeElementBounds(elementId, newSize, newPosition) {
        const index = this.modelState.index;
        const nodeToUpdate = index.findByClass(elementId, graph_1.GNode);
        if (!nodeToUpdate) {
            return;
        }
        const parent = nodeToUpdate.parent;
        let positionToSet = { x: 0, y: 0 };
        if (newPosition) {
            positionToSet = parent instanceof graph_1.GModelRoot ? newPosition : { x: Math.max(0, newPosition.x), y: Math.max(0, newPosition.y) };
        }
        if (nodeToUpdate.layout) {
            if (!nodeToUpdate.layoutOptions) {
                nodeToUpdate.layoutOptions = {};
            }
            nodeToUpdate.layoutOptions['prefWidth'] = newSize.width;
            nodeToUpdate.layoutOptions['prefHeight'] = newSize.height;
        }
        nodeToUpdate.size = newSize;
        nodeToUpdate.position = positionToSet;
    }
};
exports.GModelChangeBoundsOperationHandler = GModelChangeBoundsOperationHandler;
exports.GModelChangeBoundsOperationHandler = GModelChangeBoundsOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelChangeBoundsOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-routing-points-operation-handler.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-routing-points-operation-handler.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelChangeRoutingPointsOperationHandler = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const layout_util_1 = __webpack_require__(/*! ../utils/layout-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelChangeRoutingPointsOperationHandler = class GModelChangeRoutingPointsOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.ChangeRoutingPointsOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => this.executeChangeRoutingPoints(operation));
    }
    executeChangeRoutingPoints(operation) {
        if (!operation.newRoutingPoints) {
            throw new glsp_server_error_1.GLSPServerError('Incomplete change routingPoints  action');
        }
        const index = this.modelState.index;
        operation.newRoutingPoints.forEach(routingPoints => (0, layout_util_1.applyRoutingPoints)(routingPoints, index));
    }
};
exports.GModelChangeRoutingPointsOperationHandler = GModelChangeRoutingPointsOperationHandler;
exports.GModelChangeRoutingPointsOperationHandler = GModelChangeRoutingPointsOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelChangeRoutingPointsOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/cut-operation-handler.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/cut-operation-handler.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelCutOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const action_dispatcher_1 = __webpack_require__(/*! ../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelCutOperationHandler = class GModelCutOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CutOperation.KIND;
    }
    createCommand(operation) {
        const cuttableElementIds = this.getElementToCut(operation);
        // If we have cuttable elements we dispatch a DeleteElementOperation otherwise do nothing
        if (cuttableElementIds.length > 0) {
            this.actionDispatcher.dispatch(protocol_1.DeleteElementOperation.create(cuttableElementIds));
        }
        return undefined;
    }
    getElementToCut(cutOperation) {
        return cutOperation.editorContext.selectedElementIds;
    }
};
exports.GModelCutOperationHandler = GModelCutOperationHandler;
__decorate([
    (0, inversify_1.inject)(action_dispatcher_1.ActionDispatcher),
    __metadata("design:type", Object)
], GModelCutOperationHandler.prototype, "actionDispatcher", void 0);
exports.GModelCutOperationHandler = GModelCutOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelCutOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/delete-operation-handler.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/delete-operation-handler.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelDeleteOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelDeleteOperationHandler = class GModelDeleteOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    get operationType() {
        return protocol_1.DeleteElementOperation.KIND;
    }
    createCommand(operation) {
        const elementIds = operation.elementIds;
        if (!elementIds || elementIds.length === 0) {
            this.logger.warn('Elements to delete are not specified');
            return undefined;
        }
        return this.commandOf(() => this.deleteElements(elementIds));
    }
    deleteElements(elementIds) {
        if (!elementIds || elementIds.length === 0) {
            this.logger.warn('Elements to delete are not specified');
            return;
        }
        const index = this.modelState.index;
        this.allDependentsIds = new Set();
        const success = elementIds.every(eId => this.delete(eId, index));
        if (!success) {
            this.logger.warn('Could not delete all elements as requested (see messages above to find out why)');
        }
    }
    delete(elementId, index) {
        if (this.allDependentsIds.has(elementId)) {
            return true;
        }
        const element = index.find(elementId);
        if (!element) {
            this.logger.warn('Element not found: ' + elementId);
            return false;
        }
        if (!element.parent) {
            this.logger.warn("The requested element doesn't have a parent; it can't be deleted");
            return false;
        }
        const dependents = new Set();
        this.collectDependents(dependents, element, false);
        dependents.forEach(dependant => {
            const index = dependant.parent.children.findIndex(element => element === dependant);
            if (index > -1) {
                dependant.parent.children.splice(index, 1);
            }
            this.allDependentsIds.add(dependant.id);
        });
        return true;
    }
    collectDependents(dependents, elementToDelete, isChild) {
        if (dependents.has(elementToDelete)) {
            return;
        }
        if (elementToDelete.children.length > 0) {
            elementToDelete.children.forEach(child => this.collectDependents(dependents, child, true));
        }
        if (elementToDelete instanceof graph_1.GNode || elementToDelete instanceof graph_1.GPort) {
            const index = this.modelState.index;
            index.getIncomingEdges(elementToDelete).forEach(incoming => {
                dependents.add(incoming);
            });
            index.getOutgoingEdges(elementToDelete).forEach(outgoing => {
                dependents.add(outgoing);
            });
        }
        if (!isChild) {
            dependents.add(elementToDelete);
        }
    }
};
exports.GModelDeleteOperationHandler = GModelDeleteOperationHandler;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], GModelDeleteOperationHandler.prototype, "logger", void 0);
exports.GModelDeleteOperationHandler = GModelDeleteOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelDeleteOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-edge-operation-handler.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-edge-operation-handler.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelCreateEdgeOperationHandler = void 0;
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const gnode_1 = __webpack_require__(/*! @eclipse-glsp/graph/lib/gnode */ "../../node_modules/@eclipse-glsp/graph/lib/gnode.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
/**
 * An abstract base implementation of {@link CreateEdgeOperation} handlers for diagram implementations
 * where the graphical model is also directly used as source model.
 * (i.e. all operation handlers directly modify the graphical model).
 */
let GModelCreateEdgeOperationHandler = class GModelCreateEdgeOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CreateEdgeOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => this.executeCreation(operation));
    }
    getTriggerActions() {
        return this.elementTypeIds.map(typeId => protocol_1.TriggerEdgeCreationAction.create(typeId));
    }
    executeCreation(operation) {
        const index = this.modelState.index;
        const source = index.find(operation.sourceElementId, element => element instanceof gnode_1.GNode || element instanceof graph_1.GPort);
        const target = index.find(operation.targetElementId, element => element instanceof gnode_1.GNode || element instanceof graph_1.GPort);
        if (!source || !target) {
            throw new Error(`Invalid source or target for source ID ${operation.sourceElementId} and target ID ${operation.targetElementId}`);
        }
        const connection = this.createEdge(source, target);
        if (connection) {
            const currentModel = this.modelState.root;
            currentModel.children.push(connection);
        }
    }
};
exports.GModelCreateEdgeOperationHandler = GModelCreateEdgeOperationHandler;
exports.GModelCreateEdgeOperationHandler = GModelCreateEdgeOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelCreateEdgeOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-node-operation-handler.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-node-operation-handler.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelCreateNodeOperationHandler = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const action_dispatcher_1 = __webpack_require__(/*! ../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
const layout_util_1 = __webpack_require__(/*! ../utils/layout-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
/**
 * An abstract base implementation of {@link CreateNodeOperationHandler} for diagram implementations
 * where the graphical model is also directly used as source model.
 * (i.e. all operation handlers directly modify the graphical model).
 */
let GModelCreateNodeOperationHandler = class GModelCreateNodeOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CreateNodeOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => this.executeCreation(operation));
    }
    executeCreation(operation) {
        var _a;
        const container = (_a = this.getContainer(operation)) !== null && _a !== void 0 ? _a : this.modelState.root;
        const relativeLocation = this.getRelativeLocation(operation);
        const element = this.createNode(operation, relativeLocation);
        if (element) {
            container.children.push(element);
            element.parent = container;
            this.actionDispatcher.dispatchAfterNextUpdate(protocol_1.SelectAction.create({ selectedElementsIDs: [element.id] }));
        }
    }
    getTriggerActions() {
        return this.elementTypeIds.map(elementTypeId => this.createTriggerNodeCreationAction(elementTypeId));
    }
    createTriggerNodeCreationAction(elementTypeId) {
        return protocol_1.TriggerNodeCreationAction.create(elementTypeId, {
            ghostElement: this.createTriggerGhostElement(elementTypeId),
            args: this.createTriggerArgs(elementTypeId)
        });
    }
    createTriggerGhostElement(elementTypeId) {
        return undefined;
    }
    createTriggerArgs(elementTypeId) {
        return undefined;
    }
    /**
     * Return the GModelElement that will contain the newly created node. It is usually
     * the target element ({@link CreateNodeOperation.containerId}), but could also
     * be e.g. an intermediate compartment, or even a different Node.
     *
     * @param operation
     * @return the GModelElement that will contain the newly created node.
     */
    getContainer(operation) {
        const index = this.modelState.index;
        return operation.containerId ? index.get(operation.containerId) : undefined;
    }
    getLocation(operation) {
        return operation.location;
    }
    /**
     * Retrieves the diagram absolute location and the target container from the given {@link CreateNodeOperation}
     * and converts the absolute location to coordinates relative to the given container.
     *  Relative coordinates can only be retrieved if the given container element is part of
     * a hierarchy of {@link GBoundsAware} elements. This means each (recursive) parent element need to
     * implement {@link GBoundsAware}. If that is not the case this method returns `undefined`.
     * @param absoluteLocation The diagram absolute position.
     * @param container The container element.
     * @returns The relative position or `undefined`.
     */
    getRelativeLocation(operation) {
        var _a, _b;
        const container = (_a = this.getContainer(operation)) !== null && _a !== void 0 ? _a : this.modelState.root;
        const absoluteLocation = (_b = this.getLocation(operation)) !== null && _b !== void 0 ? _b : protocol_1.Point.ORIGIN;
        return (0, layout_util_1.getRelativeLocation)(absoluteLocation, container);
    }
};
exports.GModelCreateNodeOperationHandler = GModelCreateNodeOperationHandler;
__decorate([
    (0, inversify_1.inject)(action_dispatcher_1.ActionDispatcher),
    __metadata("design:type", Object)
], GModelCreateNodeOperationHandler.prototype, "actionDispatcher", void 0);
exports.GModelCreateNodeOperationHandler = GModelCreateNodeOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelCreateNodeOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-diagram-module.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-diagram-module.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelDiagramModule = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const diagram_module_1 = __webpack_require__(/*! ../di/diagram-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/diagram-module.js");
const request_clipboard_data_action_handler_1 = __webpack_require__(/*! ../features/clipboard/request-clipboard-data-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/clipboard/request-clipboard-data-action-handler.js");
const gmodel_factory_1 = __webpack_require__(/*! ../features/model/gmodel-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js");
const model_state_1 = __webpack_require__(/*! ../features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const apply_label_edit_operation_handler_1 = __webpack_require__(/*! ./apply-label-edit-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/apply-label-edit-operation-handler.js");
const change_bounds_operation_handler_1 = __webpack_require__(/*! ./change-bounds-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-bounds-operation-handler.js");
const change_routing_points_operation_handler_1 = __webpack_require__(/*! ./change-routing-points-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-routing-points-operation-handler.js");
const cut_operation_handler_1 = __webpack_require__(/*! ./cut-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/cut-operation-handler.js");
const delete_operation_handler_1 = __webpack_require__(/*! ./delete-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/delete-operation-handler.js");
const paste_operation_handler_1 = __webpack_require__(/*! ./paste-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/paste-operation-handler.js");
const reconnect_edge_operation_handler_1 = __webpack_require__(/*! ./reconnect-edge-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/reconnect-edge-operation-handler.js");
/**
 * Extension of the {@link DiagramModule} to provide GModel integration.
 *
 * Contains all bindings of {@link DiagramModule}.
 *
 * Additionally binds:
 * - {@link GModelFactory} to {@link GModelFactoryNullImpl}
 * - {@link RequestClipboardDataActionHandler} to {@link ActionHandler}
 * - {@link GModelApplyLabelEditOperationHandler} to {@link OperationHandler}
 * - {@link GModelChangeBoundsOperationHandler} to {@link OperationHandler}
 * - {@link GModelCutOperationHandler} to {@link OperationHandler}
 * - {@link GModelDeleteOperationHandler} to {@link OperationHandler}
 * - {@link GModelPasteOperationHandler} to {@link OperationHandler}
 * - {@link GModelReconnectEdgeOperationHandler} to {@link OperationHandler}
 * - {@link GModelChangeRoutingPointsOperationHandler} to {@link OperationHandler}

 */
let GModelDiagramModule = class GModelDiagramModule extends diagram_module_1.DiagramModule {
    bindGModelFactory() {
        return gmodel_factory_1.GModelFactoryNullImpl;
    }
    bindModelState() {
        return model_state_1.DefaultModelState;
    }
    configureActionHandlers(binding) {
        super.configureActionHandlers(binding);
        binding.add(request_clipboard_data_action_handler_1.RequestClipboardDataActionHandler);
    }
    configureOperationHandlers(binding) {
        super.configureOperationHandlers(binding);
        binding.add(apply_label_edit_operation_handler_1.GModelApplyLabelEditOperationHandler);
        binding.add(change_bounds_operation_handler_1.GModelChangeBoundsOperationHandler);
        binding.add(cut_operation_handler_1.GModelCutOperationHandler);
        binding.add(delete_operation_handler_1.GModelDeleteOperationHandler);
        binding.add(paste_operation_handler_1.GModelPasteOperationHandler);
        binding.add(reconnect_edge_operation_handler_1.GModelReconnectEdgeOperationHandler);
        binding.add(change_routing_points_operation_handler_1.GModelChangeRoutingPointsOperationHandler);
    }
};
exports.GModelDiagramModule = GModelDiagramModule;
exports.GModelDiagramModule = GModelDiagramModule = __decorate([
    (0, inversify_1.injectable)()
], GModelDiagramModule);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelOperationHandler = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const recording_command_1 = __webpack_require__(/*! ../command/recording-command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../features/model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const operation_handler_1 = __webpack_require__(/*! ../operations/operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
(0, inversify_1.injectable)();
class GModelOperationHandler extends operation_handler_1.OperationHandler {
    commandOf(runnable) {
        return new recording_command_1.GModelRecordingCommand(this.modelState, this.serializer, runnable);
    }
}
exports.GModelOperationHandler = GModelOperationHandler;
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], GModelOperationHandler.prototype, "serializer", void 0);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/paste-operation-handler.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/paste-operation-handler.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shift = exports.GModelPasteOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../features/model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelPasteOperationHandler = class GModelPasteOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.PasteOperation.KIND;
        this.DEFAULT_OFFSET = 20;
    }
    createCommand(operation) {
        const elements = this.getCopiedElements(operation.clipboardData['application/json']);
        return elements.length > 0 //
            ? this.commandOf(() => this.executePaste(elements, operation.editorContext))
            : undefined;
    }
    getCopiedElements(jsonString) {
        const schemas = JSON.parse(jsonString);
        return schemas.map(schema => this.modelSerializer.createElement(schema, this.modelState.root));
    }
    executePaste(elements, context) {
        shift(elements, this.computeOffset(elements, context.lastMousePosition));
        const idMap = this.reassignIds(elements);
        this.filterElements(elements, idMap);
        this.rewireEdges(elements, idMap);
        this.modelState.root.children.push(...elements);
    }
    computeOffset(elements, lastMousePosition) {
        var _a;
        const offset = { x: this.DEFAULT_OFFSET, y: this.DEFAULT_OFFSET };
        if (lastMousePosition) {
            const referenceElement = this.getReferenceElementForPasteOffset(elements);
            if (referenceElement) {
                const position = (_a = referenceElement.position) !== null && _a !== void 0 ? _a : protocol_1.Point.ORIGIN;
                offset.x = lastMousePosition.x - position.x;
                offset.y = lastMousePosition.y - position.y;
            }
        }
        return offset;
    }
    getReferenceElementForPasteOffset(elements) {
        var _a;
        let minY = Number.MAX_VALUE;
        for (const element of elements) {
            if ((0, graph_1.isGBoundsAware)(element)) {
                const position = (_a = element.position) !== null && _a !== void 0 ? _a : protocol_1.Point.ORIGIN;
                if (minY > position.y) {
                    minY = position.y;
                    return element;
                }
            }
        }
        return undefined;
    }
    reassignIds(elements) {
        const idMap = new Map();
        elements.forEach(element => {
            const newId = uuid.v4();
            idMap.set(element.id, newId);
            element.id = newId;
            const childMap = this.reassignIds(element.children);
            childMap.forEach((value, key) => {
                idMap.set(key, value);
            });
        });
        return idMap;
    }
    filterElements(elements, idMap) {
        elements.filter(e => !this.shouldExcludeElement(e, idMap));
    }
    shouldExcludeElement(element, idMap) {
        return false;
    }
    rewireEdges(elements, idMap) {
        const edges = elements.filter(element => element instanceof graph_1.GEdge);
        edges.forEach(edge => {
            const sourceId = idMap.get(edge.sourceId);
            if (sourceId) {
                edge.sourceId = sourceId;
            }
            const targetId = idMap.get(edge.targetId);
            if (targetId) {
                edge.targetId = targetId;
            }
        });
    }
};
exports.GModelPasteOperationHandler = GModelPasteOperationHandler;
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], GModelPasteOperationHandler.prototype, "modelSerializer", void 0);
exports.GModelPasteOperationHandler = GModelPasteOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelPasteOperationHandler);
function shift(elements, offset) {
    elements
        .filter(element => (0, graph_1.isGBoundsAware)(element))
        .map(element => element)
        .forEach(gBoundsAware => {
        var _a;
        const position = (_a = gBoundsAware.position) !== null && _a !== void 0 ? _a : protocol_1.Point.ORIGIN;
        gBoundsAware.position = { x: position.x + offset.x, y: position.y + offset.y };
    });
}
exports.shift = shift;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/reconnect-edge-operation-handler.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/gmodel/reconnect-edge-operation-handler.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelReconnectEdgeOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const gmodel_operation_handler_1 = __webpack_require__(/*! ./gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js");
let GModelReconnectEdgeOperationHandler = class GModelReconnectEdgeOperationHandler extends gmodel_operation_handler_1.GModelOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.ReconnectEdgeOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => this.executeReconnect(operation));
    }
    executeReconnect(operation) {
        if (!operation.edgeElementId || !operation.sourceElementId || !operation.targetElementId) {
            throw new glsp_server_error_1.GLSPServerError('Incomplete reconnect connection action');
        }
        const index = this.modelState.index;
        const edge = index.findByClass(operation.edgeElementId, graph_1.GEdge);
        const source = index.findByClass(operation.sourceElementId, graph_1.GNode || graph_1.GPort);
        const target = index.findByClass(operation.targetElementId, graph_1.GNode || graph_1.GPort);
        if (!edge) {
            throw new Error(`Invalid edge: edge ID ${operation.edgeElementId}`);
        }
        if (!source) {
            throw new Error(`Invalid source: source ID ${operation.sourceElementId}`);
        }
        if (!target) {
            throw new Error(`Invalid target: target ID ${operation.targetElementId}`);
        }
        edge.sourceId = source.id;
        edge.targetId = target.id;
        edge.routingPoints = [];
    }
};
exports.GModelReconnectEdgeOperationHandler = GModelReconnectEdgeOperationHandler;
exports.GModelReconnectEdgeOperationHandler = GModelReconnectEdgeOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], GModelReconnectEdgeOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js"), exports);
__exportStar(__webpack_require__(/*! ./actions/action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./actions/action-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-handler-registry.js"), exports);
__exportStar(__webpack_require__(/*! ./actions/client-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/client-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./actions/global-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/global-action-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./command/command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command.js"), exports);
__exportStar(__webpack_require__(/*! ./command/command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js"), exports);
__exportStar(__webpack_require__(/*! ./command/recording-command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js"), exports);
__exportStar(__webpack_require__(/*! ./command/undo-redo-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/command/undo-redo-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./di/binding-target */ "../../node_modules/@eclipse-glsp/server/lib/common/di/binding-target.js"), exports);
__exportStar(__webpack_require__(/*! ./di/client-session-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/client-session-module.js"), exports);
__exportStar(__webpack_require__(/*! ./di/diagram-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/diagram-module.js"), exports);
__exportStar(__webpack_require__(/*! ./di/glsp-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/glsp-module.js"), exports);
__exportStar(__webpack_require__(/*! ./di/multi-binding */ "../../node_modules/@eclipse-glsp/server/lib/common/di/multi-binding.js"), exports);
__exportStar(__webpack_require__(/*! ./di/server-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/server-module.js"), exports);
__exportStar(__webpack_require__(/*! ./di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js"), exports);
__exportStar(__webpack_require__(/*! ./diagram/diagram-configuration */ "../../node_modules/@eclipse-glsp/server/lib/common/diagram/diagram-configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./features/clipboard/request-clipboard-data-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/clipboard/request-clipboard-data-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/command-palette-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/command-palette-action-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/context-actions-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/context-actions-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-actions-provider-registry.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/context-menu-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/context-menu-item-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/request-context-actions-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/request-context-actions-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/contextactions/tool-palette-item-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/contextactions/tool-palette-item-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./features/directediting/context-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator.js"), exports);
__exportStar(__webpack_require__(/*! ./features/directediting/context-edit-validator-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/context-edit-validator-registry.js"), exports);
__exportStar(__webpack_require__(/*! ./features/directediting/label-edit-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/label-edit-validator.js"), exports);
__exportStar(__webpack_require__(/*! ./features/directediting/request-edit-validation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/directediting/request-edit-validation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/layout/computed-bounds-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/computed-bounds-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/layout/layout-engine */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-engine.js"), exports);
__exportStar(__webpack_require__(/*! ./features/layout/layout-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/layout/layout-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/gmodel-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-factory.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/gmodel-index */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-index.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/request-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/request-model-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/save-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/save-model-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/model/source-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/source-model-storage.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/json-opener-options */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/json-opener-options.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/navigation-target-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/navigation-target-provider-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-provider-registry.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/navigation-target-resolution */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolution.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/navigation-target-resolver */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/navigation-target-resolver.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/request-navigation-targets-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/request-navigation-targets-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/navigation/resolve-navigation-targets-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/navigation/resolve-navigation-targets-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/popup/popup-model-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/popup-model-factory.js"), exports);
__exportStar(__webpack_require__(/*! ./features/popup/request-popup-model-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/popup/request-popup-model-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/progress/progress-service */ "../../node_modules/@eclipse-glsp/server/lib/common/features/progress/progress-service.js"), exports);
__exportStar(__webpack_require__(/*! ./features/type-hints/edge-creation-checker */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/edge-creation-checker.js"), exports);
__exportStar(__webpack_require__(/*! ./features/type-hints/request-check-edge-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-check-edge-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/type-hints/request-type-hints-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/type-hints/request-type-hints-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./features/validation/model-validator */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/model-validator.js"), exports);
__exportStar(__webpack_require__(/*! ./features/validation/request-markers-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/validation/request-markers-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/apply-label-edit-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/apply-label-edit-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/change-bounds-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-bounds-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/change-routing-points-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/change-routing-points-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/cut-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/cut-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/delete-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/delete-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/gmodel-create-edge-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-edge-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/gmodel-create-node-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-create-node-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/gmodel-diagram-module */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-diagram-module.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/gmodel-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/gmodel-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/paste-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/paste-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/reconnect-edge-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/gmodel/reconnect-edge-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/glsp-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/common/launch/glsp-server-launcher.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/jsonrpc-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/common/launch/jsonrpc-server-launcher.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/compound-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/compound-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/create-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/create-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/json-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/json-operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/operation-action-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./operations/operation-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol/client-action */ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/client-action.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol/glsp-server */ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/glsp-server.js"), exports);
__exportStar(__webpack_require__(/*! ./reexport */ "../../node_modules/@eclipse-glsp/server/lib/common/reexport.js"), exports);
__exportStar(__webpack_require__(/*! ./session/client-session */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session.js"), exports);
__exportStar(__webpack_require__(/*! ./session/client-session-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-factory.js"), exports);
__exportStar(__webpack_require__(/*! ./session/client-session-initializer */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js"), exports);
__exportStar(__webpack_require__(/*! ./session/client-session-listener */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-listener.js"), exports);
__exportStar(__webpack_require__(/*! ./session/client-session-manager */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-manager.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/args-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/args-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/client-options-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/client-options-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/console-logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/console-logger.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/layout-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/promise-queue */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/promise-queue.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/launch/glsp-server-launcher.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/launch/glsp-server-launcher.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLSPServerLauncher = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
let GLSPServerLauncher = class GLSPServerLauncher {
    constructor() {
        this._modules = [];
        this.toDispose = new protocol_1.DisposableCollection();
    }
    configure(serverModule, ...additionalModules) {
        this._modules.push(serverModule, ...additionalModules);
    }
    createContainer(...additionalModules) {
        const container = this.parentContainer ? this.parentContainer.createChild() : new inversify_1.Container();
        container.load(...this._modules, ...additionalModules);
        return container;
    }
    start(startParams) {
        if (!this.running) {
            this.running = true;
            return this.run(startParams);
        }
        this.logger.warn('Could not start launcher. Launcher is already running!');
    }
    shutdown() {
        if (this.running) {
            this.logger.info('Shutdown GLSPServerLauncher');
            const result = this.stop();
            this.running = false;
            return result;
        }
        this.logger.warn('Could not stop launcher. Launcher is not running!');
    }
    stop() {
        this.dispose();
    }
    dispose() {
        this.toDispose.dispose();
    }
    get modules() {
        if (!this._modules) {
            throw new Error('The GLSPServerLauncher has not been configured yet');
        }
        return this._modules;
    }
};
exports.GLSPServerLauncher = GLSPServerLauncher;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], GLSPServerLauncher.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.InjectionContainer),
    (0, inversify_1.optional)(),
    __metadata("design:type", inversify_1.Container)
], GLSPServerLauncher.prototype, "parentContainer", void 0);
exports.GLSPServerLauncher = GLSPServerLauncher = __decorate([
    (0, inversify_1.injectable)()
], GLSPServerLauncher);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/launch/jsonrpc-server-launcher.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/launch/jsonrpc-server-launcher.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcGLSPServerLauncher = exports.START_UP_COMPLETE_MSG = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const glsp_server_launcher_1 = __webpack_require__(/*! ./glsp-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/common/launch/glsp-server-launcher.js");
exports.START_UP_COMPLETE_MSG = '[GLSP-Server]:Startup completed. Accepting requests on port:';
let JsonRpcGLSPServerLauncher = class JsonRpcGLSPServerLauncher extends glsp_server_launcher_1.GLSPServerLauncher {
    constructor() {
        super();
        this.serverInstances = new Map();
        this.startupCompleteMessage = exports.START_UP_COMPLETE_MSG;
        this.toDispose.push(protocol_1.Disposable.create(() => {
            this.serverInstances.forEach(instance => this.disposeServerInstance(instance));
        }));
    }
    disposeServerInstance(instance) {
        this.serverInstances.delete(instance.clientConnection);
        instance.server.shutdown();
        instance.container.unbindAll();
        instance.clientConnection.dispose();
    }
    createServerInstance(clientConnection) {
        const container = this.createContainer(this.createJsonRpcModule(clientConnection));
        const server = container.get(protocol_1.GLSPServer);
        const instance = { container, clientConnection, server };
        this.serverInstances.set(clientConnection, instance);
        this.configureClientConnection(instance);
    }
    createJsonRpcModule(clientConnection) {
        return new inversify_1.ContainerModule(bind => {
            bind(protocol_1.GLSPClientProxy).toDynamicValue(ctx => {
                const proxy = ctx.container.resolve(protocol_1.JsonrpcClientProxy);
                proxy.initialize(clientConnection);
                return proxy;
            });
        });
    }
    configureClientConnection(serverInstance) {
        (0, protocol_1.configureClientConnection)(serverInstance.clientConnection, serverInstance.server);
        serverInstance.clientConnection.onNotification(protocol_1.JsonrpcGLSPClient.ShutdownNotification, () => this.disposeServerInstance(serverInstance));
        this.logger.info('Starting GLSP server connection');
    }
    createClientProxy(serverInstance) {
        const proxy = serverInstance.container.resolve(protocol_1.JsonrpcClientProxy);
        proxy.initialize(serverInstance.clientConnection);
        return proxy;
    }
};
exports.JsonRpcGLSPServerLauncher = JsonRpcGLSPServerLauncher;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], JsonRpcGLSPServerLauncher.prototype, "logger", void 0);
exports.JsonRpcGLSPServerLauncher = JsonRpcGLSPServerLauncher = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], JsonRpcGLSPServerLauncher);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/compound-operation-handler.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/compound-operation-handler.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompoundOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const command_1 = __webpack_require__(/*! ../command/command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command.js");
const operation_handler_1 = __webpack_require__(/*! ./operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
const operation_handler_registry_1 = __webpack_require__(/*! ./operation-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js");
/**
 * Generic {@link OperationHandler} from {@link CompoundOperations}.
 * Retrieves the corresponding execution commands for the list of (sub) operations
 * and constructs a {@link CompoundCommand} for them.
 */
let CompoundOperationHandler = class CompoundOperationHandler extends operation_handler_1.OperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CompoundOperation.KIND;
    }
    async createCommand(operation) {
        const maybeCommands = operation.operationList.map(op => { var _a; return (_a = this.operationHandlerRegistry.getOperationHandler(op)) === null || _a === void 0 ? void 0 : _a.execute(op); });
        const commands = [];
        for await (const command of maybeCommands) {
            if (command) {
                commands.push(command);
            }
        }
        return new command_1.CompoundCommand(commands);
    }
};
exports.CompoundOperationHandler = CompoundOperationHandler;
__decorate([
    (0, inversify_1.inject)(operation_handler_registry_1.OperationHandlerRegistry),
    __metadata("design:type", operation_handler_registry_1.OperationHandlerRegistry)
], CompoundOperationHandler.prototype, "operationHandlerRegistry", void 0);
exports.CompoundOperationHandler = CompoundOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], CompoundOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/create-operation-handler.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/create-operation-handler.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOperationHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const operation_handler_1 = __webpack_require__(/*! ./operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
var CreateOperationHandler;
(function (CreateOperationHandler) {
    function is(object) {
        return (object instanceof operation_handler_1.OperationHandler &&
            (0, protocol_1.hasStringProp)(object, 'operationType') &&
            (0, protocol_1.hasStringProp)(object, 'label') &&
            (0, protocol_1.hasArrayProp)(object, 'elementTypeIds') &&
            (0, protocol_1.hasFunctionProp)(object, 'getTriggerActions', true));
    }
    CreateOperationHandler.is = is;
})(CreateOperationHandler || (exports.CreateOperationHandler = CreateOperationHandler = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/json-operation-handler.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/json-operation-handler.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonCreateEdgeOperationHandler = exports.JsonCreateNodeOperationHandler = exports.JsonOperationHandler = exports.JsonRecordingCommand = exports.JsonModelState = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const recording_command_1 = __webpack_require__(/*! ../command/recording-command */ "../../node_modules/@eclipse-glsp/server/lib/common/command/recording-command.js");
const layout_util_1 = __webpack_require__(/*! ../utils/layout-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js");
const operation_handler_1 = __webpack_require__(/*! ./operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
var JsonModelState;
(function (JsonModelState) {
    function is(modelState) {
        return (0, protocol_1.hasObjectProp)(modelState, 'sourceModel') && (0, protocol_1.hasFunctionProp)(modelState, 'updateSourceModel');
    }
    JsonModelState.is = is;
})(JsonModelState || (exports.JsonModelState = JsonModelState = {}));
/**
 * Simple base implementation of {@link AbstractRecordingCommand} that allows recording of changes made
 * to the `sourceModel` of the given {@link JsonModelState} during the given `doExecute` function
 */
class JsonRecordingCommand extends recording_command_1.AbstractRecordingCommand {
    constructor(modelState, doExecute) {
        super();
        this.modelState = modelState;
        this.doExecute = doExecute;
    }
    getJsonObject() {
        return this.modelState.sourceModel;
    }
    postChange(newModel) {
        return this.modelState.updateSourceModel(newModel);
    }
}
exports.JsonRecordingCommand = JsonRecordingCommand;
/**
 * Reusable {@link OperationHandler} base implementation for diagram languages that use a (serializable) JSON-based source model.
 * To use this class (or its subclasses) the injected {@link ModelState} has to implement the {@link JsonModelState} interface.
 *
 */
let JsonOperationHandler = class JsonOperationHandler extends operation_handler_1.OperationHandler {
    commandOf(runnable) {
        if (!JsonModelState.is(this.modelState)) {
            throw new Error('Cannot create command. The underlying model state does not implement the `JsonModelState` interface');
        }
        return new JsonRecordingCommand(this.modelState, runnable);
    }
};
exports.JsonOperationHandler = JsonOperationHandler;
exports.JsonOperationHandler = JsonOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], JsonOperationHandler);
/**
 * Reusable {@link CreateNodeOperationHandler} base implementation for diagram languages that use a (serializable) JSON-based source model.
 */
let JsonCreateNodeOperationHandler = class JsonCreateNodeOperationHandler extends JsonOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CreateNodeOperation.KIND;
    }
    getTriggerActions() {
        return this.elementTypeIds.map(elementTypeId => this.createTriggerNodeCreationAction(elementTypeId));
    }
    createTriggerNodeCreationAction(elementTypeId) {
        return protocol_1.TriggerNodeCreationAction.create(elementTypeId, {
            ghostElement: this.createTriggerGhostElement(elementTypeId),
            args: this.createTriggerArgs(elementTypeId)
        });
    }
    createTriggerGhostElement(elementTypeId) {
        return undefined;
    }
    createTriggerArgs(elementTypeId) {
        return undefined;
    }
    /**
     * Return the GModelElement that will contain the newly created node. It is usually
     * the target element ({@link CreateNodeOperation.containerId}), but could also
     * be e.g. an intermediate compartment, or even a different Node.
     *
     * @param operation
     * @return the GModelElement that will contain the newly created node.
     */
    getContainer(operation) {
        const index = this.modelState.index;
        return operation.containerId ? index.get(operation.containerId) : undefined;
    }
    getLocation(operation) {
        return operation.location;
    }
    /**
     * Retrieves the diagram absolute location and the target container from the given {@link CreateNodeOperation}
     * and converts the absolute location to coordinates relative to the given container.
     *  Relative coordinates can only be retrieved if the given container element is part of
     * a hierarchy of {@link GBoundsAware} elements. This means each (recursive) parent element need to
     * implement {@link GBoundsAware}. If that is not the case this method returns `undefined`.
     * @param absoluteLocation The diagram absolute position.
     * @param container The container element.
     * @returns The relative position or `undefined`.
     */
    getRelativeLocation(operation) {
        var _a, _b;
        const container = (_a = this.getContainer(operation)) !== null && _a !== void 0 ? _a : this.modelState.root;
        const absoluteLocation = (_b = this.getLocation(operation)) !== null && _b !== void 0 ? _b : protocol_1.Point.ORIGIN;
        return (0, layout_util_1.getRelativeLocation)(absoluteLocation, container);
    }
};
exports.JsonCreateNodeOperationHandler = JsonCreateNodeOperationHandler;
exports.JsonCreateNodeOperationHandler = JsonCreateNodeOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], JsonCreateNodeOperationHandler);
/**
 * Reusable {@link CreateEdgeOperationHandler} base implementation for diagram languages that use a (serializable) JSON-based source model.
 */
let JsonCreateEdgeOperationHandler = class JsonCreateEdgeOperationHandler extends JsonOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.CreateEdgeOperation.KIND;
    }
    getTriggerActions() {
        return this.elementTypeIds.map(typeId => protocol_1.TriggerEdgeCreationAction.create(typeId));
    }
};
exports.JsonCreateEdgeOperationHandler = JsonCreateEdgeOperationHandler;
exports.JsonCreateEdgeOperationHandler = JsonCreateEdgeOperationHandler = __decorate([
    (0, inversify_1.injectable)()
], JsonCreateEdgeOperationHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-action-handler.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-action-handler.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var OperationActionHandler_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationActionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const command_stack_1 = __webpack_require__(/*! ../command/command-stack */ "../../node_modules/@eclipse-glsp/server/lib/common/command/command-stack.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const model_state_1 = __webpack_require__(/*! ../features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const model_submission_handler_1 = __webpack_require__(/*! ../features/model/model-submission-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-submission-handler.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const operation_handler_registry_1 = __webpack_require__(/*! ./operation-handler-registry */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js");
let OperationActionHandler = OperationActionHandler_1 = class OperationActionHandler {
    constructor(actionKinds) {
        this.actionKinds = actionKinds;
    }
    execute(action) {
        if (!this.handles(action)) {
            throw new glsp_server_error_1.GLSPServerError(`Unhandled operation kind: ${action.kind}`);
        }
        if (this.modelState.isReadonly) {
            return [
                protocol_1.MessageAction.create(`Server is in readonly-mode! Could not execute operation: ${action.kind}`, {
                    severity: 'WARNING'
                })
            ];
        }
        return this.executeOperation(action);
    }
    executeOperation(operation) {
        const operationHandler = OperationActionHandler_1.getOperationHandler(operation, this.operationHandlerRegistry);
        if (operationHandler) {
            return this.executeHandler(operation, operationHandler);
        }
        return [];
    }
    async executeHandler(operation, handler) {
        const command = await handler.execute(operation);
        if (command) {
            await this.executeCommand(command);
        }
        return this.modelSubmissionHandler.submitModel('operation');
    }
    async executeCommand(command) {
        return this.commandStack.execute(command);
    }
    submitModel() {
        return this.modelSubmissionHandler.submitModel('operation');
    }
    handles(action) {
        return this.actionKinds.includes(action.kind);
    }
    /**
     *  @Deprecated Use {@link OperationHandlerRegistry#getOperationHandler(Operation) instead}.
     */
    static getOperationHandler(operation, registry) {
        return registry.getOperationHandler(operation);
    }
};
exports.OperationActionHandler = OperationActionHandler;
__decorate([
    (0, inversify_1.inject)(operation_handler_registry_1.OperationHandlerRegistry),
    __metadata("design:type", operation_handler_registry_1.OperationHandlerRegistry)
], OperationActionHandler.prototype, "operationHandlerRegistry", void 0);
__decorate([
    (0, inversify_1.inject)(model_submission_handler_1.ModelSubmissionHandler),
    __metadata("design:type", model_submission_handler_1.ModelSubmissionHandler)
], OperationActionHandler.prototype, "modelSubmissionHandler", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], OperationActionHandler.prototype, "modelState", void 0);
__decorate([
    (0, inversify_1.inject)(command_stack_1.CommandStack),
    __metadata("design:type", Object)
], OperationActionHandler.prototype, "commandStack", void 0);
exports.OperationActionHandler = OperationActionHandler = OperationActionHandler_1 = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(service_identifiers_1.Operations)),
    __metadata("design:paramtypes", [Array])
], OperationActionHandler);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler-registry.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationHandlerRegistryInitializer = exports.OperationHandlerRegistry = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js");
const create_operation_handler_1 = __webpack_require__(/*! ./create-operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/create-operation-handler.js");
const operation_handler_1 = __webpack_require__(/*! ./operation-handler */ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js");
let OperationHandlerRegistry = class OperationHandlerRegistry extends registry_1.Registry {
    registerHandler(handler) {
        if (create_operation_handler_1.CreateOperationHandler.is(handler)) {
            handler.elementTypeIds.forEach(typeId => this.register(`${handler.operationType}_${typeId}`, handler));
            return true;
        }
        else {
            return this.register(handler.operationType, handler);
        }
    }
    getOperationHandler(operation) {
        return protocol_1.CreateOperation.is(operation) ? this.get(`${operation.kind}_${operation.elementTypeId}`) : this.get(operation.kind);
    }
};
exports.OperationHandlerRegistry = OperationHandlerRegistry;
exports.OperationHandlerRegistry = OperationHandlerRegistry = __decorate([
    (0, inversify_1.injectable)()
], OperationHandlerRegistry);
let OperationHandlerRegistryInitializer = class OperationHandlerRegistryInitializer {
    constructor() {
        this.handlerConstructors = [];
    }
    initialize(_args) {
        const handlers = this.handlerConstructors.map(constructor => this.factory(constructor));
        handlers.forEach(handler => this.registry.registerHandler(handler));
    }
};
exports.OperationHandlerRegistryInitializer = OperationHandlerRegistryInitializer;
__decorate([
    (0, inversify_1.inject)(operation_handler_1.OperationHandlerFactory),
    __metadata("design:type", Function)
], OperationHandlerRegistryInitializer.prototype, "factory", void 0);
__decorate([
    (0, inversify_1.inject)(operation_handler_1.OperationHandlerConstructor),
    (0, inversify_1.optional)(),
    __metadata("design:type", Array)
], OperationHandlerRegistryInitializer.prototype, "handlerConstructors", void 0);
__decorate([
    (0, inversify_1.inject)(OperationHandlerRegistry),
    __metadata("design:type", OperationHandlerRegistry)
], OperationHandlerRegistryInitializer.prototype, "registry", void 0);
exports.OperationHandlerRegistryInitializer = OperationHandlerRegistryInitializer = __decorate([
    (0, inversify_1.injectable)()
], OperationHandlerRegistryInitializer);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/operations/operation-handler.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationHandlerFactory = exports.OperationHandlerConstructor = exports.OperationHandler = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const model_state_1 = __webpack_require__(/*! ../features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
/**
 * An operation handler can execute {@link Operation}s of a certain type (subclass).
 * The operation handler processes the operation in the {@link OperationHandler.execute()} method. The result
 * of the execution is a {@link Command} that captures the corresponding source model changes.
 * This command can be applied on the `CommandStack` and is reversible (undo) and can be reapplied (redo).
 *
 * The `OperationActionHandler` is responsible for retrieving all available (valid) operation handlers for an
 * operation that is dispatched via `ActionDispatcher`.
 */
let OperationHandler = class OperationHandler {
    /**
     * Executes the operation handler for the given {@link Operation} and returns the corresponding {@link Command}.
     * If the given operation cannot be handled by this handler or the handler execution did not result in any changes
     * `undefined` is returned.
     *
     * @param operation The operation that should be executed or empty if nothing should be done.
     * @returns The command capturing the execution changes or `undefined`
     */
    execute(operation) {
        return this.handles(operation) ? this.createCommand(operation) : undefined;
    }
    /**
     * Validates whether the given {@link Operation} can be handled by this operation handler.
     *
     * @param operation The operation that should be validated.
     * @returns `true` if the given operation can be handled, `false` otherwise.
     */
    handles(operation) {
        return this.modelState.root && operation.kind === this.operationType;
    }
};
exports.OperationHandler = OperationHandler;
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], OperationHandler.prototype, "modelState", void 0);
exports.OperationHandler = OperationHandler = __decorate([
    (0, inversify_1.injectable)()
], OperationHandler);
exports.OperationHandlerConstructor = Symbol('OperationHandlerConstructor');
exports.OperationHandlerFactory = Symbol('OperationHandlerFactory');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/client-action.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/protocol/client-action.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientAction = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
var ClientAction;
(function (ClientAction) {
    function is(object) {
        return protocol_1.Action.is(object) && '__receivedFromClient' in object && object.__receivedFromClient === true;
    }
    ClientAction.is = is;
    /**
     * Mark the given action as {@link ClientAction} by attaching the "__receivedFromClient" property
     * @param action The action that should be marked as client action
     */
    function mark(action) {
        action.__receivedFromClient = true;
    }
    ClientAction.mark = mark;
})(ClientAction || (exports.ClientAction = ClientAction = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/glsp-server.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/protocol/glsp-server.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DefaultGLSPServer_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGLSPServer = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const global_action_provider_1 = __webpack_require__(/*! ../actions/global-action-provider */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/global-action-provider.js");
const client_session_manager_1 = __webpack_require__(/*! ../session/client-session-manager */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-manager.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const logger_1 = __webpack_require__(/*! ../utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const client_action_1 = __webpack_require__(/*! ./client-action */ "../../node_modules/@eclipse-glsp/server/lib/common/protocol/client-action.js");
let DefaultGLSPServer = DefaultGLSPServer_1 = class DefaultGLSPServer {
    constructor(serverListeners = []) {
        this.serverListeners = [];
        this.clientSessions = new Map();
        serverListeners.forEach(listener => this.addListener(listener));
    }
    validateProtocolVersion(params) {
        if (params.protocolVersion !== DefaultGLSPServer_1.PROTOCOL_VERSION) {
            throw new Error(
            // eslint-disable-next-line max-len
            `Protocol version mismatch! The client protocol version ${params.protocolVersion} is not compatible with the server protocol version ${DefaultGLSPServer_1.PROTOCOL_VERSION}!`);
        }
    }
    validateServerInitialized() {
        if (!this.isInitialized()) {
            throw new Error('This GLSP server has not been initialized.');
        }
    }
    async initialize(params) {
        this.logger.info(`Initializing server with: applicationId: ${params.applicationId}, protocolVersion: ${params.protocolVersion}`);
        this.validateProtocolVersion(params);
        if (this.isInitialized()) {
            if (params.applicationId !== this.applicationId) {
                throw new Error(`Could not initialize GLSP server for application ${params.applicationId}. 
                    Server has already been initialized for different application with id ${this.applicationId}`);
            }
            if (this.initializeResult) {
                return this.initializeResult;
            }
        }
        this.applicationId = params.applicationId;
        const serverActions = {};
        this.actionProvider.actionKinds.forEach((kinds, diagramType) => (serverActions[diagramType] = kinds));
        let result = { protocolVersion: DefaultGLSPServer_1.PROTOCOL_VERSION, serverActions };
        result = await this.handleInitializeArgs(result, params.args);
        this.getListenersToNotify('serverInitialized').forEach((listener) => listener.serverInitialized(this));
        this.initializeResult = result;
        return result;
    }
    handleInitializeArgs(result, args) {
        return result;
    }
    async initializeClientSession(params) {
        this.logger.info(`Initializing client session with: clientSessionId: '${params.clientSessionId}', diagramType: '${params.diagramType}'`);
        this.validateServerInitialized();
        const session = this.sessionManager.getOrCreateClientSession(params);
        this.clientSessions.set(params.clientSessionId, session);
        return this.handleInitializeClientSessionArgs(params.args);
    }
    handleInitializeClientSessionArgs(args) {
        return;
    }
    async disposeClientSession(params) {
        this.logger.debug('Dispose client session with:', params);
        this.validateServerInitialized();
        if (this.sessionManager.disposeClientSession(params.clientSessionId)) {
            this.clientSessions.delete(params.clientSessionId);
            return this.handleDisposeClientSessionArgs(params.args);
        }
        return;
    }
    async handleDisposeClientSessionArgs(args) {
        return;
    }
    process(message) {
        this.validateServerInitialized();
        this.logger.info(`process [action=${message.action.kind}, clientId=${message.clientId}]`);
        const clientSessionId = message.clientId;
        const clientSession = this.clientSessions.get(clientSessionId);
        if (!clientSession) {
            throw new Error(`No client session has been initialized for client id: ${clientSessionId}`);
        }
        const action = message.action;
        client_action_1.ClientAction.mark(action);
        clientSession.actionDispatcher.dispatch(action).catch(error => this.handleProcessError(message, error));
    }
    handleProcessError(message, reason) {
        var _a, _b, _c;
        let errorMsg = `Could not process action: '${message.action.kind}`;
        this.logger.error(errorMsg);
        this.logger.error(reason);
        let details = (_a = reason === null || reason === void 0 ? void 0 : reason.toString) === null || _a === void 0 ? void 0 : _a.call(reason);
        if (reason instanceof glsp_server_error_1.GLSPServerError) {
            details = (_c = (_b = reason.cause) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b);
            errorMsg = reason.message;
        }
        const errorAction = protocol_1.MessageAction.create(errorMsg, { severity: 'ERROR', details });
        this.sendToClient({ clientId: message.clientId, action: errorAction });
    }
    sendToClient(message) {
        this.glspClientProxy.process(message);
    }
    getClientSession(sessionId) {
        return this.clientSessions.get(sessionId);
    }
    shutdown() {
        this.logger.info('Shutdown GLSP Server');
        this.getListenersToNotify('serverShutDown').forEach(listener => listener.serverShutDown(this));
        this.clientSessions.clear();
        this.initializeResult = undefined;
    }
    isInitialized() {
        return this.initializeResult !== undefined;
    }
    addListener(listener) {
        (0, protocol_1.distinctAdd)(this.serverListeners, listener);
        return true;
    }
    removeListener(listener) {
        (0, protocol_1.remove)(this.serverListeners, listener);
        return true;
    }
    getListenersToNotify(method) {
        return this.serverListeners.filter(listener => listener[method]);
    }
};
exports.DefaultGLSPServer = DefaultGLSPServer;
DefaultGLSPServer.PROTOCOL_VERSION = '1.0.0';
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], DefaultGLSPServer.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(client_session_manager_1.ClientSessionManager),
    __metadata("design:type", Object)
], DefaultGLSPServer.prototype, "sessionManager", void 0);
__decorate([
    (0, inversify_1.inject)(global_action_provider_1.GlobalActionProvider),
    __metadata("design:type", Object)
], DefaultGLSPServer.prototype, "actionProvider", void 0);
__decorate([
    (0, inversify_1.inject)(protocol_1.GLSPClientProxy),
    __metadata("design:type", Object)
], DefaultGLSPServer.prototype, "glspClientProxy", void 0);
exports.DefaultGLSPServer = DefaultGLSPServer = DefaultGLSPServer_1 = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(protocol_1.GLSPServerListener)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], DefaultGLSPServer);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/reexport.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/reexport.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js"), exports);
__exportStar(__webpack_require__(/*! @eclipse-glsp/protocol/lib/di */ "../../node_modules/@eclipse-glsp/protocol/lib/di/index.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-factory.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-factory.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultClientSessionFactory = exports.ClientSessionFactory = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const action_dispatcher_1 = __webpack_require__(/*! ../actions/action-dispatcher */ "../../node_modules/@eclipse-glsp/server/lib/common/actions/action-dispatcher.js");
const client_session_module_1 = __webpack_require__(/*! ../di/client-session-module */ "../../node_modules/@eclipse-glsp/server/lib/common/di/client-session-module.js");
const service_identifiers_1 = __webpack_require__(/*! ../di/service-identifiers */ "../../node_modules/@eclipse-glsp/server/lib/common/di/service-identifiers.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const client_session_1 = __webpack_require__(/*! ./client-session */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session.js");
const client_session_initializer_1 = __webpack_require__(/*! ./client-session-initializer */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js");
exports.ClientSessionFactory = Symbol('ClientSessionFactory');
let DefaultClientSessionFactory = class DefaultClientSessionFactory {
    create(params) {
        const { clientSessionId: clientId, diagramType, clientActionKinds, args } = params;
        const diagramModules = this.diagramModules.get(diagramType);
        if (!diagramModules || diagramModules.length === 0) {
            throw new glsp_server_error_1.GLSPServerError(`Could not retrieve diagram module configuration for diagram type: '${diagramType}''`);
        }
        const sessionModule = (0, client_session_module_1.createClientSessionModule)({ clientId, glspClient: this.glspClient, clientActionKinds });
        const sessionContainer = this.serverContainer.createChild();
        sessionContainer.load(...diagramModules, sessionModule);
        const initializers = sessionContainer.getAll(client_session_initializer_1.ClientSessionInitializer);
        initializers.forEach(service => service.initialize(args));
        const actionDispatcher = sessionContainer.get(action_dispatcher_1.ActionDispatcher);
        return new client_session_1.DefaultClientSession(clientId, diagramType, actionDispatcher, sessionContainer);
    }
};
exports.DefaultClientSessionFactory = DefaultClientSessionFactory;
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.InjectionContainer),
    __metadata("design:type", inversify_1.Container)
], DefaultClientSessionFactory.prototype, "serverContainer", void 0);
__decorate([
    (0, inversify_1.inject)(service_identifiers_1.DiagramModules),
    __metadata("design:type", Map)
], DefaultClientSessionFactory.prototype, "diagramModules", void 0);
__decorate([
    (0, inversify_1.inject)(protocol_1.GLSPClientProxy),
    __metadata("design:type", Object)
], DefaultClientSessionFactory.prototype, "glspClient", void 0);
exports.DefaultClientSessionFactory = DefaultClientSessionFactory = __decorate([
    (0, inversify_1.injectable)()
], DefaultClientSessionFactory);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-initializer.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSessionInitializer = void 0;
exports.ClientSessionInitializer = Symbol('ClientSessionInitializer');


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-listener.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-listener.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-manager.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-manager.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultClientSessionManager = exports.ClientSessionManager = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const glsp_server_error_1 = __webpack_require__(/*! ../utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
const client_session_factory_1 = __webpack_require__(/*! ./client-session-factory */ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session-factory.js");
exports.ClientSessionManager = Symbol('ClientSessionManager');
const ALL_CLIENT_IDS_KEY = '*';
let DefaultClientSessionManager = class DefaultClientSessionManager {
    constructor() {
        this.clientSessions = new Map();
        this.listeners = new Map();
    }
    getListenersToNotify(clientSession, method) {
        var _a, _b, _c, _d;
        const globalListeners = (_b = (_a = this.listeners.get(ALL_CLIENT_IDS_KEY)) === null || _a === void 0 ? void 0 : _a.filter(listener => listener[method])) !== null && _b !== void 0 ? _b : [];
        const sessionListeners = (_d = (_c = this.listeners.get(clientSession.id)) === null || _c === void 0 ? void 0 : _c.filter(listener => listener[method])) !== null && _d !== void 0 ? _d : [];
        return [...globalListeners, ...sessionListeners];
    }
    getOrCreateClientSession(params) {
        const { clientSessionId, diagramType } = params;
        const session = this.clientSessions.get(clientSessionId);
        if (session) {
            if (session.diagramType !== diagramType) {
                throw new glsp_server_error_1.GLSPServerError(`Could not initialize new session for diagram type '${diagramType}'
                Another session with the same id for the diagram type ${session.diagramType} already exists`);
            }
            return session;
        }
        const newSession = this.sessionFactory.create(params);
        this.clientSessions.set(clientSessionId, newSession);
        this.getListenersToNotify(newSession, 'sessionCreated').forEach(listener => listener.sessionCreated(newSession));
        return newSession;
    }
    getSession(clientSessionId) {
        return this.clientSessions.get(clientSessionId);
    }
    getSessionsByType(diagramType) {
        return Array.from(this.clientSessions.values()).filter(session => session.diagramType === diagramType);
    }
    disposeClientSession(clientSessionId) {
        const session = this.clientSessions.get(clientSessionId);
        if (session) {
            session.dispose();
            this.getListenersToNotify(session, 'sessionDisposed').forEach(listener => listener.sessionDisposed(session));
            this.clientSessions.delete(clientSessionId);
            this.listeners.delete(clientSessionId);
            return true;
        }
        return false;
    }
    addListener(listener, ...clientSessionIds) {
        if (clientSessionIds.length === 0) {
            this.addSingleListener(ALL_CLIENT_IDS_KEY, listener);
        }
        return clientSessionIds.map(clientId => this.addSingleListener(clientId, listener)).every(added => added);
    }
    addSingleListener(clientSessionId, listener) {
        var _a;
        const listeners = (_a = this.listeners.get(clientSessionId)) !== null && _a !== void 0 ? _a : [];
        listeners.push(listener);
        this.listeners.set(clientSessionId, listeners);
        return true;
    }
    removeListener(listener) {
        return Array.from(this.listeners.values())
            .map(listeners => (0, protocol_1.remove)(listeners, listener))
            .every(removed => removed);
    }
    removeListeners(...clientSessionIds) {
        if (clientSessionIds.length === 0) {
            this.listeners.clear();
        }
        else {
            clientSessionIds.forEach(id => this.listeners.delete(id));
        }
    }
    serverShutDown(server) {
        Array.from(this.clientSessions.keys()).forEach(id => this.disposeClientSession(id));
        this.listeners.clear();
    }
};
exports.DefaultClientSessionManager = DefaultClientSessionManager;
__decorate([
    (0, inversify_1.inject)(client_session_factory_1.ClientSessionFactory),
    __metadata("design:type", Object)
], DefaultClientSessionManager.prototype, "sessionFactory", void 0);
exports.DefaultClientSessionManager = DefaultClientSessionManager = __decorate([
    (0, inversify_1.injectable)()
], DefaultClientSessionManager);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/session/client-session.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/session/client-session.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultClientSession = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
class DefaultClientSession {
    constructor(id, diagramType, actionDispatcher, container) {
        this.id = id;
        this.diagramType = diagramType;
        this.actionDispatcher = actionDispatcher;
        this.container = container;
    }
    dispose() {
        if (protocol_1.Disposable.is(this.actionDispatcher)) {
            this.actionDispatcher.dispose();
        }
    }
}
exports.DefaultClientSession = DefaultClientSession;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/args-util.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/args-util.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArgsUtil = void 0;
var ArgsUtil;
(function (ArgsUtil) {
    ArgsUtil.KEY_EDGE_PADDING = 'edgePadding';
    ArgsUtil.KEY_EDGE_SOURCE_POINT_X = 'edgeSourcePointX';
    ArgsUtil.KEY_EDGE_SOURCE_POINT_Y = 'edgeSourcePointY';
    ArgsUtil.KEY_EDGE_TARGET_POINT_X = 'edgeTargetPointX';
    ArgsUtil.KEY_EDGE_TARGET_POINT_Y = 'edgeTargetPointY';
    ArgsUtil.KEY_RADIUS_TOP_LEFT = 'radiusTopLeft';
    ArgsUtil.KEY_RADIUS_TOP_RIGHT = 'radiusTopRight';
    ArgsUtil.KEY_RADIUS_BOTTOM_RIGHT = 'radiusBottomRight';
    ArgsUtil.KEY_RADIUS_BOTTOM_LEFT = 'radiusBottomLeft';
    function cornerRadius(radiusOrTopLeft, topRightOpt, bottomRightOpt, bottomLeftOpt) {
        const topLeft = radiusOrTopLeft;
        let topRight = radiusOrTopLeft;
        let bottomLeft = radiusOrTopLeft;
        let bottomRight = radiusOrTopLeft;
        if (topRightOpt) {
            topRight = topRightOpt;
            if (bottomRightOpt && bottomLeftOpt) {
                bottomLeft = bottomLeftOpt;
                bottomRight = bottomRightOpt;
            }
            else {
                bottomRight = radiusOrTopLeft;
                bottomLeft = topRight;
            }
        }
        return {
            [ArgsUtil.KEY_RADIUS_TOP_LEFT]: topLeft,
            [ArgsUtil.KEY_RADIUS_BOTTOM_LEFT]: bottomLeft,
            [ArgsUtil.KEY_RADIUS_BOTTOM_RIGHT]: bottomRight,
            [ArgsUtil.KEY_RADIUS_TOP_RIGHT]: topRight
        };
    }
    ArgsUtil.cornerRadius = cornerRadius;
    function edgePadding(edgePadding) {
        return { [ArgsUtil.KEY_EDGE_PADDING]: edgePadding };
    }
    ArgsUtil.edgePadding = edgePadding;
    function getEdgePadding(args) {
        return getNumber(args, ArgsUtil.KEY_EDGE_PADDING);
    }
    ArgsUtil.getEdgePadding = getEdgePadding;
    function getEdgeSourcePoint(args = {}) {
        const x = getNumber(args, ArgsUtil.KEY_EDGE_SOURCE_POINT_X);
        const y = getNumber(args, ArgsUtil.KEY_EDGE_SOURCE_POINT_Y);
        if (x && y) {
            return { x, y };
        }
        return undefined;
    }
    ArgsUtil.getEdgeSourcePoint = getEdgeSourcePoint;
    function getEdgeTargetPoint(args = {}) {
        const x = getNumber(args, ArgsUtil.KEY_EDGE_TARGET_POINT_X);
        const y = getNumber(args, ArgsUtil.KEY_EDGE_TARGET_POINT_Y);
        if (x && y) {
            return { x, y };
        }
        return undefined;
    }
    ArgsUtil.getEdgeTargetPoint = getEdgeTargetPoint;
    function get(args = {}, key) {
        const value = args[key];
        return value && typeof value === 'string' ? value : undefined;
    }
    ArgsUtil.get = get;
    function getNumber(args = {}, key) {
        const value = args[key];
        return value && typeof value === 'number' ? value : undefined;
    }
    ArgsUtil.getNumber = getNumber;
    function getBoolean(args = {}, key) {
        const value = args[key];
        return value && typeof value === 'boolean' ? value : false;
    }
    ArgsUtil.getBoolean = getBoolean;
})(ArgsUtil || (exports.ArgsUtil = ArgsUtil = {}));


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/client-options-util.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/client-options-util.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientOptionsUtil = void 0;
const args_util_1 = __webpack_require__(/*! ./args-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/args-util.js");
class ClientOptionsUtil {
    static adaptUri(uri) {
        return uri.replace(this.FILE_PREFIX, '');
    }
    static isReconnecting(options) {
        return args_util_1.ArgsUtil.getBoolean(options, ClientOptionsUtil.IS_RECONNECTING);
    }
}
exports.ClientOptionsUtil = ClientOptionsUtil;
ClientOptionsUtil.FILE_PREFIX = 'file://';
ClientOptionsUtil.IS_RECONNECTING = 'isReconnecting';


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/console-logger.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/console-logger.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureConsoleLogger = exports.ConsoleLogger = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ./logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
/**
 *  Simple logger implementation that forwards logging calls to the `console` and
 *  can be used in both the browser and node context.
 */
let ConsoleLogger = class ConsoleLogger extends logger_1.Logger {
    constructor(logLevel = logger_1.LogLevel.none, caller) {
        super();
        this.logLevel = logLevel;
        this.caller = caller;
    }
    info(message, ...params) {
        if (logger_1.LogLevel.info <= this.logLevel) {
            console.info(this.logMessage(message, params));
        }
    }
    warn(message, ...params) {
        if (logger_1.LogLevel.warn <= this.logLevel) {
            console.warn(this.logMessage(message, params));
        }
    }
    error(message, ...params) {
        if (logger_1.LogLevel.error <= this.logLevel) {
            console.error(this.logMessage(message, params));
        }
    }
    debug(message, ...params) {
        if (logger_1.LogLevel.debug <= this.logLevel) {
            console.debug(this.logMessage(message, params));
        }
    }
    logMessage(message, ...params) {
        const timestamp = new Date().toLocaleTimeString();
        const caller = this.caller ? `[${this.caller}]` : '';
        const additional = this.logAdditionals(...params);
        return `${timestamp} ${this.logLevel} - ${caller} ${message} ${additional}`;
    }
    logAdditionals(...params) {
        if (!params || params.length === 0) {
            return '';
        }
        return params.map(param => this.stringify(param)).join(',\n');
    }
    stringify(param) {
        if (param instanceof Error) {
            return `${param.message}
            ${param.stack || ''}`;
        }
        return JSON.stringify(param, undefined, 4);
    }
};
exports.ConsoleLogger = ConsoleLogger;
exports.ConsoleLogger = ConsoleLogger = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [Number, String])
], ConsoleLogger);
function configureConsoleLogger(context, options) {
    if (!options.consoleLog) {
        context.bind(logger_1.Logger).to(logger_1.NullLogger).inSingletonScope();
    }
    else {
        context.bind(logger_1.Logger).toDynamicValue(ctx => new ConsoleLogger(options.logLevel, (0, logger_1.getRequestParentName)(ctx)));
    }
    context.bind(logger_1.LoggerFactory).toFactory(dynamicContext => (caller) => {
        const logger = dynamicContext.container.get(logger_1.Logger);
        logger.caller = caller;
        return logger;
    });
}
exports.configureConsoleLogger = configureConsoleLogger;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOrThrow = exports.GLSPServerError = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
class GLSPServerError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
    }
}
exports.GLSPServerError = GLSPServerError;
function getOrThrow(optional, errorMsg) {
    if (optional !== undefined) {
        return optional;
    }
    throw new GLSPServerError(errorMsg);
}
exports.getOrThrow = getOrThrow;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/layout-util.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.absoluteToRelative = exports.getRelativeLocation = exports.applyRoutingPoints = exports.getRoute = exports.applyRoute = exports.applyAlignment = exports.applyElementAndBounds = void 0;
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const args_util_1 = __webpack_require__(/*! ./args-util */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/args-util.js");
const glsp_server_error_1 = __webpack_require__(/*! ./glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
/**
 * Applies the new bounds to the model.
 *
 * @param bounds The new bounds.
 * @param index  The model index.
 * @returns The changed element.
 */
function applyElementAndBounds(bounds, index) {
    const element = (0, glsp_server_error_1.getOrThrow)(index.get(bounds.elementId), 'Model element not found! ID: ' + bounds.elementId);
    if ((0, graph_1.isGBoundsAware)(element)) {
        if (bounds.newPosition !== undefined) {
            element.position = bounds.newPosition;
        }
        element.size = bounds.newSize;
        return element;
    }
    return undefined;
}
exports.applyElementAndBounds = applyElementAndBounds;
/**
 * Applies the new alignment to the model.
 *
 * @param alignment The new alignment.
 * @param index     The model index.
 * @returns The changed element.
 */
function applyAlignment(alignment, index) {
    const element = (0, glsp_server_error_1.getOrThrow)(index.get(alignment.elementId), 'Model element not found! ID: ' + alignment.elementId);
    if ((0, graph_1.isGAlignable)(element)) {
        element.alignment = alignment.newAlignment;
        return element;
    }
    return undefined;
}
exports.applyAlignment = applyAlignment;
/**
 * Applies the new route to the model.
 *
 * @param route The new route.
 * @param index The model index.
 * @returns The changed element.
 */
function applyRoute(route, index) {
    var _a, _b;
    const routingPoints = (_a = route.newRoutingPoints) !== null && _a !== void 0 ? _a : [];
    if (routingPoints.length < 2) {
        throw new glsp_server_error_1.GLSPServerError('Invalid Route!');
    }
    // first and last point mark the source and target point
    const edge = applyRoutingPoints(route, index);
    const edgeRoutingPoints = edge.routingPoints;
    const args = (_b = edge.args) !== null && _b !== void 0 ? _b : {};
    const source = edgeRoutingPoints.shift();
    const target = edgeRoutingPoints.pop();
    args[args_util_1.ArgsUtil.KEY_EDGE_SOURCE_POINT_X] = source.x;
    args[args_util_1.ArgsUtil.KEY_EDGE_SOURCE_POINT_Y] = source.y;
    args[args_util_1.ArgsUtil.KEY_EDGE_TARGET_POINT_X] = target.x;
    args[args_util_1.ArgsUtil.KEY_EDGE_TARGET_POINT_Y] = target.y;
    return edge;
}
exports.applyRoute = applyRoute;
/**
 * Returns the complete route of the given edge. The route, as opposed to the routing points, also contain the source
 * and target point.
 *
 * @param edge The edge from which we get the route
 * @returns complete edge route
 */
function getRoute(edge) {
    const sourcePoint = args_util_1.ArgsUtil.getEdgeSourcePoint(edge.args);
    if (!sourcePoint) {
        throw new glsp_server_error_1.GLSPServerError('Cannot get route without source point!');
    }
    const targetPoint = args_util_1.ArgsUtil.getEdgeTargetPoint(edge.args);
    if (!targetPoint) {
        throw new glsp_server_error_1.GLSPServerError('Cannot get route without target point!');
    }
    const route = [];
    route.push(sourcePoint);
    route.push(...edge.routingPoints);
    route.push(targetPoint);
    return { elementId: edge.id, newRoutingPoints: route };
}
exports.getRoute = getRoute;
function applyRoutingPoints(routingPoints, index) {
    var _a;
    const edge = (0, glsp_server_error_1.getOrThrow)(index.findByClass(routingPoints.elementId, graph_1.GEdge), 'Model element not found! ID: ' + routingPoints.elementId);
    edge.routingPoints = (_a = routingPoints.newRoutingPoints) !== null && _a !== void 0 ? _a : [];
    return edge;
}
exports.applyRoutingPoints = applyRoutingPoints;
/**
 * Returns the relative location of the given absolute location within the container.
 *
 * @param absoluteLocation absolute location
 * @param container        container
 * @return relative location if it can be determined, absolute location in case of error and null if the container
 *         cannot contain any location.
 */
function getRelativeLocation(absoluteLocation, container) {
    const allowNegativeCoordinates = container instanceof graph_1.GGraph;
    if ((0, graph_1.isGBoundsAware)(container)) {
        const relativePosition = absoluteToRelative(absoluteLocation, container);
        const relativeLocation = allowNegativeCoordinates
            ? relativePosition
            : { x: Math.max(0, relativePosition.x), y: Math.max(0, relativePosition.y) };
        return relativeLocation;
    }
    return undefined;
}
exports.getRelativeLocation = getRelativeLocation;
/**
 * Convert a point in absolute coordinates to a point relative to the specified GBoundsAware.
 * Note: this method only works if the specified {@link GBoundsAware} is part of a
 * hierarchy of {@link GBoundsAware}. If any of its parents (recursively) does not implement
 * {@link GBoundsAware}, this method will throw an exception.
 *
 * @param absolutePoint
 * @param modelElement
 * @returns
 *         A new point, relative to the coordinates space of the specified {@link GBoundsAware}
 * @throws Error if the modelElement is not part of a {@link GBoundsAware} hierarchy
 */
function absoluteToRelative(absolutePoint, modelElement) {
    var _a, _b, _c, _d;
    let parentElement;
    if (!(modelElement instanceof graph_1.GModelRoot)) {
        parentElement = modelElement.parent;
    }
    let relativeToParent;
    if (!parentElement) {
        relativeToParent = { x: absolutePoint.x, y: absolutePoint.y };
    }
    else {
        if (!(0, graph_1.isGBoundsAware)(parentElement)) {
            throw new Error(`The element is not part of a GBoundsAware hierarchy: ${modelElement}`);
        }
        relativeToParent = absoluteToRelative(absolutePoint, parentElement);
    }
    const x = (_b = (_a = modelElement.position) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
    const y = (_d = (_c = modelElement.position) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
    return { x: relativeToParent.x - x, y: relativeToParent.y - y };
}
exports.absoluteToRelative = absoluteToRelative;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRequestParentName = exports.asLogLevel = exports.LogLevel = exports.LoggerFactory = exports.NullLogger = exports.Logger = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
let Logger = class Logger {
};
exports.Logger = Logger;
exports.Logger = Logger = __decorate([
    (0, inversify_1.injectable)()
], Logger);
class NullLogger extends Logger {
    info(message, ...params) {
        // no-op
    }
    warn(message, ...params) {
        // no-op
    }
    error(message, ...params) {
        // no-op
    }
    debug(message, ...params) {
        // no-op
    }
}
exports.NullLogger = NullLogger;
exports.LoggerFactory = Symbol('LoggerFactory');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["none"] = 0] = "none";
    LogLevel[LogLevel["error"] = 1] = "error";
    LogLevel[LogLevel["warn"] = 2] = "warn";
    LogLevel[LogLevel["info"] = 3] = "info";
    LogLevel[LogLevel["debug"] = 4] = "debug";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
function asLogLevel(level) {
    let levelKey = level;
    if (typeof levelKey === 'string') {
        levelKey = levelKey.toLowerCase();
    }
    if (levelKey in LogLevel) {
        return LogLevel[level];
    }
    return undefined;
}
exports.asLogLevel = asLogLevel;
function getRequestParentName(context) {
    var _a;
    if (context.currentRequest.parentRequest) {
        const bindings = context.currentRequest.parentRequest.bindings;
        if (bindings.length > 0) {
            const binding = bindings[0];
            return (_a = binding.implementationType) === null || _a === void 0 ? void 0 : _a.name;
        }
    }
    return undefined;
}
exports.getRequestParentName = getRequestParentName;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/promise-queue.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/promise-queue.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiseQueue = void 0;
/**
 * A data structure that enables controlled,sequential resolving
 * of promises. Promises that are put in this queue are processed one by one.
 * i.e. After the first promise in the queue is resolved, it will be removed from the queue and the resolving of the
 * the next promise (if present) will start. The queue can only resolve one promise at a given time.
 */
class PromiseQueue {
    constructor() {
        this.queue = [];
        this.busy = false;
    }
    /**
     * Add a {@link PromiseQueueElement} to the queue
     * @param promise The element that should be queued
     * @param atStart if `true` the element is added to the start of queue, otherwise it's added at queue end.
     * @returns A promise of the queued promise that resolves once dequeued.
     */
    enqueue(promise) {
        return new Promise((resolve, reject) => {
            const element = {
                promise,
                resolve,
                reject
            };
            this.queue.push(element);
            this.dequeue();
        });
    }
    dequeue() {
        if (this.busy) {
            return false;
        }
        const element = this.queue.shift();
        if (!element) {
            return false;
        }
        this.busy = true;
        this.resolveQueuedPromise(element).catch(error => {
            element.reject(error);
            this.busy = false;
            this.dequeue();
        });
        return true;
    }
    async resolveQueuedPromise(element) {
        try {
            const value = await element.promise();
            return element.resolve(value);
        }
        catch (error) {
            element.reject(error);
        }
        finally {
            this.busy = false;
            this.dequeue();
        }
    }
    get isBusy() {
        return this.busy;
    }
    get size() {
        return this.queue.length;
    }
    get isEmpty() {
        return this.queue.length === 0;
    }
    clear() {
        this.queue = [];
    }
}
exports.PromiseQueue = PromiseQueue;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/common/utils/registry.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiRegistry = exports.Registry = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const array_util_1 = __webpack_require__(/*! @eclipse-glsp/protocol/lib/utils/array-util */ "../../node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const logger_1 = __webpack_require__(/*! ./logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
/**
 * A registry manages a set of key-value pairs and provides query functionality. In GLSP this is typically used to
 * provide a convenience API for working with multi-injected instances e.g. action handlers or
 * operation handlers.
 *
 * @typeParam K Key type
 * @param V Value type
 */
let Registry = class Registry {
    constructor() {
        this.elements = new Map();
    }
    /**
     * Registers a new key-value pair.
     *
     * @param key     The key object.
     * @param element The value object.
     * @returns `true` if the pair was registered successfully, `false` if another pair with the same key is already
     *         registered.
     */
    register(key, value) {
        if (!this.hasKey(key)) {
            this.elements.set(key, value);
            return true;
        }
        this.logger.warn('Could not register key-value pair. Key is already registered', { key, value });
        return false;
    }
    /**
     * Removes the value with the given key from the registry.
     *
     * @param key The key of the value which should be removed.
     * @returns `true` if the value was removed successfully, `false` if no value was registered for the given key.
     */
    deregister(key) {
        return this.elements.delete(key);
    }
    /**
     * Queries the registry to check whether a value for the given key is registered.
     *
     * @param key The key which should be checked.
     * @returns `true` if a key-value pair is registered for the given key, `false` otherwise.
     */
    hasKey(key) {
        return this.elements.has(key);
    }
    /**
     * Retrieve the value for the given key.
     *
     * @param key The key whose value should be retrieved.
     * @returns The registered value or `undefined`. Is `undefined` if no value was registered for the given key.
     */
    get(key) {
        return this.elements.get(key);
    }
    /**
     * Retrieve all registered values from the registry.
     *
     * @returns An array of all registered keys.
     */
    getAll() {
        return [...new Set(this.elements.values())];
    }
    /**
     * Retrieve all registered keys from the registry.
     *
     * @returns An array of all registered keys.
     */
    keys() {
        return [...new Set(this.elements.keys())];
    }
};
exports.Registry = Registry;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], Registry.prototype, "logger", void 0);
exports.Registry = Registry = __decorate([
    (0, inversify_1.injectable)()
], Registry);
/**
 * A multi registry is used to manage a set of key-value pairs. The main difference to {@link Registry} is that
 * a multi registry doesn't enforce a 1-1 relation between key and value(s).
 * One key can be associated with multiple values.
 *
 *
 * @typeParam K  Type of the key
 * @param V Type of the values
 */
let MultiRegistry = class MultiRegistry {
    constructor() {
        this.elements = new Map();
    }
    register(key, instance) {
        const instances = this.elements.get(key);
        if (instances) {
            instances.push(instance);
        }
        else {
            this.elements.set(key, [instance]);
        }
    }
    deregister(key, element) {
        const instances = this.elements.get(key);
        if (instances) {
            (0, array_util_1.remove)(instances, element);
            return true;
        }
        return false;
    }
    deregisterAll(key) {
        return this.elements.delete(key);
    }
    get(key) {
        const existingInstances = this.elements.get(key);
        if (existingInstances) {
            return [...new Set(existingInstances)];
        }
        else {
            return [];
        }
    }
    hasKey(key) {
        return this.elements.has(key);
    }
    getAll() {
        const values = [];
        Array.from(this.elements.values()).forEach(instances => values.push(...instances));
        return [...new Set(values)];
    }
    keys() {
        return [...new Set(this.elements.keys())];
    }
};
exports.MultiRegistry = MultiRegistry;
exports.MultiRegistry = MultiRegistry = __decorate([
    (0, inversify_1.injectable)()
], MultiRegistry);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/abstract-json-model-storage.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/abstract-json-model-storage.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractJsonModelStorage = void 0;
const fs = __webpack_require__(/*! fs */ "fs");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const os = __webpack_require__(/*! os */ "os");
const url_1 = __webpack_require__(/*! url */ "url");
const model_state_1 = __webpack_require__(/*! ../common/features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const glsp_server_error_1 = __webpack_require__(/*! ../common/utils/glsp-server-error */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/glsp-server-error.js");
/**
 * An abstract implementation of {@link SourceModelStorage} that provides utility methods for loading and saving JSON source models
 * from/into a file.
 */
let AbstractJsonModelStorage = class AbstractJsonModelStorage {
    getSourceUri(action) {
        var _a;
        const sourceUri = (_a = action.options) === null || _a === void 0 ? void 0 : _a[model_state_1.SOURCE_URI_ARG];
        if (typeof sourceUri !== 'string') {
            throw new glsp_server_error_1.GLSPServerError(`Invalid RequestModelAction! Missing argument with key '${model_state_1.SOURCE_URI_ARG}'`);
        }
        return sourceUri;
    }
    loadFromFile(sourceUri, guard) {
        try {
            const path = this.toPath(sourceUri);
            let fileContent = this.readFile(path);
            if (!fileContent) {
                fileContent = this.createModelForEmptyFile(path);
                if (!fileContent) {
                    throw new glsp_server_error_1.GLSPServerError(`Could not load the source model. The file '${path}' is empty!.`);
                }
            }
            if (guard && !guard(fileContent)) {
                throw new Error('The loaded root object is not of the expected type!');
            }
            return fileContent;
        }
        catch (error) {
            throw new glsp_server_error_1.GLSPServerError(`Could not load model from file: ${sourceUri}`, error);
        }
    }
    /**
     * Can be overwritten to customize the behavior if the given file path points to an empty file.
     * The default implementation returns undefined, concrete subclasses can customize this behavior and
     * return new source model object instead.
     * @param path The path of the empty file.
     * @returns The new model or `undefined`
     */
    createModelForEmptyFile(path) {
        return undefined;
    }
    readFile(path) {
        try {
            const data = fs.readFileSync(path, { encoding: 'utf8' });
            if (!data || data.length === 0) {
                return undefined;
            }
            return this.toJson(data);
        }
        catch (error) {
            throw new glsp_server_error_1.GLSPServerError(`Could not read & parse file contents of '${path}' as json`, error);
        }
    }
    toJson(fileContent) {
        return JSON.parse(fileContent);
    }
    toPath(sourceUri) {
        let path = sourceUri.startsWith('file://') ? (0, url_1.fileURLToPath)(sourceUri) : sourceUri;
        if (os.platform() === 'win32') {
            // Remove the leading slash if it exists (Windows paths don't have it)
            path = path.replace(/^\//, '');
        }
        return path;
    }
    getFileUri(action) {
        var _a;
        const uri = (_a = action.fileUri) !== null && _a !== void 0 ? _a : this.modelState.get(model_state_1.SOURCE_URI_ARG);
        if (!uri) {
            throw new glsp_server_error_1.GLSPServerError('Could not derive fileUri for saving the current source model');
        }
        return uri;
    }
    writeFile(fileUri, model) {
        const path = this.toPath(fileUri);
        const content = this.toString(model);
        fs.writeFileSync(path, content);
    }
    toString(model) {
        return JSON.stringify(model, undefined, 2);
    }
};
exports.AbstractJsonModelStorage = AbstractJsonModelStorage;
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], AbstractJsonModelStorage.prototype, "modelState", void 0);
exports.AbstractJsonModelStorage = AbstractJsonModelStorage = __decorate([
    (0, inversify_1.injectable)()
], AbstractJsonModelStorage);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/di/app-module.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/di/app-module.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureWinstonLogger = exports.createWinstonInstance = exports.createAppModule = void 0;
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const winston = __webpack_require__(/*! winston */ "../../node_modules/winston/lib/winston.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@eclipse-glsp/server/lib/common/index.js");
const winston_logger_1 = __webpack_require__(/*! ./winston-logger */ "../../node_modules/@eclipse-glsp/server/lib/node/di/winston-logger.js");
function createAppModule(options) {
    return new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
        bind(common_1.InjectionContainer).toDynamicValue(dynamicContext => dynamicContext.container);
        const context = { bind, unbind, isBound, rebind };
        configureWinstonLogger(context, options);
    });
}
exports.createAppModule = createAppModule;
/**
 * Creates the global {@link winston.Logger} instance is used internally by all instances of {@link WinstonLogger}. Can be configured with
 * the given {@link LaunchOptions}.
 * @param options The {@link LaunchOptions}
 * @returns the configured winston instance.
 */
function createWinstonInstance(options) {
    const level = common_1.LogLevel[options.logLevel];
    const transports = [];
    const printf = winston.format.printf(({ level, message, timestamp }) => `${timestamp} ${level} -  ${message}`);
    const timestamp = winston.format.timestamp({ format: () => new Date().toLocaleTimeString() });
    const consoleLogFormat = winston.format.combine(winston.format.colorize(), timestamp, printf);
    const fileLogFormat = winston.format.combine(timestamp, printf);
    if (options.consoleLog) {
        transports.push(new winston.transports.Console({ format: consoleLogFormat }));
    }
    if (options.fileLog) {
        const date = new Date();
        const dateString = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}_${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}`;
        const filename = `GLSP-Server_${dateString}.log`;
        transports.push(new winston.transports.File({ dirname: options.logDir, filename, format: fileLogFormat }));
    }
    return winston.createLogger({ level, transports });
}
exports.createWinstonInstance = createWinstonInstance;
/**
 * Configures the binding for {@link WinstonLogger} in the given {@link ModuleContext} with the given {@link LaunchOptions}.
 * @param context The module context.
 * @param options The launch options.
 * @param rebind Flag to determine wether an existing {@link Logger} binding in the context should be rebound. Default is `true`.
 * @param baseLoggerCreator The underling global {@link winston.Logger} instance.
 */
function configureWinstonLogger(context, options, rebind = true, baseLoggerCreator = createWinstonInstance) {
    const baseLogger = baseLoggerCreator(options);
    if (rebind) {
        if (context.isBound(common_1.Logger)) {
            context.unbind(common_1.Logger);
        }
        if (context.isBound(common_1.LoggerFactory)) {
            context.unbind(common_1.LoggerFactory);
        }
    }
    context.bind(common_1.Logger).toDynamicValue(dynamicContext => new winston_logger_1.WinstonLogger(baseLogger, (0, common_1.getRequestParentName)(dynamicContext)));
    context.bind(common_1.LoggerFactory).toFactory(dynamicContext => (caller) => {
        const logger = dynamicContext.container.get(common_1.Logger);
        logger.caller = caller;
        return logger;
    });
}
exports.configureWinstonLogger = configureWinstonLogger;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/di/winston-logger.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/di/winston-logger.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WinstonLogger = void 0;
const logger_1 = __webpack_require__(/*! ../../common/utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
class WinstonLogger extends logger_1.Logger {
    constructor(baseLogger, caller) {
        super();
        this.baseLogger = baseLogger;
        this.caller = caller;
    }
    info(message, ...params) {
        if (this.logLevel !== logger_1.LogLevel.none) {
            this.baseLogger.info(this.combinedMessage(message, ...params));
        }
    }
    warn(message, ...params) {
        if (this.logLevel !== logger_1.LogLevel.none) {
            this.baseLogger.warn(this.combinedMessage(message, ...params));
        }
    }
    error(message, ...params) {
        if (this.logLevel !== logger_1.LogLevel.none) {
            this.baseLogger.error(this.combinedMessage(message, ...params));
        }
    }
    debug(message, ...params) {
        if (this.logLevel !== logger_1.LogLevel.none) {
            this.baseLogger.debug(this.combinedMessage(message, ...params));
        }
    }
    get logLevel() {
        return (0, logger_1.asLogLevel)(this.baseLogger.level) || logger_1.LogLevel.none;
    }
    set logLevel(level) {
        this.baseLogger.level = logger_1.LogLevel[level];
    }
    combinedMessage(message, ...params) {
        const caller = this.caller ? `[${this.caller}]` : '';
        const additional = this.logAdditionals(...params);
        return `${caller} ${message} ${additional}`;
    }
    logAdditionals(...params) {
        if (!params || params.length === 0) {
            return '';
        }
        return params.map(param => this.toString(param)).join(',\n');
    }
    toString(param) {
        if (param instanceof Error) {
            return `${param.message}
            ${param.stack || ''}`;
        }
        try {
            return JSON.stringify(param, undefined, 4);
        }
        catch (_) {
            return '';
        }
    }
}
exports.WinstonLogger = WinstonLogger;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/gmodel/gmodel-storage.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/gmodel/gmodel-storage.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GModelStorage = exports.EMPTY_ROOT = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const graph_1 = __webpack_require__(/*! @eclipse-glsp/graph */ "../../node_modules/@eclipse-glsp/graph/lib/index.js");
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const gmodel_serializer_1 = __webpack_require__(/*! ../../common/features/model/gmodel-serializer */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/gmodel-serializer.js");
const model_state_1 = __webpack_require__(/*! ../../common/features/model/model-state */ "../../node_modules/@eclipse-glsp/server/lib/common/features/model/model-state.js");
const logger_1 = __webpack_require__(/*! ../../common/utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const abstract_json_model_storage_1 = __webpack_require__(/*! ../abstract-json-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/node/abstract-json-model-storage.js");
exports.EMPTY_ROOT = graph_1.GGraph.builder().id('empty').build();
/**
 * A {@link SourceModelStorage} that reads and writes the graph model directly from / into
 * a JSON file and uses it as source model.
 */
let GModelStorage = class GModelStorage extends abstract_json_model_storage_1.AbstractJsonModelStorage {
    loadSourceModel(action) {
        const sourceUri = this.getSourceUri(action);
        const rootSchema = this.loadFromFile(sourceUri, protocol_1.isGModelElementSchema);
        const root = this.modelSerializer.createRoot(rootSchema);
        this.modelState.updateRoot(root);
    }
    saveSourceModel(action) {
        const fileUri = this.getFileUri(action);
        const schema = this.modelSerializer.createSchema(this.modelState.root);
        this.writeFile(fileUri, schema);
    }
};
exports.GModelStorage = GModelStorage;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], GModelStorage.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(gmodel_serializer_1.GModelSerializer),
    __metadata("design:type", Object)
], GModelStorage.prototype, "modelSerializer", void 0);
__decorate([
    (0, inversify_1.inject)(model_state_1.ModelState),
    __metadata("design:type", Object)
], GModelStorage.prototype, "modelState", void 0);
exports.GModelStorage = GModelStorage = __decorate([
    (0, inversify_1.injectable)()
], GModelStorage);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/********************************************************************************
 * Copyright (c) 2022-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
__exportStar(__webpack_require__(/*! ./abstract-json-model-storage */ "../../node_modules/@eclipse-glsp/server/lib/node/abstract-json-model-storage.js"), exports);
__exportStar(__webpack_require__(/*! ./di/app-module */ "../../node_modules/@eclipse-glsp/server/lib/node/di/app-module.js"), exports);
__exportStar(__webpack_require__(/*! ./di/winston-logger */ "../../node_modules/@eclipse-glsp/server/lib/node/di/winston-logger.js"), exports);
__exportStar(__webpack_require__(/*! ./gmodel/gmodel-storage */ "../../node_modules/@eclipse-glsp/server/lib/node/gmodel/gmodel-storage.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/cli-parser */ "../../node_modules/@eclipse-glsp/server/lib/node/launch/cli-parser.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/socket-cli-parser */ "../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-cli-parser.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/socket-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-server-launcher.js"), exports);
__exportStar(__webpack_require__(/*! ./launch/websocket-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/node/launch/websocket-server-launcher.js"), exports);
__exportStar(__webpack_require__(/*! ./reexport */ "../../node_modules/@eclipse-glsp/server/lib/node/reexport.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/launch/cli-parser.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/launch/cli-parser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isDirectory = exports.processLogDir = exports.processLogLevel = exports.parse = exports.createCliParser = exports.defaultLaunchOptions = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const cmd = __webpack_require__(/*! commander */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/index.js");
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const logger_1 = __webpack_require__(/*! ../../common/utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
exports.defaultLaunchOptions = {
    logLevel: logger_1.LogLevel.info,
    logDir: '.config',
    consoleLog: true,
    fileLog: false
};
function createCliParser(options = exports.defaultLaunchOptions) {
    const command = new cmd.Command()
        .version('1.0.0')
        .description('GLSP server')
        .showHelpAfterError(true)
        .name('Launch a GLSP server')
        .option('-l , --logLevel <logLevel>', `Set the log level. [default='${options.logLevel}']`, processLogLevel, options.logLevel)
        .option('-d , --logDir <logDir>', `Set the directory for log files (when file logging is enabled) [default=${options.logDir}]`, processLogDir, options.logDir)
        .addHelpText('afterAll', '\n Copyright (c) 2022-2023 Eclipse GLSP');
    return { command, parse: argv => parse(command, options, argv) };
}
exports.createCliParser = createCliParser;
function parse(command, defaultOptions, argv) {
    command.parse(argv);
    return { ...defaultOptions, ...command.opts() };
}
exports.parse = parse;
function processLogLevel(value) {
    const level = (0, logger_1.asLogLevel)(value);
    if (!level) {
        throw new cmd.InvalidArgumentError("Argument has to be 'none'|'error'|'warn'|'info'|'debug'!");
    }
    return level;
}
exports.processLogLevel = processLogLevel;
function processLogDir(value) {
    const logDir = path.resolve(value);
    if (path.extname(logDir).length !== 0 || !isDirectory(path.dirname(logDir))) {
        throw new cmd.InvalidArgumentError('Argument is not a valid directory!');
    }
    return logDir;
}
exports.processLogDir = processLogDir;
function isDirectory(value) {
    try {
        return fs.statSync(value).isDirectory();
    }
    catch (error) {
        return false;
    }
}
exports.isDirectory = isDirectory;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-cli-parser.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-cli-parser.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processPort = exports.createSocketCliParser = exports.defaultSocketLaunchOptions = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const cmd = __webpack_require__(/*! commander */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/index.js");
const cli_parser_1 = __webpack_require__(/*! ./cli-parser */ "../../node_modules/@eclipse-glsp/server/lib/node/launch/cli-parser.js");
exports.defaultSocketLaunchOptions = {
    ...cli_parser_1.defaultLaunchOptions,
    port: 0,
    host: '127.0.0.1'
};
function createSocketCliParser(defaultOptions = exports.defaultSocketLaunchOptions) {
    const parser = (0, cli_parser_1.createCliParser)(defaultOptions);
    parser.command
        .option('-p , --port <port>', `Set server port [default= ${defaultOptions.port}]`, processPort, defaultOptions.port)
        .option('--host <host>', `Set host name [default= ${defaultOptions.host}`, defaultOptions.host)
        .option('--no-consoleLog', 'Disable console logging')
        .option('--fileLog', 'Enable file logging', defaultOptions.fileLog);
    return parser;
}
exports.createSocketCliParser = createSocketCliParser;
function processPort(value) {
    const port = Number.parseInt(value, 10);
    if (isNaN(port)) {
        throw new cmd.InvalidArgumentError('Port is not a number!');
    }
    if (port < 0 || port > 65535) {
        throw new cmd.InvalidArgumentError('Port has to be between in range (0,65535)!');
    }
    return port;
}
exports.processPort = processPort;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-server-launcher.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/launch/socket-server-launcher.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SocketServerLauncher = void 0;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const net = __webpack_require__(/*! net */ "net");
const jsonrpc = __webpack_require__(/*! vscode-jsonrpc/node */ "../../node_modules/vscode-jsonrpc/node.js");
const jsonrpc_server_launcher_1 = __webpack_require__(/*! ../../common/launch/jsonrpc-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/common/launch/jsonrpc-server-launcher.js");
const logger_1 = __webpack_require__(/*! ../../common/utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
let SocketServerLauncher = class SocketServerLauncher extends jsonrpc_server_launcher_1.JsonRpcGLSPServerLauncher {
    constructor() {
        super();
        this.toDispose.push(protocol_1.Disposable.create(() => {
            this.netServer.close();
        }));
    }
    run(opts) {
        this.netServer = net.createServer(socket => {
            const connection = this.createConnection(socket);
            this.createServerInstance(connection);
        });
        this.netServer.listen(opts.port, opts.host);
        this.netServer.on('listening', () => {
            const addressInfo = this.netServer.address();
            if (!addressInfo) {
                this.logger.error('Could not resolve GLSP Server address info. Shutting down.');
                this.shutdown();
                return;
            }
            else if (typeof addressInfo === 'string') {
                this.logger.error(`GLSP Server is unexpectedly listening to pipe or domain socket "${addressInfo}". Shutting down.`);
                this.shutdown();
                return;
            }
            const currentPort = addressInfo.port;
            this.logger.info(`The GLSP server is ready to accept new client requests on port: ${currentPort}`);
            // Print a message to the output stream that indicates that the start is completed.
            // This indicates to the client that the server process is ready (in an embedded scenario).
            console.log(this.startupCompleteMessage.concat(currentPort.toString()));
        });
        this.netServer.on('error', () => this.shutdown());
        return new Promise((resolve, reject) => {
            this.netServer.on('close', () => resolve(undefined));
            this.netServer.on('error', error => reject(error));
        });
    }
    createConnection(socket) {
        return jsonrpc.createMessageConnection(new jsonrpc.SocketMessageReader(socket), new jsonrpc.SocketMessageWriter(socket), console);
    }
};
exports.SocketServerLauncher = SocketServerLauncher;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], SocketServerLauncher.prototype, "logger", void 0);
exports.SocketServerLauncher = SocketServerLauncher = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], SocketServerLauncher);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/launch/websocket-server-launcher.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/launch/websocket-server-launcher.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapWebSocket = exports.WebSocketServerLauncher = void 0;
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const http = __webpack_require__(/*! http */ "http");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const net = __webpack_require__(/*! net */ "net");
const ws_1 = __webpack_require__(/*! ws */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/index.js");
const jsonrpc_server_launcher_1 = __webpack_require__(/*! ../../common/launch/jsonrpc-server-launcher */ "../../node_modules/@eclipse-glsp/server/lib/common/launch/jsonrpc-server-launcher.js");
const logger_1 = __webpack_require__(/*! ../../common/utils/logger */ "../../node_modules/@eclipse-glsp/server/lib/common/utils/logger.js");
const STATUS_UPGRADE_REQUIRED = 426;
let WebSocketServerLauncher = class WebSocketServerLauncher extends jsonrpc_server_launcher_1.JsonRpcGLSPServerLauncher {
    constructor() {
        super();
        this.toDispose.push(protocol_1.Disposable.create(() => {
            this.server.close();
        }));
    }
    async run(options) {
        const resolvedOptions = await this.resolveOptions(options);
        this.server = new ws_1.Server({ server: resolvedOptions.server, path: resolvedOptions.path });
        const endpoint = `ws://${resolvedOptions.host}:${resolvedOptions.port}:${resolvedOptions.path}`;
        this.logger.info(`The GLSP Websocket launcher is ready to accept new client requests on endpoint '${endpoint}'`);
        console.log(this.startupCompleteMessage.concat(resolvedOptions.port.toString()));
        this.server.on('connection', (ws, req) => {
            const connection = this.createConnection(ws);
            this.createServerInstance(connection);
        });
        return new Promise((resolve, reject) => {
            this.server.on('close', () => resolve(undefined));
            this.server.on('error', error => reject(error));
        });
    }
    createConnection(socket) {
        return (0, protocol_1.createWebSocketConnection)(wrapWebSocket(socket));
    }
    async resolveOptions(options) {
        const port = !options.port || options.port === 0 ? await getFreePort() : options.port;
        const path = options.path.startsWith('/') ? options.path : `/${options.path}`;
        const server = this.createHttpServer(port, options.host);
        return { ...options, port, path, server };
    }
    createHttpServer(port, host) {
        const server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[STATUS_UPGRADE_REQUIRED];
            res.writeHead(426, {
                'Content-Length': body === null || body === void 0 ? void 0 : body.length,
                'Content-Type': 'text/plain'
            });
            res.end(body);
        });
        server.listen(port, host);
        // Set server timeout to infinite
        server.setTimeout(0);
        return server;
    }
    start(options) {
        super.start(options);
    }
};
exports.WebSocketServerLauncher = WebSocketServerLauncher;
__decorate([
    (0, inversify_1.inject)(logger_1.Logger),
    __metadata("design:type", logger_1.Logger)
], WebSocketServerLauncher.prototype, "logger", void 0);
exports.WebSocketServerLauncher = WebSocketServerLauncher = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], WebSocketServerLauncher);
async function getFreePort() {
    return new Promise((resolve, reject) => {
        const srv = net.createServer();
        srv.listen(0, () => {
            const address = srv.address();
            if (!address || typeof address === 'string') {
                reject(new Error('Could not address to compute a free port'));
                return;
            }
            srv.close(() => resolve(address.port));
        });
    });
}
/**
 * Creates a {@link WebSocketWrapper} for the given plain WebSocket
 * @param socket The socket to wrap
 */
function wrapWebSocket(socket) {
    return {
        send: content => socket.send(content),
        onMessage: cb => socket.on('message', cb),
        onClose: cb => socket.on('close', cb),
        onError: cb => socket.on('error', cb),
        dispose: () => socket.close()
    };
}
exports.wrapWebSocket = wrapWebSocket;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/lib/node/reexport.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/lib/node/reexport.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
__exportStar(__webpack_require__(/*! ../common */ "../../node_modules/@eclipse-glsp/server/lib/common/index.js"), exports);


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/


module.exports = __webpack_require__(/*! ./lib/node/index */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/index.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/sender.js");

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/event-target.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/event-target.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/extension.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/extension.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/limiter.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/limiter.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/receiver.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/receiver.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js");

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/sender.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/sender.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");
const { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/stream.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/stream.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/subprotocol.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/subprotocol.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(/*! buffer */ "buffer");

const { hasBlob } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket-server.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket-server.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const http = __webpack_require__(/*! http */ "http");
const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");

const extension = __webpack_require__(/*! ./extension */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/websocket.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { Duplex, Readable } = __webpack_require__(/*! stream */ "stream");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/sender.js");
const { isBlob } = __webpack_require__(/*! ./validation */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/validation.js");

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../node_modules/@eclipse-glsp/server/node_modules/ws/lib/buffer-util.js");

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "../../node_modules/abort-controller/dist/abort-controller.js":
/*!********************************************************************!*\
  !*** ../../node_modules/abort-controller/dist/abort-controller.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({ value: true }));

var eventTargetShim = __webpack_require__(/*! event-target-shim */ "../../node_modules/event-target-shim/dist/event-target-shim.js");

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
class AbortSignal extends eventTargetShim.EventTarget {
    /**
     * AbortSignal cannot be constructed directly.
     */
    constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
    }
    /**
     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
     */
    get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
    }
}
eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
    const signal = Object.create(AbortSignal.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
        return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true },
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal",
    });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
class AbortController {
    /**
     * Initialize this controller.
     */
    constructor() {
        signals.set(this, createAbortSignal());
    }
    /**
     * Returns the `AbortSignal` object associated with this object.
     */
    get signal() {
        return getSignal(this);
    }
    /**
     * Abort and signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        abortSignal(getSignal(this));
    }
}
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true },
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController",
    });
}

exports.AbortController = AbortController;
exports.AbortSignal = AbortSignal;
exports["default"] = AbortController;

module.exports = AbortController
module.exports.AbortController = module.exports["default"] = AbortController
module.exports.AbortSignal = AbortSignal


/***/ }),

/***/ "../../node_modules/color-convert/conversions.js":
/*!*******************************************************!*\
  !*** ../../node_modules/color-convert/conversions.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
var cssKeywords = __webpack_require__(/*! color-name */ "../../node_modules/color-convert/node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "../../node_modules/color-convert/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/color-convert/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var conversions = __webpack_require__(/*! ./conversions */ "../../node_modules/color-convert/conversions.js");
var route = __webpack_require__(/*! ./route */ "../../node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "../../node_modules/color-convert/node_modules/color-name/index.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/color-convert/node_modules/color-name/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "../../node_modules/color-convert/route.js":
/*!*************************************************!*\
  !*** ../../node_modules/color-convert/route.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var conversions = __webpack_require__(/*! ./conversions */ "../../node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "../../node_modules/color-name/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/color-name/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "../../node_modules/color-string/index.js":
/*!************************************************!*\
  !*** ../../node_modules/color-string/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
var colorNames = __webpack_require__(/*! color-name */ "../../node_modules/color-name/index.js");
var swizzle = __webpack_require__(/*! simple-swizzle */ "../../node_modules/simple-swizzle/index.js");
var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = Object.create(null);

// create a list of reverse color names
for (var name in colorNames) {
	if (hasOwnProperty.call(colorNames, name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorNames, match[1])) {
			return null;
		}

		rgb = colorNames[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}


/***/ }),

/***/ "../../node_modules/color/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/color/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var colorString = __webpack_require__(/*! color-string */ "../../node_modules/color-string/index.js");
var convert = __webpack_require__(/*! color-convert */ "../../node_modules/color-convert/index.js");

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;


/***/ }),

/***/ "../../node_modules/colorspace/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/colorspace/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var color = __webpack_require__(/*! color */ "../../node_modules/color/index.js")
  , hex = __webpack_require__(/*! text-hex */ "../../node_modules/text-hex/index.js");

/**
 * Generate a color for a given name. But be reasonably smart about it by
 * understanding name spaces and coloring each namespace a bit lighter so they
 * still have the same base color as the root.
 *
 * @param {string} namespace The namespace
 * @param {string} [delimiter] The delimiter
 * @returns {string} color
 */
module.exports = function colorspace(namespace, delimiter) {
  var split = namespace.split(delimiter || ':');
  var base = hex(split[0]);

  if (!split.length) return base;

  for (var i = 0, l = split.length - 1; i < l; i++) {
    base = color(base)
    .mix(color(hex(split[i + 1])))
    .saturate(1)
    .hex();
  }

  return base;
};


/***/ }),

/***/ "../../node_modules/enabled/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/enabled/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * Checks if a given namespace is allowed by the given variable.
 *
 * @param {String} name namespace that should be included.
 * @param {String} variable Value that needs to be tested.
 * @returns {Boolean} Indication if namespace is enabled.
 * @public
 */
module.exports = function enabled(name, variable) {
  if (!variable) return false;

  var variables = variable.split(/[\s,]+/)
    , i = 0;

  for (; i < variables.length; i++) {
    variable = variables[i].replace('*', '.*?');

    if ('-' === variable.charAt(0)) {
      if ((new RegExp('^'+ variable.substr(1) +'$')).test(name)) {
        return false;
      }

      continue;
    }

    if ((new RegExp('^'+ variable +'$')).test(name)) {
      return true;
    }
  }

  return false;
};


/***/ }),

/***/ "../../node_modules/event-target-shim/dist/event-target-shim.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/event-target-shim/dist/event-target-shim.js ***!
  \**********************************************************************/
/***/ ((module, exports) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({ value: true }));

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
    if (data.passiveListener != null) {
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) {
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
        }
        return
    }
    if (!data.event.cancelable) {
        return
    }

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
    }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        setCancelFlag(pd(this));
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     * @deprecated
     */
    get srcElement() {
        return pd(this).eventTarget
    },

    /**
     * The flag to stop event bubbling.
     * @type {boolean}
     * @deprecated
     */
    get cancelBubble() {
        return pd(this).stopped
    },
    set cancelBubble(value) {
        if (!value) {
            return
        }
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
            data.event.cancelBubble = true;
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     * @deprecated
     */
    get returnValue() {
        return !pd(this).canceled
    },
    set returnValue(value) {
        if (!value) {
            setCancelFlag(pd(this));
        }
    },

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string} type The event type.
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() {
        // Do nothing.
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).immediateStopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    } else {
                        listeners.delete(eventName);
                    }
                } else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
    );
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
            value: CustomEventTarget,
            configurable: true,
            writable: true,
        },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                // Should ignore duplication.
                return
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
                return
            }

            prev = node;
            node = node.next;
        }
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.')
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
            } else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                } catch (err) {
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) {
                        console.error(err);
                    }
                }
            } else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports["default"] = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute


/***/ }),

/***/ "../../node_modules/fecha/lib/fecha.js":
/*!*********************************************!*\
  !*** ../../node_modules/fecha/lib/fecha.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultI18n: () => (/* binding */ defaultI18n),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   setGlobalDateI18n: () => (/* binding */ setGlobalDateI18n),
/* harmony export */   setGlobalDateMasks: () => (/* binding */ setGlobalDateMasks)
/* harmony export */ });
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
}
var monthUpdate = function (arrName) { return function (v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function (v) { return v.toLowerCase(); });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
        return index;
    }
    return null;
}; };
function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
            // @ts-ignore ex
            origObj[key] = obj[key];
        }
    }
    return origObj;
}
var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
];
var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ["am", "pm"],
    DoFn: function (dayOfMonth) {
        return (dayOfMonth +
            ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3
                ? 0
                : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);
    }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function (i18n) {
    return (globalI18n = assign(globalI18n, i18n));
};
var regexEscape = function (str) {
    return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function (val, len) {
    if (len === void 0) { len = 2; }
    val = String(val);
    while (val.length < len) {
        val = "0" + val;
    }
    return val;
};
var formatFlags = {
    D: function (dateObj) { return String(dateObj.getDate()); },
    DD: function (dateObj) { return pad(dateObj.getDate()); },
    Do: function (dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
    },
    d: function (dateObj) { return String(dateObj.getDay()); },
    dd: function (dateObj) { return pad(dateObj.getDay()); },
    ddd: function (dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function (dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
    },
    M: function (dateObj) { return String(dateObj.getMonth() + 1); },
    MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },
    MMM: function (dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function (dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function (dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },
    h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },
    hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },
    H: function (dateObj) { return String(dateObj.getHours()); },
    HH: function (dateObj) { return pad(dateObj.getHours()); },
    m: function (dateObj) { return String(dateObj.getMinutes()); },
    mm: function (dateObj) { return pad(dateObj.getMinutes()); },
    s: function (dateObj) { return String(dateObj.getSeconds()); },
    ss: function (dateObj) { return pad(dateObj.getSeconds()); },
    S: function (dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function (dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },
    a: function (dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function (dateObj, i18n) {
        return dateObj.getHours() < 12
            ? i18n.amPm[0].toUpperCase()
            : i18n.amPm[1].toUpperCase();
    },
    ZZ: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));
    },
    Z: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60), 2) +
            ":" +
            pad(Math.abs(offset) % 60, 2));
    }
};
var monthParse = function (v) { return +v - 1; };
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
    "isPm",
    word,
    function (v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
            return 0;
        }
        else if (val === i18n.amPm[1]) {
            return 1;
        }
        return null;
    }
];
var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function (v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
    }
];
var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function (v) { return parseInt(v, 10); }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
        "year",
        twoDigits,
        function (v) {
            var now = new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
    ],
    h: ["hour", twoDigitsOptional, undefined, "isPm"],
    hh: ["hour", twoDigits, undefined, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function (v) { return +v * 100; }],
    SS: ["millisecond", twoDigits, function (v) { return +v * 10; }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
};
// Some common format strings
var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function (masks) { return assign(globalMasks, masks); };
/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 * @returns {string} Formatted date string
 */
var format = function (dateObj, mask, i18n) {
    if (mask === void 0) { mask = globalMasks["default"]; }
    if (i18n === void 0) { i18n = {}; }
    if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" ||
        isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    // Make literals inactive by replacing them with @@@
    mask = mask.replace(literal, function ($0, $1) {
        literals.push($1);
        return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/@@@/g, function () { return literals.shift(); });
};
/**
 * Parse a date string into a Javascript Date object /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
 * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
 */
function parse(dateStr, format, i18n) {
    if (i18n === void 0) { i18n = {}; }
    if (typeof format !== "string") {
        throw new Error("Invalid format in fecha parse");
    }
    // Check to see if the format is actually a mask
    format = globalMasks[format] || format;
    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
        return null;
    }
    // Default to the beginning of the year.
    var today = new Date();
    var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
    };
    var parseInfo = [];
    var literals = [];
    // Replace all the literals with @@@. Hopefully a string that won't exist in the format
    var newFormat = format.replace(literal, function ($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
    });
    var specifiedFields = {};
    var requiredFields = {};
    // Change every token that we find into the correct regex
    newFormat = regexEscape(newFormat).replace(token, function ($0) {
        var info = parseFlags[$0];
        var field = info[0], regex = info[1], requiredField = info[3];
        // Check if the person has specified the same field twice. This will lead to confusing results.
        if (specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " specified twice in format");
        }
        specifiedFields[field] = true;
        // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified
        if (requiredField) {
            requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
    });
    // Check all the required fields are present
    Object.keys(requiredFields).forEach(function (field) {
        if (!specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " is required in specified format");
        }
    });
    // Add back all the literals after
    newFormat = newFormat.replace(/@@@/g, function () { return literals.shift(); });
    // Check if the date string matches the format. If it doesn't return null
    var matches = dateStr.match(new RegExp(newFormat, "i"));
    if (!matches) {
        return null;
    }
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    // For each match, call the parser function for that date part
    for (var i = 1; i < matches.length; i++) {
        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
        var value = parser
            ? parser(matches[i], combinedI18nSettings)
            : +matches[i];
        // If the parser can't make sense of the value, return null
        if (value == null) {
            return null;
        }
        dateInfo[field] = value;
    }
    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
    }
    else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
    }
    var dateTZ;
    if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length; i < len; i++) {
            // Check to make sure the date field is within the allowed range. Javascript dates allows values
            // outside the allowed range. If the values don't match the value was invalid
            if (specifiedFields[validateFields[i][0]] &&
                dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
                return null;
            }
        }
    }
    else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        // We can't validate dates in another timezone unfortunately. Do a basic check instead
        if (dateInfo.month > 11 ||
            dateInfo.month < 0 ||
            dateInfo.day > 31 ||
            dateInfo.day < 1 ||
            dateInfo.hour > 23 ||
            dateInfo.hour < 0 ||
            dateInfo.minute > 59 ||
            dateInfo.minute < 0 ||
            dateInfo.second > 59 ||
            dateInfo.second < 0) {
            return null;
        }
    }
    // Don't allow invalid dates
    return dateTZ;
}
var fecha = {
    format: format,
    parse: parse,
    defaultI18n: defaultI18n,
    setGlobalDateI18n: setGlobalDateI18n,
    setGlobalDateMasks: setGlobalDateMasks
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fecha);



/***/ }),

/***/ "../../node_modules/fn.name/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/fn.name/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var toString = Object.prototype.toString;

/**
 * Extract names from functions.
 *
 * @param {Function} fn The function who's name we need to extract.
 * @returns {String} The name of the function.
 * @public
 */
module.exports = function name(fn) {
  if ('string' === typeof fn.displayName && fn.constructor.name) {
    return fn.displayName;
  } else if ('string' === typeof fn.name && fn.name) {
    return fn.name;
  }

  //
  // Check to see if the constructor has a name.
  //
  if (
       'object' === typeof fn
    && fn.constructor
    && 'string' === typeof fn.constructor.name
  ) return fn.constructor.name;

  //
  // toString the given function and attempt to parse it out of it, or determine
  // the class.
  //
  var named = fn.toString()
    , type = toString.call(fn).slice(8, -1);

  if ('Function' === type) {
    named = named.substring(named.indexOf('(') + 1, named.indexOf(')'));
  } else {
    named = type;
  }

  return named || 'anonymous';
};


/***/ }),

/***/ "../../node_modules/inherits/inherits.js":
/*!***********************************************!*\
  !*** ../../node_modules/inherits/inherits.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(/*! util */ "util");
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "../../node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "../../node_modules/inherits/inherits_browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/inherits/inherits_browser.js ***!
  \*******************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "../../node_modules/inversify/es/annotation/decorator_utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/decorator_utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTaggedDecorator: () => (/* binding */ createTaggedDecorator),
/* harmony export */   decorate: () => (/* binding */ decorate),
/* harmony export */   tagParameter: () => (/* binding */ tagParameter),
/* harmony export */   tagProperty: () => (/* binding */ tagProperty)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/js */ "../../node_modules/inversify/es/utils/js.js");



function targetIsConstructorFunction(target) {
    return target.prototype !== undefined;
}
function _throwIfMethodParameter(parameterName) {
    if (parameterName !== undefined) {
        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_DECORATOR_OPERATION);
    }
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    _throwIfMethodParameter(parameterName);
    _tagParameterOrProperty(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function tagProperty(annotationTarget, propertyName, metadata) {
    if (targetIsConstructorFunction(annotationTarget)) {
        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_DECORATOR_OPERATION);
    }
    _tagParameterOrProperty(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
}
function _ensureNoMetadataKeyDuplicates(metadata) {
    var metadatas = [];
    if (Array.isArray(metadata)) {
        metadatas = metadata;
        var duplicate = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getFirstArrayDuplicate)(metadatas.map(function (md) { return md.key; }));
        if (duplicate !== undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.DUPLICATED_METADATA + " " + duplicate.toString());
        }
    }
    else {
        metadatas = [metadata];
    }
    return metadatas;
}
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
    var paramsOrPropertiesMetadata = {};
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (paramOrPropertyMetadata === undefined) {
        paramOrPropertyMetadata = [];
    }
    else {
        var _loop_1 = function (m) {
            if (metadatas.some(function (md) { return md.key === m.key; })) {
                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.DUPLICATED_METADATA + " " + m.key.toString());
            }
        };
        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
            var m = paramOrPropertyMetadata_1[_i];
            _loop_1(m);
        }
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function createTaggedDecorator(metadata) {
    return function (target, targetKey, indexOrPropertyDescriptor) {
        if (typeof indexOrPropertyDescriptor === 'number') {
            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
        }
        else {
            tagProperty(target, targetKey, metadata);
        }
    };
}
function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
}
function _param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
}
function decorate(decorator, target, parameterIndexOrProperty) {
    if (typeof parameterIndexOrProperty === 'number') {
        _decorate([_param(parameterIndexOrProperty, decorator)], target);
    }
    else if (typeof parameterIndexOrProperty === 'string') {
        Reflect.decorate([decorator], target, parameterIndexOrProperty);
    }
    else {
        _decorate([decorator], target);
    }
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/inject.js":
/*!************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/inject.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inject: () => (/* binding */ inject)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _inject_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inject_base */ "../../node_modules/inversify/es/annotation/inject_base.js");


var inject = (0,_inject_base__WEBPACK_IMPORTED_MODULE_0__.injectBase)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.INJECT_TAG);



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/inject_base.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/inject_base.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   injectBase: () => (/* binding */ injectBase)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");



function injectBase(metadataKey) {
    return function (serviceIdentifier) {
        return function (target, targetKey, indexOrPropertyDescriptor) {
            if (serviceIdentifier === undefined) {
                var className = typeof target === 'function' ? target.name : target.constructor.name;
                throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED_INJECT_ANNOTATION)(className));
            }
            return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_1__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_2__.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
        };
    };
}


/***/ }),

/***/ "../../node_modules/inversify/es/annotation/injectable.js":
/*!****************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/injectable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   injectable: () => (/* binding */ injectable)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");


function injectable() {
    return function (target) {
        if (Reflect.hasOwnMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, target)) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.DUPLICATED_INJECTABLE_DECORATOR);
        }
        var types = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.DESIGN_PARAM_TYPES, target) || [];
        Reflect.defineMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, types, target);
        return target;
    };
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/lazy_service_identifier.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/lazy_service_identifier.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LazyServiceIdentifier: () => (/* binding */ LazyServiceIdentifier)
/* harmony export */ });
var LazyServiceIdentifier = (function () {
    function LazyServiceIdentifier(cb) {
        this._cb = cb;
    }
    LazyServiceIdentifier.prototype.unwrap = function () {
        return this._cb();
    };
    return LazyServiceIdentifier;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/multi_inject.js":
/*!******************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/multi_inject.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   multiInject: () => (/* binding */ multiInject)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _inject_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inject_base */ "../../node_modules/inversify/es/annotation/inject_base.js");


var multiInject = (0,_inject_base__WEBPACK_IMPORTED_MODULE_0__.injectBase)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.MULTI_INJECT_TAG);



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/named.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/named.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   named: () => (/* binding */ named)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");



function named(name) {
    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.NAMED_TAG, name));
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/optional.js":
/*!**************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/optional.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   optional: () => (/* binding */ optional)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");



function optional() {
    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.OPTIONAL_TAG, true));
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/post_construct.js":
/*!********************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/post_construct.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   postConstruct: () => (/* binding */ postConstruct)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _property_event_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property_event_decorator */ "../../node_modules/inversify/es/annotation/property_event_decorator.js");



var postConstruct = (0,_property_event_decorator__WEBPACK_IMPORTED_MODULE_0__.propertyEventDecorator)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.POST_CONSTRUCT, _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLE_POST_CONSTRUCT_METHODS);



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/pre_destroy.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/pre_destroy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   preDestroy: () => (/* binding */ preDestroy)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _property_event_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property_event_decorator */ "../../node_modules/inversify/es/annotation/property_event_decorator.js");



var preDestroy = (0,_property_event_decorator__WEBPACK_IMPORTED_MODULE_0__.propertyEventDecorator)(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.PRE_DESTROY, _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLE_PRE_DESTROY_METHODS);



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/property_event_decorator.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/property_event_decorator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   propertyEventDecorator: () => (/* binding */ propertyEventDecorator)
/* harmony export */ });
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");

function propertyEventDecorator(eventKey, errorMessage) {
    return function () {
        return function (target, propertyKey) {
            var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(eventKey, propertyKey);
            if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
                throw new Error(errorMessage);
            }
            Reflect.defineMetadata(eventKey, metadata, target.constructor);
        };
    };
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/tagged.js":
/*!************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/tagged.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tagged: () => (/* binding */ tagged)
/* harmony export */ });
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");


function tagged(metadataKey, metadataValue) {
    return (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_0__.createTaggedDecorator)(new _planning_metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(metadataKey, metadataValue));
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/target_name.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/target_name.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   targetName: () => (/* binding */ targetName)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");



function targetName(name) {
    return function (target, targetKey, index) {
        var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.NAME_TAG, name);
        (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_2__.tagParameter)(target, targetKey, index, metadata);
    };
}



/***/ }),

/***/ "../../node_modules/inversify/es/annotation/unmanaged.js":
/*!***************************************************************!*\
  !*** ../../node_modules/inversify/es/annotation/unmanaged.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unmanaged: () => (/* binding */ unmanaged)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _decorator_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");



function unmanaged() {
    return function (target, targetKey, index) {
        var metadata = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.UNMANAGED_TAG, true);
        (0,_decorator_utils__WEBPACK_IMPORTED_MODULE_2__.tagParameter)(target, targetKey, index, metadata);
    };
}



/***/ }),

/***/ "../../node_modules/inversify/es/bindings/binding.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/bindings/binding.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Binding: () => (/* binding */ Binding)
/* harmony export */ });
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");


var Binding = (function () {
    function Binding(serviceIdentifier, scope) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingTypeEnum.Invalid;
        this.constraint = function (request) { return true; };
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.onActivation = null;
        this.onDeactivation = null;
        this.dynamicValue = null;
    }
    Binding.prototype.clone = function () {
        var clone = new Binding(this.serviceIdentifier, this.scope);
        clone.activated = (clone.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Singleton) ? this.activated : false;
        clone.implementationType = this.implementationType;
        clone.dynamicValue = this.dynamicValue;
        clone.scope = this.scope;
        clone.type = this.type;
        clone.factory = this.factory;
        clone.provider = this.provider;
        clone.constraint = this.constraint;
        clone.onActivation = this.onActivation;
        clone.onDeactivation = this.onDeactivation;
        clone.cache = this.cache;
        return clone;
    };
    return Binding;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/bindings/binding_count.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/inversify/es/bindings/binding_count.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingCount: () => (/* binding */ BindingCount)
/* harmony export */ });
var BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
};


/***/ }),

/***/ "../../node_modules/inversify/es/constants/error_msgs.js":
/*!***************************************************************!*\
  !*** ../../node_modules/inversify/es/constants/error_msgs.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AMBIGUOUS_MATCH: () => (/* binding */ AMBIGUOUS_MATCH),
/* harmony export */   ARGUMENTS_LENGTH_MISMATCH: () => (/* binding */ ARGUMENTS_LENGTH_MISMATCH),
/* harmony export */   ASYNC_UNBIND_REQUIRED: () => (/* binding */ ASYNC_UNBIND_REQUIRED),
/* harmony export */   CANNOT_UNBIND: () => (/* binding */ CANNOT_UNBIND),
/* harmony export */   CIRCULAR_DEPENDENCY: () => (/* binding */ CIRCULAR_DEPENDENCY),
/* harmony export */   CIRCULAR_DEPENDENCY_IN_FACTORY: () => (/* binding */ CIRCULAR_DEPENDENCY_IN_FACTORY),
/* harmony export */   CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE: () => (/* binding */ CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE),
/* harmony export */   CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE: () => (/* binding */ CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE),
/* harmony export */   CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK: () => (/* binding */ CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK),
/* harmony export */   CONTAINER_OPTIONS_MUST_BE_AN_OBJECT: () => (/* binding */ CONTAINER_OPTIONS_MUST_BE_AN_OBJECT),
/* harmony export */   DUPLICATED_INJECTABLE_DECORATOR: () => (/* binding */ DUPLICATED_INJECTABLE_DECORATOR),
/* harmony export */   DUPLICATED_METADATA: () => (/* binding */ DUPLICATED_METADATA),
/* harmony export */   INVALID_BINDING_TYPE: () => (/* binding */ INVALID_BINDING_TYPE),
/* harmony export */   INVALID_DECORATOR_OPERATION: () => (/* binding */ INVALID_DECORATOR_OPERATION),
/* harmony export */   INVALID_FUNCTION_BINDING: () => (/* binding */ INVALID_FUNCTION_BINDING),
/* harmony export */   INVALID_MIDDLEWARE_RETURN: () => (/* binding */ INVALID_MIDDLEWARE_RETURN),
/* harmony export */   INVALID_TO_SELF_VALUE: () => (/* binding */ INVALID_TO_SELF_VALUE),
/* harmony export */   KEY_NOT_FOUND: () => (/* binding */ KEY_NOT_FOUND),
/* harmony export */   LAZY_IN_SYNC: () => (/* binding */ LAZY_IN_SYNC),
/* harmony export */   MISSING_INJECTABLE_ANNOTATION: () => (/* binding */ MISSING_INJECTABLE_ANNOTATION),
/* harmony export */   MISSING_INJECT_ANNOTATION: () => (/* binding */ MISSING_INJECT_ANNOTATION),
/* harmony export */   MULTIPLE_POST_CONSTRUCT_METHODS: () => (/* binding */ MULTIPLE_POST_CONSTRUCT_METHODS),
/* harmony export */   MULTIPLE_PRE_DESTROY_METHODS: () => (/* binding */ MULTIPLE_PRE_DESTROY_METHODS),
/* harmony export */   NOT_IMPLEMENTED: () => (/* binding */ NOT_IMPLEMENTED),
/* harmony export */   NOT_REGISTERED: () => (/* binding */ NOT_REGISTERED),
/* harmony export */   NO_MORE_SNAPSHOTS_AVAILABLE: () => (/* binding */ NO_MORE_SNAPSHOTS_AVAILABLE),
/* harmony export */   NULL_ARGUMENT: () => (/* binding */ NULL_ARGUMENT),
/* harmony export */   ON_DEACTIVATION_ERROR: () => (/* binding */ ON_DEACTIVATION_ERROR),
/* harmony export */   POST_CONSTRUCT_ERROR: () => (/* binding */ POST_CONSTRUCT_ERROR),
/* harmony export */   PRE_DESTROY_ERROR: () => (/* binding */ PRE_DESTROY_ERROR),
/* harmony export */   STACK_OVERFLOW: () => (/* binding */ STACK_OVERFLOW),
/* harmony export */   UNDEFINED_INJECT_ANNOTATION: () => (/* binding */ UNDEFINED_INJECT_ANNOTATION)
/* harmony export */ });
var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';
var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';
var NULL_ARGUMENT = 'NULL argument';
var KEY_NOT_FOUND = 'Key Not Found';
var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';
var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';
var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';
var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';
var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';
var UNDEFINED_INJECT_ANNOTATION = function (name) {
    return "@inject called with undefined this could mean that the class " + name + " has " +
        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +
        'overcome this limitation.';
};
var CIRCULAR_DEPENDENCY = 'Circular dependency found:';
var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';
var INVALID_BINDING_TYPE = 'Invalid binding type:';
var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';
var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';
var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';
var LAZY_IN_SYNC = function (key) { return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies."; };
var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +
    'used as service identifier';
var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +
    'must be applied to the parameters of a class constructor or a class property.';
var ARGUMENTS_LENGTH_MISMATCH = function () {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return 'The number of constructor arguments in the derived class ' +
        (values[0] + " must be >= than the number of constructor arguments of its base class.");
};
var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +
    'must be an object.';
var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +
    'be a string ("singleton" or "transient").';
var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +
    'be a boolean';
var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +
    'be a boolean';
var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';
var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';
var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';
var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return "@postConstruct error in class " + clazz + ": " + errorMessage; };
var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return "@preDestroy error in class " + clazz + ": " + errorMessage; };
var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return "onDeactivation() error in class " + clazz + ": " + errorMessage; };
var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {
    return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with " +
        ("service identifier '" + serviceIdentifier + "'.");
};
var STACK_OVERFLOW = 'Maximum call stack size exceeded';


/***/ }),

/***/ "../../node_modules/inversify/es/constants/literal_types.js":
/*!******************************************************************!*\
  !*** ../../node_modules/inversify/es/constants/literal_types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingScopeEnum: () => (/* binding */ BindingScopeEnum),
/* harmony export */   BindingTypeEnum: () => (/* binding */ BindingTypeEnum),
/* harmony export */   TargetTypeEnum: () => (/* binding */ TargetTypeEnum)
/* harmony export */ });
var BindingScopeEnum = {
    Request: 'Request',
    Singleton: 'Singleton',
    Transient: 'Transient'
};
var BindingTypeEnum = {
    ConstantValue: 'ConstantValue',
    Constructor: 'Constructor',
    DynamicValue: 'DynamicValue',
    Factory: 'Factory',
    Function: 'Function',
    Instance: 'Instance',
    Invalid: 'Invalid',
    Provider: 'Provider'
};
var TargetTypeEnum = {
    ClassProperty: 'ClassProperty',
    ConstructorArgument: 'ConstructorArgument',
    Variable: 'Variable'
};



/***/ }),

/***/ "../../node_modules/inversify/es/constants/metadata_keys.js":
/*!******************************************************************!*\
  !*** ../../node_modules/inversify/es/constants/metadata_keys.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DESIGN_PARAM_TYPES: () => (/* binding */ DESIGN_PARAM_TYPES),
/* harmony export */   INJECT_TAG: () => (/* binding */ INJECT_TAG),
/* harmony export */   MULTI_INJECT_TAG: () => (/* binding */ MULTI_INJECT_TAG),
/* harmony export */   NAMED_TAG: () => (/* binding */ NAMED_TAG),
/* harmony export */   NAME_TAG: () => (/* binding */ NAME_TAG),
/* harmony export */   NON_CUSTOM_TAG_KEYS: () => (/* binding */ NON_CUSTOM_TAG_KEYS),
/* harmony export */   OPTIONAL_TAG: () => (/* binding */ OPTIONAL_TAG),
/* harmony export */   PARAM_TYPES: () => (/* binding */ PARAM_TYPES),
/* harmony export */   POST_CONSTRUCT: () => (/* binding */ POST_CONSTRUCT),
/* harmony export */   PRE_DESTROY: () => (/* binding */ PRE_DESTROY),
/* harmony export */   TAGGED: () => (/* binding */ TAGGED),
/* harmony export */   TAGGED_PROP: () => (/* binding */ TAGGED_PROP),
/* harmony export */   UNMANAGED_TAG: () => (/* binding */ UNMANAGED_TAG)
/* harmony export */ });
var NAMED_TAG = 'named';
var NAME_TAG = 'name';
var UNMANAGED_TAG = 'unmanaged';
var OPTIONAL_TAG = 'optional';
var INJECT_TAG = 'inject';
var MULTI_INJECT_TAG = 'multi_inject';
var TAGGED = 'inversify:tagged';
var TAGGED_PROP = 'inversify:tagged_props';
var PARAM_TYPES = 'inversify:paramtypes';
var DESIGN_PARAM_TYPES = 'design:paramtypes';
var POST_CONSTRUCT = 'post_construct';
var PRE_DESTROY = 'pre_destroy';
function getNonCustomTagKeys() {
    return [
        INJECT_TAG,
        MULTI_INJECT_TAG,
        NAME_TAG,
        UNMANAGED_TAG,
        NAMED_TAG,
        OPTIONAL_TAG,
    ];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();


/***/ }),

/***/ "../../node_modules/inversify/es/container/container.js":
/*!**************************************************************!*\
  !*** ../../node_modules/inversify/es/container/container.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Container: () => (/* binding */ Container)
/* harmony export */ });
/* harmony import */ var _bindings_binding__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../bindings/binding */ "../../node_modules/inversify/es/bindings/binding.js");
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../planning/metadata_reader */ "../../node_modules/inversify/es/planning/metadata_reader.js");
/* harmony import */ var _planning_planner__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../planning/planner */ "../../node_modules/inversify/es/planning/planner.js");
/* harmony import */ var _resolution_resolver__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../resolution/resolver */ "../../node_modules/inversify/es/resolution/resolver.js");
/* harmony import */ var _syntax_binding_to_syntax__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../syntax/binding_to_syntax */ "../../node_modules/inversify/es/syntax/binding_to_syntax.js");
/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/async */ "../../node_modules/inversify/es/utils/async.js");
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/serialization */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _container_snapshot__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./container_snapshot */ "../../node_modules/inversify/es/container/container_snapshot.js");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookup */ "../../node_modules/inversify/es/container/lookup.js");
/* harmony import */ var _module_activation_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./module_activation_store */ "../../node_modules/inversify/es/container/module_activation_store.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};














var Container = (function () {
    function Container(containerOptions) {
        var options = containerOptions || {};
        if (typeof options !== 'object') {
            throw new Error("" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
        }
        if (options.defaultScope === undefined) {
            options.defaultScope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient;
        }
        else if (options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Singleton &&
            options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient &&
            options.defaultScope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Request) {
            throw new Error("" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
        }
        if (options.autoBindInjectable === undefined) {
            options.autoBindInjectable = false;
        }
        else if (typeof options.autoBindInjectable !== 'boolean') {
            throw new Error("" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
        }
        if (options.skipBaseClassChecks === undefined) {
            options.skipBaseClassChecks = false;
        }
        else if (typeof options.skipBaseClassChecks !== 'boolean') {
            throw new Error("" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
        }
        this.options = {
            autoBindInjectable: options.autoBindInjectable,
            defaultScope: options.defaultScope,
            skipBaseClassChecks: options.skipBaseClassChecks
        };
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_2__.id)();
        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();
        this._snapshots = [];
        this._middleware = null;
        this._activations = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();
        this._deactivations = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();
        this.parent = null;
        this._metadataReader = new _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_4__.MetadataReader();
        this._moduleActivationStore = new _module_activation_store__WEBPACK_IMPORTED_MODULE_5__.ModuleActivationStore();
    }
    Container.merge = function (container1, container2) {
        var containers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            containers[_i - 2] = arguments[_i];
        }
        var container = new Container();
        var targetContainers = __spreadArray([container1, container2], containers, true).map(function (targetContainer) { return (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.getBindingDictionary)(targetContainer); });
        var bindingDictionary = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.getBindingDictionary)(container);
        function copyDictionary(origin, destination) {
            origin.traverse(function (_key, value) {
                value.forEach(function (binding) {
                    destination.add(binding.serviceIdentifier, binding.clone());
                });
            });
        }
        targetContainers.forEach(function (targetBindingDictionary) {
            copyDictionary(targetBindingDictionary, bindingDictionary);
        });
        return container;
    };
    Container.prototype.load = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var getHelpers = this._getContainerModuleHelpersFactory();
        for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
            var currentModule = modules_1[_a];
            var containerModuleHelpers = getHelpers(currentModule.id);
            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
        }
    };
    Container.prototype.loadAsync = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        getHelpers = this._getContainerModuleHelpersFactory();
                        _a = 0, modules_2 = modules;
                        _b.label = 1;
                    case 1:
                        if (!(_a < modules_2.length)) return [3, 4];
                        currentModule = modules_2[_a];
                        containerModuleHelpers = getHelpers(currentModule.id);
                        return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _a++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    Container.prototype.unload = function () {
        var _this = this;
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        modules.forEach(function (module) {
            var deactivations = _this._removeModuleBindings(module.id);
            _this._deactivateSingletons(deactivations);
            _this._removeModuleHandlers(module.id);
        });
    };
    Container.prototype.unloadAsync = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _a, modules_3, module_1, deactivations;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = 0, modules_3 = modules;
                        _b.label = 1;
                    case 1:
                        if (!(_a < modules_3.length)) return [3, 4];
                        module_1 = modules_3[_a];
                        deactivations = this._removeModuleBindings(module_1.id);
                        return [4, this._deactivateSingletonsAsync(deactivations)];
                    case 2:
                        _b.sent();
                        this._removeModuleHandlers(module_1.id);
                        _b.label = 3;
                    case 3:
                        _a++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    Container.prototype.bind = function (serviceIdentifier) {
        var scope = this.options.defaultScope || _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.BindingScopeEnum.Transient;
        var binding = new _bindings_binding__WEBPACK_IMPORTED_MODULE_7__.Binding(serviceIdentifier, scope);
        this._bindingDictionary.add(serviceIdentifier, binding);
        return new _syntax_binding_to_syntax__WEBPACK_IMPORTED_MODULE_8__.BindingToSyntax(binding);
    };
    Container.prototype.rebind = function (serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
    };
    Container.prototype.rebindAsync = function (serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.unbindAsync(serviceIdentifier)];
                    case 1:
                        _a.sent();
                        return [2, this.bind(serviceIdentifier)];
                }
            });
        });
    };
    Container.prototype.unbind = function (serviceIdentifier) {
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            var bindings = this._bindingDictionary.get(serviceIdentifier);
            this._deactivateSingletons(bindings);
        }
        this._removeServiceFromDictionary(serviceIdentifier);
    };
    Container.prototype.unbindAsync = function (serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            var bindings;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._bindingDictionary.hasKey(serviceIdentifier)) return [3, 2];
                        bindings = this._bindingDictionary.get(serviceIdentifier);
                        return [4, this._deactivateSingletonsAsync(bindings)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this._removeServiceFromDictionary(serviceIdentifier);
                        return [2];
                }
            });
        });
    };
    Container.prototype.unbindAll = function () {
        var _this = this;
        this._bindingDictionary.traverse(function (_key, value) {
            _this._deactivateSingletons(value);
        });
        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();
    };
    Container.prototype.unbindAllAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        this._bindingDictionary.traverse(function (_key, value) {
                            promises.push(_this._deactivateSingletonsAsync(value));
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        this._bindingDictionary = new _lookup__WEBPACK_IMPORTED_MODULE_3__.Lookup();
                        return [2];
                }
            });
        });
    };
    Container.prototype.onActivation = function (serviceIdentifier, onActivation) {
        this._activations.add(serviceIdentifier, onActivation);
    };
    Container.prototype.onDeactivation = function (serviceIdentifier, onDeactivation) {
        this._deactivations.add(serviceIdentifier, onDeactivation);
    };
    Container.prototype.isBound = function (serviceIdentifier) {
        var bound = this._bindingDictionary.hasKey(serviceIdentifier);
        if (!bound && this.parent) {
            bound = this.parent.isBound(serviceIdentifier);
        }
        return bound;
    };
    Container.prototype.isCurrentBound = function (serviceIdentifier) {
        return this._bindingDictionary.hasKey(serviceIdentifier);
    };
    Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
        return this.isBoundTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);
    };
    Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
        var bound = false;
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            var bindings = this._bindingDictionary.get(serviceIdentifier);
            var request_1 = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.createMockRequest)(this, serviceIdentifier, key, value);
            bound = bindings.some(function (b) { return b.constraint(request_1); });
        }
        if (!bound && this.parent) {
            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
        }
        return bound;
    };
    Container.prototype.snapshot = function () {
        this._snapshots.push(_container_snapshot__WEBPACK_IMPORTED_MODULE_10__.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    };
    Container.prototype.restore = function () {
        var snapshot = this._snapshots.pop();
        if (snapshot === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NO_MORE_SNAPSHOTS_AVAILABLE);
        }
        this._bindingDictionary = snapshot.bindings;
        this._activations = snapshot.activations;
        this._deactivations = snapshot.deactivations;
        this._middleware = snapshot.middleware;
        this._moduleActivationStore = snapshot.moduleActivationStore;
    };
    Container.prototype.createChild = function (containerOptions) {
        var child = new Container(containerOptions || this.options);
        child.parent = this;
        return child;
    };
    Container.prototype.applyMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var initial = (this._middleware) ? this._middleware : this._planAndResolve();
        this._middleware = middlewares.reduce(function (prev, curr) { return curr(prev); }, initial);
    };
    Container.prototype.applyCustomMetadataReader = function (metadataReader) {
        this._metadataReader = metadataReader;
    };
    Container.prototype.get = function (serviceIdentifier) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, false);
        return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAsync = function (serviceIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            var getArgs;
            return __generator(this, function (_a) {
                getArgs = this._getNotAllArgs(serviceIdentifier, false);
                return [2, this._get(getArgs)];
            });
        });
    };
    Container.prototype.getTagged = function (serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
        return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getTaggedAsync = function (serviceIdentifier, key, value) {
        return __awaiter(this, void 0, void 0, function () {
            var getArgs;
            return __generator(this, function (_a) {
                getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
                return [2, this._get(getArgs)];
            });
        });
    };
    Container.prototype.getNamed = function (serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);
    };
    Container.prototype.getNamedAsync = function (serviceIdentifier, named) {
        return this.getTaggedAsync(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);
    };
    Container.prototype.getAll = function (serviceIdentifier) {
        var getArgs = this._getAllArgs(serviceIdentifier);
        return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAllAsync = function (serviceIdentifier) {
        var getArgs = this._getAllArgs(serviceIdentifier);
        return this._getAll(getArgs);
    };
    Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
        return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAllTaggedAsync = function (serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
        return this._getAll(getArgs);
    };
    Container.prototype.getAllNamed = function (serviceIdentifier, named) {
        return this.getAllTagged(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);
    };
    Container.prototype.getAllNamedAsync = function (serviceIdentifier, named) {
        return this.getAllTaggedAsync(serviceIdentifier, _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.NAMED_TAG, named);
    };
    Container.prototype.resolve = function (constructorFunction) {
        var isBound = this.isBound(constructorFunction);
        if (!isBound) {
            this.bind(constructorFunction).toSelf();
        }
        var resolved = this.get(constructorFunction);
        if (!isBound) {
            this.unbind(constructorFunction);
        }
        return resolved;
    };
    Container.prototype._preDestroy = function (constructor, instance) {
        var _a, _b;
        if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.PRE_DESTROY, constructor)) {
            var data = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_9__.PRE_DESTROY, constructor);
            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    };
    Container.prototype._removeModuleHandlers = function (moduleId) {
        var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
        this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
        this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
    };
    Container.prototype._removeModuleBindings = function (moduleId) {
        return this._bindingDictionary.removeByCondition(function (binding) { return binding.moduleId === moduleId; });
    };
    Container.prototype._deactivate = function (binding, instance) {
        var _this = this;
        var constructor = Object.getPrototypeOf(instance).constructor;
        try {
            if (this._deactivations.hasKey(binding.serviceIdentifier)) {
                var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
                if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {
                    return this._handleDeactivationError(result.then(function () { return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor); }), constructor);
                }
            }
            var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(propagateDeactivationResult)) {
                return this._handleDeactivationError(propagateDeactivationResult, constructor);
            }
        }
        catch (ex) {
            if (ex instanceof Error) {
                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ON_DEACTIVATION_ERROR(constructor.name, ex.message));
            }
        }
    };
    Container.prototype._handleDeactivationError = function (asyncResult, constructor) {
        return __awaiter(this, void 0, void 0, function () {
            var ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4, asyncResult];
                    case 1:
                        _a.sent();
                        return [3, 3];
                    case 2:
                        ex_1 = _a.sent();
                        if (ex_1 instanceof Error) {
                            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
                        }
                        return [3, 3];
                    case 3: return [2];
                }
            });
        });
    };
    Container.prototype._deactivateContainer = function (instance, deactivationsIterator) {
        var _this = this;
        var deactivation = deactivationsIterator.next();
        while (deactivation.value) {
            var result = deactivation.value(instance);
            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {
                return result.then(function () {
                    return _this._deactivateContainerAsync(instance, deactivationsIterator);
                });
            }
            deactivation = deactivationsIterator.next();
        }
    };
    Container.prototype._deactivateContainerAsync = function (instance, deactivationsIterator) {
        return __awaiter(this, void 0, void 0, function () {
            var deactivation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deactivation = deactivationsIterator.next();
                        _a.label = 1;
                    case 1:
                        if (!deactivation.value) return [3, 3];
                        return [4, deactivation.value(instance)];
                    case 2:
                        _a.sent();
                        deactivation = deactivationsIterator.next();
                        return [3, 1];
                    case 3: return [2];
                }
            });
        });
    };
    Container.prototype._getContainerModuleHelpersFactory = function () {
        var _this = this;
        var setModuleId = function (bindingToSyntax, moduleId) {
            bindingToSyntax._binding.moduleId = moduleId;
        };
        var getBindFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var bindingToSyntax = _this.bind(serviceIdentifier);
                setModuleId(bindingToSyntax, moduleId);
                return bindingToSyntax;
            };
        };
        var getUnbindFunction = function () {
            return function (serviceIdentifier) {
                return _this.unbind(serviceIdentifier);
            };
        };
        var getUnbindAsyncFunction = function () {
            return function (serviceIdentifier) {
                return _this.unbindAsync(serviceIdentifier);
            };
        };
        var getIsboundFunction = function () {
            return function (serviceIdentifier) {
                return _this.isBound(serviceIdentifier);
            };
        };
        var getRebindFunction = function (moduleId) {
            return function (serviceIdentifier) {
                var bindingToSyntax = _this.rebind(serviceIdentifier);
                setModuleId(bindingToSyntax, moduleId);
                return bindingToSyntax;
            };
        };
        var getOnActivationFunction = function (moduleId) {
            return function (serviceIdentifier, onActivation) {
                _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
                _this.onActivation(serviceIdentifier, onActivation);
            };
        };
        var getOnDeactivationFunction = function (moduleId) {
            return function (serviceIdentifier, onDeactivation) {
                _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
                _this.onDeactivation(serviceIdentifier, onDeactivation);
            };
        };
        return function (mId) { return ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            onActivationFunction: getOnActivationFunction(mId),
            onDeactivationFunction: getOnDeactivationFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(),
            unbindAsyncFunction: getUnbindAsyncFunction()
        }); };
    };
    Container.prototype._getAll = function (getArgs) {
        return Promise.all(this._get(getArgs));
    };
    Container.prototype._get = function (getArgs) {
        var planAndResolveArgs = __assign(__assign({}, getArgs), { contextInterceptor: function (context) { return context; }, targetType: _constants_literal_types__WEBPACK_IMPORTED_MODULE_1__.TargetTypeEnum.Variable });
        if (this._middleware) {
            var middlewareResult = this._middleware(planAndResolveArgs);
            if (middlewareResult === undefined || middlewareResult === null) {
                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.INVALID_MIDDLEWARE_RETURN);
            }
            return middlewareResult;
        }
        return this._planAndResolve()(planAndResolveArgs);
    };
    Container.prototype._getButThrowIfAsync = function (getArgs) {
        var result = this._get(getArgs);
        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromiseOrContainsPromise)(result)) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.LAZY_IN_SYNC(getArgs.serviceIdentifier));
        }
        return result;
    };
    Container.prototype._getAllArgs = function (serviceIdentifier) {
        var getAllArgs = {
            avoidConstraints: true,
            isMultiInject: true,
            serviceIdentifier: serviceIdentifier,
        };
        return getAllArgs;
    };
    Container.prototype._getNotAllArgs = function (serviceIdentifier, isMultiInject, key, value) {
        var getNotAllArgs = {
            avoidConstraints: false,
            isMultiInject: isMultiInject,
            serviceIdentifier: serviceIdentifier,
            key: key,
            value: value,
        };
        return getNotAllArgs;
    };
    Container.prototype._planAndResolve = function () {
        var _this = this;
        return function (args) {
            var context = (0,_planning_planner__WEBPACK_IMPORTED_MODULE_6__.plan)(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
            context = args.contextInterceptor(context);
            var result = (0,_resolution_resolver__WEBPACK_IMPORTED_MODULE_12__.resolve)(context);
            return result;
        };
    };
    Container.prototype._deactivateIfSingleton = function (binding) {
        var _this = this;
        if (!binding.activated) {
            return;
        }
        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(binding.cache)) {
            return binding.cache.then(function (resolved) { return _this._deactivate(binding, resolved); });
        }
        return this._deactivate(binding, binding.cache);
    };
    Container.prototype._deactivateSingletons = function (bindings) {
        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
            var binding = bindings_1[_i];
            var result = this._deactivateIfSingleton(binding);
            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {
                throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.ASYNC_UNBIND_REQUIRED);
            }
        }
    };
    Container.prototype._deactivateSingletonsAsync = function (bindings) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, Promise.all(bindings.map(function (b) { return _this._deactivateIfSingleton(b); }))];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function (binding, instance, constructor) {
        if (this.parent) {
            return this._deactivate.bind(this.parent)(binding, instance);
        }
        else {
            return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
        }
    };
    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function (binding, instance, constructor) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.parent) return [3, 2];
                        return [4, this._deactivate.bind(this.parent)(binding, instance)];
                    case 1:
                        _a.sent();
                        return [3, 4];
                    case 2: return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2];
                }
            });
        });
    };
    Container.prototype._removeServiceFromDictionary = function (serviceIdentifier) {
        try {
            this._bindingDictionary.remove(serviceIdentifier);
        }
        catch (e) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_UNBIND + " " + (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_13__.getServiceIdentifierAsString)(serviceIdentifier));
        }
    };
    Container.prototype._bindingDeactivationAndPreDestroy = function (binding, instance, constructor) {
        var _this = this;
        if (typeof binding.onDeactivation === 'function') {
            var result = binding.onDeactivation(instance);
            if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_11__.isPromise)(result)) {
                return result.then(function () { return _this._preDestroy(constructor, instance); });
            }
        }
        return this._preDestroy(constructor, instance);
    };
    Container.prototype._bindingDeactivationAndPreDestroyAsync = function (binding, instance, constructor) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(typeof binding.onDeactivation === 'function')) return [3, 2];
                        return [4, binding.onDeactivation(instance)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4, this._preDestroy(constructor, instance)];
                    case 3:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    return Container;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/container/container_module.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/inversify/es/container/container_module.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncContainerModule: () => (/* binding */ AsyncContainerModule),
/* harmony export */   ContainerModule: () => (/* binding */ ContainerModule)
/* harmony export */ });
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");

var ContainerModule = (function () {
    function ContainerModule(registry) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.registry = registry;
    }
    return ContainerModule;
}());

var AsyncContainerModule = (function () {
    function AsyncContainerModule(registry) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.registry = registry;
    }
    return AsyncContainerModule;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/container/container_snapshot.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/inversify/es/container/container_snapshot.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContainerSnapshot: () => (/* binding */ ContainerSnapshot)
/* harmony export */ });
var ContainerSnapshot = (function () {
    function ContainerSnapshot() {
    }
    ContainerSnapshot.of = function (bindings, middleware, activations, deactivations, moduleActivationStore) {
        var snapshot = new ContainerSnapshot();
        snapshot.bindings = bindings;
        snapshot.middleware = middleware;
        snapshot.deactivations = deactivations;
        snapshot.activations = activations;
        snapshot.moduleActivationStore = moduleActivationStore;
        return snapshot;
    };
    return ContainerSnapshot;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/container/lookup.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/container/lookup.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lookup: () => (/* binding */ Lookup)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _utils_clonable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/clonable */ "../../node_modules/inversify/es/utils/clonable.js");


var Lookup = (function () {
    function Lookup() {
        this._map = new Map();
    }
    Lookup.prototype.getMap = function () {
        return this._map;
    };
    Lookup.prototype.add = function (serviceIdentifier, value) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);
        }
        if (value === null || value === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== undefined) {
            entry.push(value);
        }
        else {
            this._map.set(serviceIdentifier, [value]);
        }
    };
    Lookup.prototype.get = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== undefined) {
            return entry;
        }
        else {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.KEY_NOT_FOUND);
        }
    };
    Lookup.prototype.remove = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);
        }
        if (!this._map.delete(serviceIdentifier)) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.KEY_NOT_FOUND);
        }
    };
    Lookup.prototype.removeIntersection = function (lookup) {
        var _this = this;
        this.traverse(function (serviceIdentifier, value) {
            var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : undefined;
            if (lookupActivations !== undefined) {
                var filteredValues = value.filter(function (lookupValue) {
                    return !lookupActivations.some(function (moduleActivation) { return lookupValue === moduleActivation; });
                });
                _this._setValue(serviceIdentifier, filteredValues);
            }
        });
    };
    Lookup.prototype.removeByCondition = function (condition) {
        var _this = this;
        var removals = [];
        this._map.forEach(function (entries, key) {
            var updatedEntries = [];
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                var remove = condition(entry);
                if (remove) {
                    removals.push(entry);
                }
                else {
                    updatedEntries.push(entry);
                }
            }
            _this._setValue(key, updatedEntries);
        });
        return removals;
    };
    Lookup.prototype.hasKey = function (serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === undefined) {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.NULL_ARGUMENT);
        }
        return this._map.has(serviceIdentifier);
    };
    Lookup.prototype.clone = function () {
        var copy = new Lookup();
        this._map.forEach(function (value, key) {
            value.forEach(function (b) { return copy.add(key, (0,_utils_clonable__WEBPACK_IMPORTED_MODULE_1__.isClonable)(b) ? b.clone() : b); });
        });
        return copy;
    };
    Lookup.prototype.traverse = function (func) {
        this._map.forEach(function (value, key) {
            func(key, value);
        });
    };
    Lookup.prototype._setValue = function (serviceIdentifier, value) {
        if (value.length > 0) {
            this._map.set(serviceIdentifier, value);
        }
        else {
            this._map.delete(serviceIdentifier);
        }
    };
    return Lookup;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/container/module_activation_store.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/inversify/es/container/module_activation_store.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModuleActivationStore: () => (/* binding */ ModuleActivationStore)
/* harmony export */ });
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lookup */ "../../node_modules/inversify/es/container/lookup.js");

var ModuleActivationStore = (function () {
    function ModuleActivationStore() {
        this._map = new Map();
    }
    ModuleActivationStore.prototype.remove = function (moduleId) {
        if (this._map.has(moduleId)) {
            var handlers = this._map.get(moduleId);
            this._map.delete(moduleId);
            return handlers;
        }
        return this._getEmptyHandlersStore();
    };
    ModuleActivationStore.prototype.addDeactivation = function (moduleId, serviceIdentifier, onDeactivation) {
        this._getModuleActivationHandlers(moduleId)
            .onDeactivations.add(serviceIdentifier, onDeactivation);
    };
    ModuleActivationStore.prototype.addActivation = function (moduleId, serviceIdentifier, onActivation) {
        this._getModuleActivationHandlers(moduleId)
            .onActivations.add(serviceIdentifier, onActivation);
    };
    ModuleActivationStore.prototype.clone = function () {
        var clone = new ModuleActivationStore();
        this._map.forEach(function (handlersStore, moduleId) {
            clone._map.set(moduleId, {
                onActivations: handlersStore.onActivations.clone(),
                onDeactivations: handlersStore.onDeactivations.clone(),
            });
        });
        return clone;
    };
    ModuleActivationStore.prototype._getModuleActivationHandlers = function (moduleId) {
        var moduleActivationHandlers = this._map.get(moduleId);
        if (moduleActivationHandlers === undefined) {
            moduleActivationHandlers = this._getEmptyHandlersStore();
            this._map.set(moduleId, moduleActivationHandlers);
        }
        return moduleActivationHandlers;
    };
    ModuleActivationStore.prototype._getEmptyHandlersStore = function () {
        var handlersStore = {
            onActivations: new _lookup__WEBPACK_IMPORTED_MODULE_0__.Lookup(),
            onDeactivations: new _lookup__WEBPACK_IMPORTED_MODULE_0__.Lookup()
        };
        return handlersStore;
    };
    return ModuleActivationStore;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/interfaces/interfaces.js":
/*!****************************************************************!*\
  !*** ../../node_modules/inversify/es/interfaces/interfaces.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interfaces: () => (/* binding */ interfaces)
/* harmony export */ });
var interfaces;
(function (interfaces) {
    ;
})(interfaces || (interfaces = {}));



/***/ }),

/***/ "../../node_modules/inversify/es/inversify.js":
/*!****************************************************!*\
  !*** ../../node_modules/inversify/es/inversify.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncContainerModule: () => (/* reexport safe */ _container_container_module__WEBPACK_IMPORTED_MODULE_3__.AsyncContainerModule),
/* harmony export */   BindingScopeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.BindingScopeEnum),
/* harmony export */   BindingTypeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.BindingTypeEnum),
/* harmony export */   Container: () => (/* reexport safe */ _container_container__WEBPACK_IMPORTED_MODULE_1__.Container),
/* harmony export */   ContainerModule: () => (/* reexport safe */ _container_container_module__WEBPACK_IMPORTED_MODULE_3__.ContainerModule),
/* harmony export */   LazyServiceIdentifer: () => (/* reexport safe */ _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__.LazyServiceIdentifier),
/* harmony export */   LazyServiceIdentifier: () => (/* reexport safe */ _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__.LazyServiceIdentifier),
/* harmony export */   METADATA_KEY: () => (/* binding */ METADATA_KEY),
/* harmony export */   MetadataReader: () => (/* reexport safe */ _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_16__.MetadataReader),
/* harmony export */   TargetTypeEnum: () => (/* reexport safe */ _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__.TargetTypeEnum),
/* harmony export */   createTaggedDecorator: () => (/* reexport safe */ _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__.createTaggedDecorator),
/* harmony export */   decorate: () => (/* reexport safe */ _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__.decorate),
/* harmony export */   getServiceIdentifierAsString: () => (/* reexport safe */ _utils_serialization__WEBPACK_IMPORTED_MODULE_20__.getServiceIdentifierAsString),
/* harmony export */   id: () => (/* reexport safe */ _utils_id__WEBPACK_IMPORTED_MODULE_17__.id),
/* harmony export */   inject: () => (/* reexport safe */ _annotation_inject__WEBPACK_IMPORTED_MODULE_8__.inject),
/* harmony export */   injectable: () => (/* reexport safe */ _annotation_injectable__WEBPACK_IMPORTED_MODULE_5__.injectable),
/* harmony export */   interfaces: () => (/* reexport safe */ _interfaces_interfaces__WEBPACK_IMPORTED_MODULE_18__.interfaces),
/* harmony export */   multiBindToService: () => (/* reexport safe */ _utils_binding_utils__WEBPACK_IMPORTED_MODULE_21__.multiBindToService),
/* harmony export */   multiInject: () => (/* reexport safe */ _annotation_multi_inject__WEBPACK_IMPORTED_MODULE_12__.multiInject),
/* harmony export */   named: () => (/* reexport safe */ _annotation_named__WEBPACK_IMPORTED_MODULE_7__.named),
/* harmony export */   namedConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.namedConstraint),
/* harmony export */   optional: () => (/* reexport safe */ _annotation_optional__WEBPACK_IMPORTED_MODULE_10__.optional),
/* harmony export */   postConstruct: () => (/* reexport safe */ _annotation_post_construct__WEBPACK_IMPORTED_MODULE_14__.postConstruct),
/* harmony export */   preDestroy: () => (/* reexport safe */ _annotation_pre_destroy__WEBPACK_IMPORTED_MODULE_15__.preDestroy),
/* harmony export */   tagged: () => (/* reexport safe */ _annotation_tagged__WEBPACK_IMPORTED_MODULE_6__.tagged),
/* harmony export */   taggedConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.taggedConstraint),
/* harmony export */   targetName: () => (/* reexport safe */ _annotation_target_name__WEBPACK_IMPORTED_MODULE_13__.targetName),
/* harmony export */   traverseAncerstors: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.traverseAncerstors),
/* harmony export */   typeConstraint: () => (/* reexport safe */ _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__.typeConstraint),
/* harmony export */   unmanaged: () => (/* reexport safe */ _annotation_unmanaged__WEBPACK_IMPORTED_MODULE_11__.unmanaged)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _container_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./container/container */ "../../node_modules/inversify/es/container/container.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _container_container_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./container/container_module */ "../../node_modules/inversify/es/container/container_module.js");
/* harmony import */ var _annotation_decorator_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./annotation/decorator_utils */ "../../node_modules/inversify/es/annotation/decorator_utils.js");
/* harmony import */ var _annotation_injectable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./annotation/injectable */ "../../node_modules/inversify/es/annotation/injectable.js");
/* harmony import */ var _annotation_tagged__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./annotation/tagged */ "../../node_modules/inversify/es/annotation/tagged.js");
/* harmony import */ var _annotation_named__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./annotation/named */ "../../node_modules/inversify/es/annotation/named.js");
/* harmony import */ var _annotation_inject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./annotation/inject */ "../../node_modules/inversify/es/annotation/inject.js");
/* harmony import */ var _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./annotation/lazy_service_identifier */ "../../node_modules/inversify/es/annotation/lazy_service_identifier.js");
/* harmony import */ var _annotation_optional__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./annotation/optional */ "../../node_modules/inversify/es/annotation/optional.js");
/* harmony import */ var _annotation_unmanaged__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./annotation/unmanaged */ "../../node_modules/inversify/es/annotation/unmanaged.js");
/* harmony import */ var _annotation_multi_inject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./annotation/multi_inject */ "../../node_modules/inversify/es/annotation/multi_inject.js");
/* harmony import */ var _annotation_target_name__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./annotation/target_name */ "../../node_modules/inversify/es/annotation/target_name.js");
/* harmony import */ var _annotation_post_construct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./annotation/post_construct */ "../../node_modules/inversify/es/annotation/post_construct.js");
/* harmony import */ var _annotation_pre_destroy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./annotation/pre_destroy */ "../../node_modules/inversify/es/annotation/pre_destroy.js");
/* harmony import */ var _planning_metadata_reader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./planning/metadata_reader */ "../../node_modules/inversify/es/planning/metadata_reader.js");
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/id */ "../../node_modules/inversify/es/utils/id.js");
/* harmony import */ var _interfaces_interfaces__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interfaces/interfaces */ "../../node_modules/inversify/es/interfaces/interfaces.js");
/* harmony import */ var _syntax_constraint_helpers__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./syntax/constraint_helpers */ "../../node_modules/inversify/es/syntax/constraint_helpers.js");
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/serialization */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _utils_binding_utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/binding_utils */ "../../node_modules/inversify/es/utils/binding_utils.js");

var METADATA_KEY = _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__;

























/***/ }),

/***/ "../../node_modules/inversify/es/planning/context.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/planning/context.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Context: () => (/* binding */ Context)
/* harmony export */ });
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");

var Context = (function () {
    function Context(container) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.container = container;
    }
    Context.prototype.addPlan = function (plan) {
        this.plan = plan;
    };
    Context.prototype.setCurrentRequest = function (currentRequest) {
        this.currentRequest = currentRequest;
    };
    return Context;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/metadata.js":
/*!************************************************************!*\
  !*** ../../node_modules/inversify/es/planning/metadata.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Metadata: () => (/* binding */ Metadata)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");

var Metadata = (function () {
    function Metadata(key, value) {
        this.key = key;
        this.value = value;
    }
    Metadata.prototype.toString = function () {
        if (this.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.NAMED_TAG) {
            return "named: " + String(this.value).toString() + " ";
        }
        else {
            return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
        }
    };
    return Metadata;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/metadata_reader.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/es/planning/metadata_reader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetadataReader: () => (/* binding */ MetadataReader)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");

var MetadataReader = (function () {
    function MetadataReader() {
    }
    MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
        var compilerGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.PARAM_TYPES, constructorFunc);
        var userGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.TAGGED, constructorFunc);
        return {
            compilerGeneratedMetadata: compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata || {}
        };
    };
    MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
        var userGeneratedMetadata = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.TAGGED_PROP, constructorFunc) || [];
        return userGeneratedMetadata;
    };
    return MetadataReader;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/plan.js":
/*!********************************************************!*\
  !*** ../../node_modules/inversify/es/planning/plan.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Plan: () => (/* binding */ Plan)
/* harmony export */ });
var Plan = (function () {
    function Plan(parentContext, rootRequest) {
        this.parentContext = parentContext;
        this.rootRequest = rootRequest;
    }
    return Plan;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/planner.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/planning/planner.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMockRequest: () => (/* binding */ createMockRequest),
/* harmony export */   getBindingDictionary: () => (/* binding */ getBindingDictionary),
/* harmony export */   plan: () => (/* binding */ plan)
/* harmony export */ });
/* harmony import */ var _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bindings/binding_count */ "../../node_modules/inversify/es/bindings/binding_count.js");
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _utils_exceptions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/exceptions */ "../../node_modules/inversify/es/utils/exceptions.js");
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reflection_utils */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./context */ "../../node_modules/inversify/es/planning/context.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _plan__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plan */ "../../node_modules/inversify/es/planning/plan.js");
/* harmony import */ var _reflection_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./reflection_utils */ "../../node_modules/inversify/es/planning/reflection_utils.js");
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./request */ "../../node_modules/inversify/es/planning/request.js");
/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./target */ "../../node_modules/inversify/es/planning/target.js");












function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
}
function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
    var metadataKey = isMultiInject ? _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.MULTI_INJECT_TAG : _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_0__.INJECT_TAG;
    var injectMetadata = new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(metadataKey, serviceIdentifier);
    var target = new _target__WEBPACK_IMPORTED_MODULE_2__.Target(targetType, name, serviceIdentifier, injectMetadata);
    if (key !== undefined) {
        var tagMetadata = new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(key, value);
        target.metadata.push(tagMetadata);
    }
    return target;
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier);
    var activeBindings = [];
    if (bindings.length === _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.NoBindingsAvailable &&
        context.container.options.autoBindInjectable &&
        typeof target.serviceIdentifier === 'function' &&
        metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
        context.container.bind(target.serviceIdentifier).toSelf();
        bindings = getBindings(context.container, target.serviceIdentifier);
    }
    if (!avoidConstraints) {
        activeBindings = bindings.filter(function (binding) {
            var request = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
            return binding.constraint(request);
        });
    }
    else {
        activeBindings = bindings;
    }
    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
    return activeBindings;
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
    switch (bindings.length) {
        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.NoBindingsAvailable:
            if (target.isOptional()) {
                return bindings;
            }
            else {
                var serviceIdentifierString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getServiceIdentifierAsString)(serviceIdentifier);
                var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.NOT_REGISTERED;
                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listMetadataForTarget)(serviceIdentifierString, target);
                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
                throw new Error(msg);
            }
        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.OnlyOneBindingAvailable:
            return bindings;
        case _bindings_binding_count__WEBPACK_IMPORTED_MODULE_3__.BindingCount.MultipleBindingsAvailable:
        default:
            if (!target.isArray()) {
                var serviceIdentifierString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getServiceIdentifierAsString)(serviceIdentifier);
                var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.AMBIGUOUS_MATCH + " " + serviceIdentifierString;
                msg += (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
                throw new Error(msg);
            }
            else {
                return bindings;
            }
    }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings;
    var childRequest;
    if (parentRequest === null) {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
        childRequest = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(serviceIdentifier, context, null, activeBindings, target);
        var thePlan = new _plan__WEBPACK_IMPORTED_MODULE_7__.Plan(context, childRequest);
        context.addPlan(thePlan);
    }
    else {
        activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
        childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    }
    activeBindings.forEach(function (binding) {
        var subChildRequest = null;
        if (target.isArray()) {
            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
        }
        else {
            if (binding.cache) {
                return;
            }
            subChildRequest = childRequest;
        }
        if (binding.type === _constants_literal_types__WEBPACK_IMPORTED_MODULE_8__.BindingTypeEnum.Instance && binding.implementationType !== null) {
            var dependencies = (0,_reflection_utils__WEBPACK_IMPORTED_MODULE_9__.getDependencies)(metadataReader, binding.implementationType);
            if (!context.container.options.skipBaseClassChecks) {
                var baseClassDependencyCount = (0,_reflection_utils__WEBPACK_IMPORTED_MODULE_9__.getBaseClassDependencyCount)(metadataReader, binding.implementationType);
                if (dependencies.length < baseClassDependencyCount) {
                    var error = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_6__.ARGUMENTS_LENGTH_MISMATCH((0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.getFunctionName)(binding.implementationType));
                    throw new Error(error);
                }
            }
            dependencies.forEach(function (dependency) {
                _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
            });
        }
    });
}
function getBindings(container, serviceIdentifier) {
    var bindings = [];
    var bindingDictionary = getBindingDictionary(container);
    if (bindingDictionary.hasKey(serviceIdentifier)) {
        bindings = bindingDictionary.get(serviceIdentifier);
    }
    else if (container.parent !== null) {
        bindings = getBindings(container.parent, serviceIdentifier);
    }
    return bindings;
}
function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    if (avoidConstraints === void 0) { avoidConstraints = false; }
    var context = new _context__WEBPACK_IMPORTED_MODULE_10__.Context(container);
    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, '', key, value);
    try {
        _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
        return context;
    }
    catch (error) {
        if ((0,_utils_exceptions__WEBPACK_IMPORTED_MODULE_11__.isStackOverflowExeption)(error)) {
            (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_5__.circularDependencyToException)(context.plan.rootRequest);
        }
        throw error;
    }
}
function createMockRequest(container, serviceIdentifier, key, value) {
    var target = new _target__WEBPACK_IMPORTED_MODULE_2__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_8__.TargetTypeEnum.Variable, '', serviceIdentifier, new _metadata__WEBPACK_IMPORTED_MODULE_1__.Metadata(key, value));
    var context = new _context__WEBPACK_IMPORTED_MODULE_10__.Context(container);
    var request = new _request__WEBPACK_IMPORTED_MODULE_4__.Request(serviceIdentifier, context, null, [], target);
    return request;
}



/***/ }),

/***/ "../../node_modules/inversify/es/planning/queryable_string.js":
/*!********************************************************************!*\
  !*** ../../node_modules/inversify/es/planning/queryable_string.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QueryableString: () => (/* binding */ QueryableString)
/* harmony export */ });
var QueryableString = (function () {
    function QueryableString(str) {
        this.str = str;
    }
    QueryableString.prototype.startsWith = function (searchString) {
        return this.str.indexOf(searchString) === 0;
    };
    QueryableString.prototype.endsWith = function (searchString) {
        var reverseString = '';
        var reverseSearchString = searchString.split('').reverse().join('');
        reverseString = this.str.split('').reverse().join('');
        return this.startsWith.call({ str: reverseString }, reverseSearchString);
    };
    QueryableString.prototype.contains = function (searchString) {
        return (this.str.indexOf(searchString) !== -1);
    };
    QueryableString.prototype.equals = function (compareString) {
        return this.str === compareString;
    };
    QueryableString.prototype.value = function () {
        return this.str;
    };
    return QueryableString;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/reflection_utils.js":
/*!********************************************************************!*\
  !*** ../../node_modules/inversify/es/planning/reflection_utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBaseClassDependencyCount: () => (/* binding */ getBaseClassDependencyCount),
/* harmony export */   getDependencies: () => (/* binding */ getDependencies),
/* harmony export */   getFunctionName: () => (/* reexport safe */ _utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)
/* harmony export */ });
/* harmony import */ var _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../annotation/lazy_service_identifier */ "../../node_modules/inversify/es/annotation/lazy_service_identifier.js");
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/serialization */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _target__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./target */ "../../node_modules/inversify/es/planning/target.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};






function getDependencies(metadataReader, func) {
    var constructorName = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(func);
    return getTargets(metadataReader, constructorName, func, false);
}
function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func);
    var serviceIdentifiers = metadata.compilerGeneratedMetadata;
    if (serviceIdentifiers === undefined) {
        var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
        throw new Error(msg);
    }
    var constructorArgsMetadata = metadata.userGeneratedMetadata;
    var keys = Object.keys(constructorArgsMetadata);
    var hasUserDeclaredUnknownInjections = (func.length === 0 && keys.length > 0);
    var hasOptionalParameters = keys.length > func.length;
    var iterations = (hasUserDeclaredUnknownInjections || hasOptionalParameters) ? keys.length : func.length;
    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
    var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
    var targets = __spreadArray(__spreadArray([], constructorTargets, true), propertyTargets, true);
    return targets;
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [];
    var metadata = formatTargetMetadata(targetMetadata);
    var isManaged = metadata.unmanaged !== true;
    var serviceIdentifier = serviceIdentifiers[index];
    var injectIdentifier = metadata.inject || metadata.multiInject;
    serviceIdentifier = (injectIdentifier ? injectIdentifier : serviceIdentifier);
    if (serviceIdentifier instanceof _annotation_lazy_service_identifier__WEBPACK_IMPORTED_MODULE_2__.LazyServiceIdentifier) {
        serviceIdentifier = serviceIdentifier.unwrap();
    }
    if (isManaged) {
        var isObject = serviceIdentifier === Object;
        var isFunction = serviceIdentifier === Function;
        var isUndefined = serviceIdentifier === undefined;
        var isUnknownType = isObject || isFunction || isUndefined;
        if (!isBaseClass && isUnknownType) {
            var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
            throw new Error(msg);
        }
        var target = new _target__WEBPACK_IMPORTED_MODULE_3__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_4__.TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
        target.metadata = targetMetadata;
        return target;
    }
    return null;
}
function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
    var targets = [];
    for (var i = 0; i < iterations; i++) {
        var index = i;
        var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
        if (target !== null) {
            targets.push(target);
        }
    }
    return targets;
}
function _getServiceIdentifierForProperty(inject, multiInject, propertyName, className) {
    var serviceIdentifier = (inject || multiInject);
    if (serviceIdentifier === undefined) {
        var msg = _constants_error_msgs__WEBPACK_IMPORTED_MODULE_1__.MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
        throw new Error(msg);
    }
    return serviceIdentifier;
}
function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
    var targets = [];
    var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
    var stringKeys = Object.keys(classPropsMetadata);
    var keys = stringKeys.concat(symbolKeys);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        var targetMetadata = classPropsMetadata[key];
        var metadata = formatTargetMetadata(targetMetadata);
        var identifier = metadata.targetName || key;
        var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);
        var target = new _target__WEBPACK_IMPORTED_MODULE_3__.Target(_constants_literal_types__WEBPACK_IMPORTED_MODULE_4__.TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
        target.metadata = targetMetadata;
        targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
        var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
        targets = __spreadArray(__spreadArray([], targets, true), baseTargets, true);
    }
    return targets;
}
function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
    if (baseConstructor !== Object) {
        var baseConstructorName = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(baseConstructor);
        var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
        var metadata = targets.map(function (t) { return t.metadata.filter(function (m) { return m.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.UNMANAGED_TAG; }); });
        var unmanagedCount = [].concat.apply([], metadata).length;
        var dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
            return dependencyCount;
        }
        else {
            return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
    }
    else {
        return 0;
    }
}
function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    targetMetadata.forEach(function (m) {
        targetMetadataMap[m.key.toString()] = m.value;
    });
    return {
        inject: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.INJECT_TAG],
        multiInject: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.MULTI_INJECT_TAG],
        targetName: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.NAME_TAG],
        unmanaged: targetMetadataMap[_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_5__.UNMANAGED_TAG]
    };
}



/***/ }),

/***/ "../../node_modules/inversify/es/planning/request.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/planning/request.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Request: () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");

var Request = (function () {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.serviceIdentifier = serviceIdentifier;
        this.parentContext = parentContext;
        this.parentRequest = parentRequest;
        this.target = target;
        this.childRequests = [];
        this.bindings = (Array.isArray(bindings) ? bindings : [bindings]);
        this.requestScope = parentRequest === null
            ? new Map()
            : null;
    }
    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
        var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
        this.childRequests.push(child);
        return child;
    };
    return Request;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/planning/target.js":
/*!**********************************************************!*\
  !*** ../../node_modules/inversify/es/planning/target.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Target: () => (/* binding */ Target)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _utils_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/id */ "../../node_modules/inversify/es/utils/id.js");
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/serialization */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metadata */ "../../node_modules/inversify/es/planning/metadata.js");
/* harmony import */ var _queryable_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queryable_string */ "../../node_modules/inversify/es/planning/queryable_string.js");





var Target = (function () {
    function Target(type, identifier, serviceIdentifier, namedOrTagged) {
        this.id = (0,_utils_id__WEBPACK_IMPORTED_MODULE_0__.id)();
        this.type = type;
        this.serviceIdentifier = serviceIdentifier;
        var queryableName = typeof identifier === 'symbol' ? (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_1__.getSymbolDescription)(identifier) : identifier;
        this.name = new _queryable_string__WEBPACK_IMPORTED_MODULE_2__.QueryableString(queryableName || '');
        this.identifier = identifier;
        this.metadata = new Array();
        var metadataItem = null;
        if (typeof namedOrTagged === 'string') {
            metadataItem = new _metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG, namedOrTagged);
        }
        else if (namedOrTagged instanceof _metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata) {
            metadataItem = namedOrTagged;
        }
        if (metadataItem !== null) {
            this.metadata.push(metadataItem);
        }
    }
    Target.prototype.hasTag = function (key) {
        for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
            var m = _a[_i];
            if (m.key === key) {
                return true;
            }
        }
        return false;
    };
    Target.prototype.isArray = function () {
        return this.hasTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.MULTI_INJECT_TAG);
    };
    Target.prototype.matchesArray = function (name) {
        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.MULTI_INJECT_TAG)(name);
    };
    Target.prototype.isNamed = function () {
        return this.hasTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG);
    };
    Target.prototype.isTagged = function () {
        return this.metadata.some(function (metadata) { return _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });
    };
    Target.prototype.isOptional = function () {
        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.OPTIONAL_TAG)(true);
    };
    Target.prototype.getNamedTag = function () {
        if (this.isNamed()) {
            return this.metadata.filter(function (m) { return m.key === _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG; })[0];
        }
        return null;
    };
    Target.prototype.getCustomTags = function () {
        if (this.isTagged()) {
            return this.metadata.filter(function (metadata) { return _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });
        }
        else {
            return null;
        }
    };
    Target.prototype.matchesNamedTag = function (name) {
        return this.matchesTag(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_4__.NAMED_TAG)(name);
    };
    Target.prototype.matchesTag = function (key) {
        var _this = this;
        return function (value) {
            for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
                var m = _a[_i];
                if (m.key === key && m.value === value) {
                    return true;
                }
            }
            return false;
        };
    };
    return Target;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/resolution/instantiation.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/es/resolution/instantiation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveInstance: () => (/* binding */ resolveInstance)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/async */ "../../node_modules/inversify/es/utils/async.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




function _resolveRequests(childRequests, resolveRequest) {
    return childRequests.reduce(function (resolvedRequests, childRequest) {
        var injection = resolveRequest(childRequest);
        var targetType = childRequest.target.type;
        if (targetType === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.TargetTypeEnum.ConstructorArgument) {
            resolvedRequests.constructorInjections.push(injection);
        }
        else {
            resolvedRequests.propertyRequests.push(childRequest);
            resolvedRequests.propertyInjections.push(injection);
        }
        if (!resolvedRequests.isAsync) {
            resolvedRequests.isAsync = (0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromiseOrContainsPromise)(injection);
        }
        return resolvedRequests;
    }, { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false });
}
function _createInstance(constr, childRequests, resolveRequest) {
    var result;
    if (childRequests.length > 0) {
        var resolved = _resolveRequests(childRequests, resolveRequest);
        var createInstanceWithInjectionsArg = __assign(__assign({}, resolved), { constr: constr });
        if (resolved.isAsync) {
            result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
        }
        else {
            result = createInstanceWithInjections(createInstanceWithInjectionsArg);
        }
    }
    else {
        result = new constr();
    }
    return result;
}
function createInstanceWithInjections(args) {
    var _a;
    var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray([void 0], args.constructorInjections, false)))();
    args.propertyRequests.forEach(function (r, index) {
        var property = r.target.identifier;
        var injection = args.propertyInjections[index];
        if (!r.target.isOptional() || injection !== undefined) {
            instance[property] = injection;
        }
    });
    return instance;
}
function createInstanceWithInjectionsAsync(args) {
    return __awaiter(this, void 0, void 0, function () {
        var constructorInjections, propertyInjections;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, possiblyWaitInjections(args.constructorInjections)];
                case 1:
                    constructorInjections = _a.sent();
                    return [4, possiblyWaitInjections(args.propertyInjections)];
                case 2:
                    propertyInjections = _a.sent();
                    return [2, createInstanceWithInjections(__assign(__assign({}, args), { constructorInjections: constructorInjections, propertyInjections: propertyInjections }))];
            }
        });
    });
}
function possiblyWaitInjections(possiblePromiseinjections) {
    return __awaiter(this, void 0, void 0, function () {
        var injections, _i, possiblePromiseinjections_1, injection;
        return __generator(this, function (_a) {
            injections = [];
            for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {
                injection = possiblePromiseinjections_1[_i];
                if (Array.isArray(injection)) {
                    injections.push(Promise.all(injection));
                }
                else {
                    injections.push(injection);
                }
            }
            return [2, Promise.all(injections)];
        });
    });
}
function _getInstanceAfterPostConstruct(constr, result) {
    var postConstructResult = _postConstruct(constr, result);
    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(postConstructResult)) {
        return postConstructResult.then(function () { return result; });
    }
    else {
        return result;
    }
}
function _postConstruct(constr, instance) {
    var _a, _b;
    if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.POST_CONSTRUCT, constr)) {
        var data = Reflect.getMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.POST_CONSTRUCT, constr);
        try {
            return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.POST_CONSTRUCT_ERROR)(constr.name, e.message));
            }
        }
    }
}
function _validateInstanceResolution(binding, constr) {
    if (binding.scope !== _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) {
        _throwIfHandlingDeactivation(binding, constr);
    }
}
function _throwIfHandlingDeactivation(binding, constr) {
    var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request ?
        'request' :
        'transient') + " scope.";
    if (typeof binding.onDeactivation === 'function') {
        throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));
    }
    if (Reflect.hasMetadata(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_2__.PRE_DESTROY, constr)) {
        throw new Error((0,_constants_error_msgs__WEBPACK_IMPORTED_MODULE_3__.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));
    }
}
function resolveInstance(binding, constr, childRequests, resolveRequest) {
    _validateInstanceResolution(binding, constr);
    var result = _createInstance(constr, childRequests, resolveRequest);
    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(result)) {
        return result.then(function (resolvedResult) { return _getInstanceAfterPostConstruct(constr, resolvedResult); });
    }
    else {
        return _getInstanceAfterPostConstruct(constr, result);
    }
}



/***/ }),

/***/ "../../node_modules/inversify/es/resolution/resolver.js":
/*!**************************************************************!*\
  !*** ../../node_modules/inversify/es/resolution/resolver.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _planning_planner__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../planning/planner */ "../../node_modules/inversify/es/planning/planner.js");
/* harmony import */ var _scope_scope__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scope/scope */ "../../node_modules/inversify/es/scope/scope.js");
/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/async */ "../../node_modules/inversify/es/utils/async.js");
/* harmony import */ var _utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/binding_utils */ "../../node_modules/inversify/es/utils/binding_utils.js");
/* harmony import */ var _utils_exceptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/exceptions */ "../../node_modules/inversify/es/utils/exceptions.js");
/* harmony import */ var _instantiation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instantiation */ "../../node_modules/inversify/es/resolution/instantiation.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};








var _resolveRequest = function (requestScope) {
    return function (request) {
        request.parentContext.setCurrentRequest(request);
        var bindings = request.bindings;
        var childRequests = request.childRequests;
        var targetIsAnArray = request.target && request.target.isArray();
        var targetParentIsNotAnArray = !request.parentRequest ||
            !request.parentRequest.target ||
            !request.target ||
            !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
            return childRequests.map(function (childRequest) {
                var _f = _resolveRequest(requestScope);
                return _f(childRequest);
            });
        }
        else {
            if (request.target.isOptional() && bindings.length === 0) {
                return undefined;
            }
            var binding = bindings[0];
            return _resolveBinding(requestScope, request, binding);
        }
    };
};
var _resolveFactoryFromBinding = function (binding, context) {
    var factoryDetails = (0,_utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__.getFactoryDetails)(binding);
    return (0,_utils_exceptions__WEBPACK_IMPORTED_MODULE_1__.tryAndThrowErrorIfStackOverflow)(function () { return factoryDetails.factory.bind(binding)(context); }, function () { return new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString())); });
};
var _getResolvedFromBinding = function (requestScope, request, binding) {
    var result;
    var childRequests = request.childRequests;
    (0,_utils_binding_utils__WEBPACK_IMPORTED_MODULE_0__.ensureFullyBound)(binding);
    switch (binding.type) {
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.ConstantValue:
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Function:
            result = binding.cache;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Constructor:
            result = binding.implementationType;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_3__.BindingTypeEnum.Instance:
            result = (0,_instantiation__WEBPACK_IMPORTED_MODULE_4__.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
            break;
        default:
            result = _resolveFactoryFromBinding(binding, request.parentContext);
    }
    return result;
};
var _resolveInScope = function (requestScope, binding, resolveFromBinding) {
    var result = (0,_scope_scope__WEBPACK_IMPORTED_MODULE_5__.tryGetFromScope)(requestScope, binding);
    if (result !== null) {
        return result;
    }
    result = resolveFromBinding();
    (0,_scope_scope__WEBPACK_IMPORTED_MODULE_5__.saveToScope)(requestScope, binding, result);
    return result;
};
var _resolveBinding = function (requestScope, request, binding) {
    return _resolveInScope(requestScope, binding, function () {
        var result = _getResolvedFromBinding(requestScope, request, binding);
        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {
            result = result.then(function (resolved) { return _onActivation(request, binding, resolved); });
        }
        else {
            result = _onActivation(request, binding, result);
        }
        return result;
    });
};
function _onActivation(request, binding, resolved) {
    var result = _bindingActivation(request.parentContext, binding, resolved);
    var containersIterator = _getContainersIterator(request.parentContext.container);
    var container;
    var containersIteratorResult = containersIterator.next();
    do {
        container = containersIteratorResult.value;
        var context_1 = request.parentContext;
        var serviceIdentifier = request.serviceIdentifier;
        var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {
            result = _activateContainerAsync(activationsIterator, context_1, result);
        }
        else {
            result = _activateContainer(activationsIterator, context_1, result);
        }
        containersIteratorResult = containersIterator.next();
    } while (containersIteratorResult.done !== true && !(0,_planning_planner__WEBPACK_IMPORTED_MODULE_7__.getBindingDictionary)(container).hasKey(request.serviceIdentifier));
    return result;
}
var _bindingActivation = function (context, binding, previousResult) {
    var result;
    if (typeof binding.onActivation === 'function') {
        result = binding.onActivation(context, previousResult);
    }
    else {
        result = previousResult;
    }
    return result;
};
var _activateContainer = function (activationsIterator, context, result) {
    var activation = activationsIterator.next();
    while (!activation.done) {
        result = activation.value(context, result);
        if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_6__.isPromise)(result)) {
            return _activateContainerAsync(activationsIterator, context, result);
        }
        activation = activationsIterator.next();
    }
    return result;
};
var _activateContainerAsync = function (activationsIterator, context, resultPromise) { return __awaiter(void 0, void 0, void 0, function () {
    var result, activation;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, resultPromise];
            case 1:
                result = _a.sent();
                activation = activationsIterator.next();
                _a.label = 2;
            case 2:
                if (!!activation.done) return [3, 4];
                return [4, activation.value(context, result)];
            case 3:
                result = _a.sent();
                activation = activationsIterator.next();
                return [3, 2];
            case 4: return [2, result];
        }
    });
}); };
var _getContainerActivationsForService = function (container, serviceIdentifier) {
    var activations = container._activations;
    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
};
var _getContainersIterator = function (container) {
    var containersStack = [container];
    var parent = container.parent;
    while (parent !== null) {
        containersStack.push(parent);
        parent = parent.parent;
    }
    var getNextContainer = function () {
        var nextContainer = containersStack.pop();
        if (nextContainer !== undefined) {
            return { done: false, value: nextContainer };
        }
        else {
            return { done: true, value: undefined };
        }
    };
    var containersIterator = {
        next: getNextContainer,
    };
    return containersIterator;
};
function resolve(context) {
    var _f = _resolveRequest(context.plan.rootRequest.requestScope);
    return _f(context.plan.rootRequest);
}



/***/ }),

/***/ "../../node_modules/inversify/es/scope/scope.js":
/*!******************************************************!*\
  !*** ../../node_modules/inversify/es/scope/scope.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   saveToScope: () => (/* binding */ saveToScope),
/* harmony export */   tryGetFromScope: () => (/* binding */ tryGetFromScope)
/* harmony export */ });
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _utils_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/async */ "../../node_modules/inversify/es/utils/async.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var tryGetFromScope = function (requestScope, binding) {
    if ((binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) && binding.activated) {
        return binding.cache;
    }
    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request &&
        requestScope.has(binding.id)) {
        return requestScope.get(binding.id);
    }
    return null;
};
var saveToScope = function (requestScope, binding, result) {
    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton) {
        _saveToSingletonScope(binding, result);
    }
    if (binding.scope === _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request) {
        _saveToRequestScope(requestScope, binding, result);
    }
};
var _saveToRequestScope = function (requestScope, binding, result) {
    if (!requestScope.has(binding.id)) {
        requestScope.set(binding.id, result);
    }
};
var _saveToSingletonScope = function (binding, result) {
    binding.cache = result;
    binding.activated = true;
    if ((0,_utils_async__WEBPACK_IMPORTED_MODULE_1__.isPromise)(result)) {
        void _saveAsyncResultToSingletonScope(binding, result);
    }
};
var _saveAsyncResultToSingletonScope = function (binding, asyncResult) { return __awaiter(void 0, void 0, void 0, function () {
    var result, ex_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, asyncResult];
            case 1:
                result = _a.sent();
                binding.cache = result;
                return [3, 3];
            case 2:
                ex_1 = _a.sent();
                binding.cache = null;
                binding.activated = false;
                throw ex_1;
            case 3: return [2];
        }
    });
}); };


/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_in_syntax.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_in_syntax.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingInSyntax: () => (/* binding */ BindingInSyntax)
/* harmony export */ });
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_when_on_syntax */ "../../node_modules/inversify/es/syntax/binding_when_on_syntax.js");


var BindingInSyntax = (function () {
    function BindingInSyntax(binding) {
        this._binding = binding;
    }
    BindingInSyntax.prototype.inRequestScope = function () {
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Request;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inSingletonScope = function () {
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inTransientScope = function () {
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Transient;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingWhenOnSyntax(this._binding);
    };
    return BindingInSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_in_when_on_syntax.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_in_when_on_syntax.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingInWhenOnSyntax: () => (/* binding */ BindingInWhenOnSyntax)
/* harmony export */ });
/* harmony import */ var _binding_in_syntax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binding_in_syntax */ "../../node_modules/inversify/es/syntax/binding_in_syntax.js");
/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_on_syntax */ "../../node_modules/inversify/es/syntax/binding_on_syntax.js");
/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ "../../node_modules/inversify/es/syntax/binding_when_syntax.js");



var BindingInWhenOnSyntax = (function () {
    function BindingInWhenOnSyntax(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingOnSyntax(this._binding);
        this._bindingInSyntax = new _binding_in_syntax__WEBPACK_IMPORTED_MODULE_2__.BindingInSyntax(binding);
    }
    BindingInWhenOnSyntax.prototype.inRequestScope = function () {
        return this._bindingInSyntax.inRequestScope();
    };
    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
        return this._bindingInSyntax.inSingletonScope();
    };
    BindingInWhenOnSyntax.prototype.inTransientScope = function () {
        return this._bindingInSyntax.inTransientScope();
    };
    BindingInWhenOnSyntax.prototype.when = function (constraint) {
        return this._bindingWhenSyntax.when(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
        return this._bindingOnSyntax.onActivation(handler);
    };
    BindingInWhenOnSyntax.prototype.onDeactivation = function (handler) {
        return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingInWhenOnSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_on_syntax.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_on_syntax.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingOnSyntax: () => (/* binding */ BindingOnSyntax)
/* harmony export */ });
/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ "../../node_modules/inversify/es/syntax/binding_when_syntax.js");

var BindingOnSyntax = (function () {
    function BindingOnSyntax(binding) {
        this._binding = binding;
    }
    BindingOnSyntax.prototype.onActivation = function (handler) {
        this._binding.onActivation = handler;
        return new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);
    };
    BindingOnSyntax.prototype.onDeactivation = function (handler) {
        this._binding.onDeactivation = handler;
        return new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);
    };
    return BindingOnSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_to_syntax.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_to_syntax.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingToSyntax: () => (/* binding */ BindingToSyntax)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_in_when_on_syntax */ "../../node_modules/inversify/es/syntax/binding_in_when_on_syntax.js");
/* harmony import */ var _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding_when_on_syntax */ "../../node_modules/inversify/es/syntax/binding_when_on_syntax.js");




var BindingToSyntax = (function () {
    function BindingToSyntax(binding) {
        this._binding = binding;
    }
    BindingToSyntax.prototype.to = function (constructor) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toSelf = function () {
        if (typeof this._binding.serviceIdentifier !== "function") {
            throw new Error("" + _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_TO_SELF_VALUE);
        }
        var self = this._binding.serviceIdentifier;
        return this.to(self);
    };
    BindingToSyntax.prototype.toConstantValue = function (value) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toDynamicValue = function (func) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new _binding_in_when_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toConstructor = function (constructor) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Constructor;
        this._binding.implementationType = constructor;
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFactory = function (factory) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;
        this._binding.factory = factory;
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFunction = function (func) {
        if (typeof func !== "function") {
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_FUNCTION_BINDING);
        }
        var bindingWhenOnSyntax = this.toConstantValue(func);
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Function;
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return bindingWhenOnSyntax;
    };
    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;
        this._binding.factory = function (context) {
            var autofactory = function () { return context.container.get(serviceIdentifier); };
            return autofactory;
        };
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toAutoNamedFactory = function (serviceIdentifier) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory;
        this._binding.factory = function (context) {
            return function (named) { return context.container.getNamed(serviceIdentifier, named); };
        };
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toProvider = function (provider) {
        this._binding.type = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider;
        this._binding.provider = provider;
        this._binding.scope = _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingScopeEnum.Singleton;
        return new _binding_when_on_syntax__WEBPACK_IMPORTED_MODULE_3__.BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toService = function (service) {
        this.toDynamicValue(function (context) { return context.container.get(service); });
    };
    return BindingToSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_when_on_syntax.js":
/*!************************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_when_on_syntax.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingWhenOnSyntax: () => (/* binding */ BindingWhenOnSyntax)
/* harmony export */ });
/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binding_on_syntax */ "../../node_modules/inversify/es/syntax/binding_on_syntax.js");
/* harmony import */ var _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_when_syntax */ "../../node_modules/inversify/es/syntax/binding_when_syntax.js");


var BindingWhenOnSyntax = (function () {
    function BindingWhenOnSyntax(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new _binding_when_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_1__.BindingOnSyntax(this._binding);
    }
    BindingWhenOnSyntax.prototype.when = function (constraint) {
        return this._bindingWhenSyntax.when(constraint);
    };
    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
        return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.onActivation = function (handler) {
        return this._bindingOnSyntax.onActivation(handler);
    };
    BindingWhenOnSyntax.prototype.onDeactivation = function (handler) {
        return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingWhenOnSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/binding_when_syntax.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/binding_when_syntax.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindingWhenSyntax: () => (/* binding */ BindingWhenSyntax)
/* harmony export */ });
/* harmony import */ var _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binding_on_syntax */ "../../node_modules/inversify/es/syntax/binding_on_syntax.js");
/* harmony import */ var _constraint_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constraint_helpers */ "../../node_modules/inversify/es/syntax/constraint_helpers.js");


var BindingWhenSyntax = (function () {
    function BindingWhenSyntax(binding) {
        this._binding = binding;
    }
    BindingWhenSyntax.prototype.when = function (constraint) {
        this._binding.constraint = constraint;
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
        this._binding.constraint = (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name);
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
        this._binding.constraint = function (request) {
            if (request === null) {
                return false;
            }
            var targetIsDefault = (request.target !== null) &&
                (!request.target.isNamed()) &&
                (!request.target.isTagged());
            return targetIsDefault;
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
        this._binding.constraint = (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value);
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(parent)(request.parentRequest);
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentNamed = function (name) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name)(request.parentRequest);
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value)(request.parentRequest);
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(ancestor));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
        this._binding.constraint = function (request) {
            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.typeConstraint)(ancestor));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
        this._binding.constraint = function (request) {
            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.namedConstraint)(name));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
        this._binding.constraint = function (request) {
            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.taggedConstraint)(tag)(value));
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
        this._binding.constraint = function (request) {
            return request !== null && (0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, constraint);
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
        this._binding.constraint = function (request) {
            return request !== null && !(0,_constraint_helpers__WEBPACK_IMPORTED_MODULE_1__.traverseAncerstors)(request, constraint);
        };
        return new _binding_on_syntax__WEBPACK_IMPORTED_MODULE_0__.BindingOnSyntax(this._binding);
    };
    return BindingWhenSyntax;
}());



/***/ }),

/***/ "../../node_modules/inversify/es/syntax/constraint_helpers.js":
/*!********************************************************************!*\
  !*** ../../node_modules/inversify/es/syntax/constraint_helpers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   namedConstraint: () => (/* binding */ namedConstraint),
/* harmony export */   taggedConstraint: () => (/* binding */ taggedConstraint),
/* harmony export */   traverseAncerstors: () => (/* binding */ traverseAncerstors),
/* harmony export */   typeConstraint: () => (/* binding */ typeConstraint)
/* harmony export */ });
/* harmony import */ var _constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/es/constants/metadata_keys.js");
/* harmony import */ var _planning_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/es/planning/metadata.js");


var traverseAncerstors = function (request, constraint) {
    var parent = request.parentRequest;
    if (parent !== null) {
        return constraint(parent) ? true : traverseAncerstors(parent, constraint);
    }
    else {
        return false;
    }
};
var taggedConstraint = function (key) { return function (value) {
    var constraint = function (request) {
        return request !== null && request.target !== null && request.target.matchesTag(key)(value);
    };
    constraint.metaData = new _planning_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata(key, value);
    return constraint;
}; };
var namedConstraint = taggedConstraint(_constants_metadata_keys__WEBPACK_IMPORTED_MODULE_1__.NAMED_TAG);
var typeConstraint = function (type) { return function (request) {
    var binding = null;
    if (request !== null) {
        binding = request.bindings[0];
        if (typeof type === 'string') {
            var serviceIdentifier = binding.serviceIdentifier;
            return serviceIdentifier === type;
        }
        else {
            var constructor = request.bindings[0].implementationType;
            return type === constructor;
        }
    }
    return false;
}; };



/***/ }),

/***/ "../../node_modules/inversify/es/utils/async.js":
/*!******************************************************!*\
  !*** ../../node_modules/inversify/es/utils/async.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isPromiseOrContainsPromise: () => (/* binding */ isPromiseOrContainsPromise)
/* harmony export */ });
function isPromise(object) {
    var isObjectOrFunction = (typeof object === 'object' && object !== null) || typeof object === 'function';
    return isObjectOrFunction && typeof object.then === "function";
}
function isPromiseOrContainsPromise(object) {
    if (isPromise(object)) {
        return true;
    }
    return Array.isArray(object) && object.some(isPromise);
}



/***/ }),

/***/ "../../node_modules/inversify/es/utils/binding_utils.js":
/*!**************************************************************!*\
  !*** ../../node_modules/inversify/es/utils/binding_utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureFullyBound: () => (/* binding */ ensureFullyBound),
/* harmony export */   getFactoryDetails: () => (/* binding */ getFactoryDetails),
/* harmony export */   multiBindToService: () => (/* binding */ multiBindToService)
/* harmony export */ });
/* harmony import */ var _utils_serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/serialization */ "../../node_modules/inversify/es/utils/serialization.js");
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");
/* harmony import */ var _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/literal_types */ "../../node_modules/inversify/es/constants/literal_types.js");
/* harmony import */ var _factory_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factory_type */ "../../node_modules/inversify/es/utils/factory_type.js");




var multiBindToService = function (container) {
    return function (service) {
        return function () {
            var types = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                types[_i] = arguments[_i];
            }
            return types.forEach(function (t) { return container.bind(t).toService(service); });
        };
    };
};
var ensureFullyBound = function (binding) {
    var boundValue = null;
    switch (binding.type) {
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.ConstantValue:
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Function:
            boundValue = binding.cache;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Constructor:
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Instance:
            boundValue = binding.implementationType;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue:
            boundValue = binding.dynamicValue;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider:
            boundValue = binding.provider;
            break;
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory:
            boundValue = binding.factory;
            break;
    }
    if (boundValue === null) {
        var serviceIdentifierAsString = (0,_utils_serialization__WEBPACK_IMPORTED_MODULE_1__.getServiceIdentifierAsString)(binding.serviceIdentifier);
        throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_2__.INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
    }
};
var getFactoryDetails = function (binding) {
    switch (binding.type) {
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Factory:
            return { factory: binding.factory, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.Factory };
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.Provider:
            return { factory: binding.provider, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.Provider };
        case _constants_literal_types__WEBPACK_IMPORTED_MODULE_0__.BindingTypeEnum.DynamicValue:
            return { factory: binding.dynamicValue, factoryType: _factory_type__WEBPACK_IMPORTED_MODULE_3__.FactoryType.DynamicValue };
        default:
            throw new Error("Unexpected factory type " + binding.type);
    }
};


/***/ }),

/***/ "../../node_modules/inversify/es/utils/clonable.js":
/*!*********************************************************!*\
  !*** ../../node_modules/inversify/es/utils/clonable.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isClonable: () => (/* binding */ isClonable)
/* harmony export */ });
function isClonable(obj) {
    return (typeof obj === 'object')
        && (obj !== null)
        && ('clone' in obj)
        && typeof obj.clone === 'function';
}



/***/ }),

/***/ "../../node_modules/inversify/es/utils/exceptions.js":
/*!***********************************************************!*\
  !*** ../../node_modules/inversify/es/utils/exceptions.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isStackOverflowExeption: () => (/* binding */ isStackOverflowExeption),
/* harmony export */   tryAndThrowErrorIfStackOverflow: () => (/* binding */ tryAndThrowErrorIfStackOverflow)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");

function isStackOverflowExeption(error) {
    return (error instanceof RangeError ||
        error.message === _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.STACK_OVERFLOW);
}
var tryAndThrowErrorIfStackOverflow = function (fn, errorCallback) {
    try {
        return fn();
    }
    catch (error) {
        if (isStackOverflowExeption(error)) {
            error = errorCallback();
        }
        throw error;
    }
};


/***/ }),

/***/ "../../node_modules/inversify/es/utils/factory_type.js":
/*!*************************************************************!*\
  !*** ../../node_modules/inversify/es/utils/factory_type.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FactoryType: () => (/* binding */ FactoryType)
/* harmony export */ });
var FactoryType;
(function (FactoryType) {
    FactoryType["DynamicValue"] = "toDynamicValue";
    FactoryType["Factory"] = "toFactory";
    FactoryType["Provider"] = "toProvider";
})(FactoryType || (FactoryType = {}));


/***/ }),

/***/ "../../node_modules/inversify/es/utils/id.js":
/*!***************************************************!*\
  !*** ../../node_modules/inversify/es/utils/id.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id: () => (/* binding */ id)
/* harmony export */ });
var idCounter = 0;
function id() {
    return idCounter++;
}



/***/ }),

/***/ "../../node_modules/inversify/es/utils/js.js":
/*!***************************************************!*\
  !*** ../../node_modules/inversify/es/utils/js.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFirstArrayDuplicate: () => (/* binding */ getFirstArrayDuplicate)
/* harmony export */ });
function getFirstArrayDuplicate(array) {
    var seenValues = new Set();
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var entry = array_1[_i];
        if (seenValues.has(entry)) {
            return entry;
        }
        else {
            seenValues.add(entry);
        }
    }
    return undefined;
}


/***/ }),

/***/ "../../node_modules/inversify/es/utils/serialization.js":
/*!**************************************************************!*\
  !*** ../../node_modules/inversify/es/utils/serialization.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circularDependencyToException: () => (/* binding */ circularDependencyToException),
/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName),
/* harmony export */   getServiceIdentifierAsString: () => (/* binding */ getServiceIdentifierAsString),
/* harmony export */   getSymbolDescription: () => (/* binding */ getSymbolDescription),
/* harmony export */   listMetadataForTarget: () => (/* binding */ listMetadataForTarget),
/* harmony export */   listRegisteredBindingsForServiceIdentifier: () => (/* binding */ listRegisteredBindingsForServiceIdentifier)
/* harmony export */ });
/* harmony import */ var _constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/es/constants/error_msgs.js");

function getServiceIdentifierAsString(serviceIdentifier) {
    if (typeof serviceIdentifier === 'function') {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier.name;
    }
    else if (typeof serviceIdentifier === 'symbol') {
        return serviceIdentifier.toString();
    }
    else {
        var _serviceIdentifier = serviceIdentifier;
        return _serviceIdentifier;
    }
}
function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = '';
    var registeredBindings = getBindings(container, serviceIdentifier);
    if (registeredBindings.length !== 0) {
        registeredBindingsList = '\nRegistered bindings:';
        registeredBindings.forEach(function (binding) {
            var name = 'Object';
            if (binding.implementationType !== null) {
                name = getFunctionName(binding.implementationType);
            }
            registeredBindingsList = registeredBindingsList + "\n " + name;
            if (binding.constraint.metaData) {
                registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
            }
        });
    }
    return registeredBindingsList;
}
function alreadyDependencyChain(request, serviceIdentifier) {
    if (request.parentRequest === null) {
        return false;
    }
    else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
        return true;
    }
    else {
        return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
    }
}
function dependencyChainToString(request) {
    function _createStringArr(req, result) {
        if (result === void 0) { result = []; }
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        result.push(serviceIdentifier);
        if (req.parentRequest !== null) {
            return _createStringArr(req.parentRequest, result);
        }
        return result;
    }
    var stringArr = _createStringArr(request);
    return stringArr.reverse().join(' --> ');
}
function circularDependencyToException(request) {
    request.childRequests.forEach(function (childRequest) {
        if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
            var services = dependencyChainToString(childRequest);
            throw new Error(_constants_error_msgs__WEBPACK_IMPORTED_MODULE_0__.CIRCULAR_DEPENDENCY + " " + services);
        }
        else {
            circularDependencyToException(childRequest);
        }
    });
}
function listMetadataForTarget(serviceIdentifierString, target) {
    if (target.isTagged() || target.isNamed()) {
        var m_1 = '';
        var namedTag = target.getNamedTag();
        var otherTags = target.getCustomTags();
        if (namedTag !== null) {
            m_1 += namedTag.toString() + '\n';
        }
        if (otherTags !== null) {
            otherTags.forEach(function (tag) {
                m_1 += tag.toString() + '\n';
            });
        }
        return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
    }
    else {
        return " " + serviceIdentifierString;
    }
}
function getFunctionName(func) {
    if (func.name) {
        return func.name;
    }
    else {
        var name_1 = func.toString();
        var match = name_1.match(/^function\s*([^\s(]+)/);
        return match ? match[1] : "Anonymous function: " + name_1;
    }
}
function getSymbolDescription(symbol) {
    return symbol.toString().slice(7, -1);
}



/***/ }),

/***/ "../../node_modules/inversify/lib/annotation/decorator_utils.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/inversify/lib/annotation/decorator_utils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTaggedDecorator = exports.tagProperty = exports.tagParameter = exports.decorate = void 0;
var ERROR_MSGS = __importStar(__webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/lib/constants/error_msgs.js"));
var METADATA_KEY = __importStar(__webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/lib/constants/metadata_keys.js"));
var js_1 = __webpack_require__(/*! ../utils/js */ "../../node_modules/inversify/lib/utils/js.js");
function targetIsConstructorFunction(target) {
    return target.prototype !== undefined;
}
function _throwIfMethodParameter(parameterName) {
    if (parameterName !== undefined) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
    }
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    _throwIfMethodParameter(parameterName);
    _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
exports.tagParameter = tagParameter;
function tagProperty(annotationTarget, propertyName, metadata) {
    if (targetIsConstructorFunction(annotationTarget)) {
        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
    }
    _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
}
exports.tagProperty = tagProperty;
function _ensureNoMetadataKeyDuplicates(metadata) {
    var metadatas = [];
    if (Array.isArray(metadata)) {
        metadatas = metadata;
        var duplicate = (0, js_1.getFirstArrayDuplicate)(metadatas.map(function (md) { return md.key; }));
        if (duplicate !== undefined) {
            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + duplicate.toString());
        }
    }
    else {
        metadatas = [metadata];
    }
    return metadatas;
}
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
    var paramsOrPropertiesMetadata = {};
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (paramOrPropertyMetadata === undefined) {
        paramOrPropertyMetadata = [];
    }
    else {
        var _loop_1 = function (m) {
            if (metadatas.some(function (md) { return md.key === m.key; })) {
                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + " " + m.key.toString());
            }
        };
        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
            var m = paramOrPropertyMetadata_1[_i];
            _loop_1(m);
        }
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function createTaggedDecorator(metadata) {
    return function (target, targetKey, indexOrPropertyDescriptor) {
        if (typeof indexOrPropertyDescriptor === 'number') {
            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
        }
        else {
            tagProperty(target, targetKey, metadata);
        }
    };
}
exports.createTaggedDecorator = createTaggedDecorator;
function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
}
function _param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
}
function decorate(decorator, target, parameterIndexOrProperty) {
    if (typeof parameterIndexOrProperty === 'number') {
        _decorate([_param(parameterIndexOrProperty, decorator)], target);
    }
    else if (typeof parameterIndexOrProperty === 'string') {
        Reflect.decorate([decorator], target, parameterIndexOrProperty);
    }
    else {
        _decorate([decorator], target);
    }
}
exports.decorate = decorate;


/***/ }),

/***/ "../../node_modules/inversify/lib/annotation/inject.js":
/*!*************************************************************!*\
  !*** ../../node_modules/inversify/lib/annotation/inject.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inject = void 0;
var METADATA_KEY = __importStar(__webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/lib/constants/metadata_keys.js"));
var inject_base_1 = __webpack_require__(/*! ./inject_base */ "../../node_modules/inversify/lib/annotation/inject_base.js");
var inject = (0, inject_base_1.injectBase)(METADATA_KEY.INJECT_TAG);
exports.inject = inject;


/***/ }),

/***/ "../../node_modules/inversify/lib/annotation/inject_base.js":
/*!******************************************************************!*\
  !*** ../../node_modules/inversify/lib/annotation/inject_base.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.injectBase = void 0;
var error_msgs_1 = __webpack_require__(/*! ../constants/error_msgs */ "../../node_modules/inversify/lib/constants/error_msgs.js");
var metadata_1 = __webpack_require__(/*! ../planning/metadata */ "../../node_modules/inversify/lib/planning/metadata.js");
var decorator_utils_1 = __webpack_require__(/*! ./decorator_utils */ "../../node_modules/inversify/lib/annotation/decorator_utils.js");
function injectBase(metadataKey) {
    return function (serviceIdentifier) {
        return function (target, targetKey, indexOrPropertyDescriptor) {
            if (serviceIdentifier === undefined) {
                var className = typeof target === 'function' ? target.name : target.constructor.name;
                throw new Error((0, error_msgs_1.UNDEFINED_INJECT_ANNOTATION)(className));
            }
            return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
        };
    };
}
exports.injectBase = injectBase;


/***/ }),

/***/ "../../node_modules/inversify/lib/constants/error_msgs.js":
/*!****************************************************************!*\
  !*** ../../node_modules/inversify/lib/constants/error_msgs.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.ON_DEACTIVATION_ERROR = exports.PRE_DESTROY_ERROR = exports.POST_CONSTRUCT_ERROR = exports.ASYNC_UNBIND_REQUIRED = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.MULTIPLE_PRE_DESTROY_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.LAZY_IN_SYNC = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.NOT_IMPLEMENTED = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.MISSING_INJECT_ANNOTATION = exports.MISSING_INJECTABLE_ANNOTATION = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
exports.DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';
exports.DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';
exports.NULL_ARGUMENT = 'NULL argument';
exports.KEY_NOT_FOUND = 'Key Not Found';
exports.AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';
exports.CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';
exports.NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';
exports.MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';
exports.MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';
var UNDEFINED_INJECT_ANNOTATION = function (name) {
    return "@inject called with undefined this could mean that the class " + name + " has " +
        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +
        'overcome this limitation.';
};
exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
exports.CIRCULAR_DEPENDENCY = 'Circular dependency found:';
exports.NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';
exports.INVALID_BINDING_TYPE = 'Invalid binding type:';
exports.NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';
exports.INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';
exports.INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';
var LAZY_IN_SYNC = function (key) { return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies."; };
exports.LAZY_IN_SYNC = LAZY_IN_SYNC;
exports.INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +
    'used as service identifier';
exports.INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +
    'must be applied to the parameters of a class constructor or a class property.';
var ARGUMENTS_LENGTH_MISMATCH = function () {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return 'The number of constructor arguments in the derived class ' +
        (values[0] + " must be >= than the number of constructor arguments of its base class.");
};
exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +
    'must be an object.';
exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +
    'be a string ("singleton" or "transient").';
exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +
    'be a boolean';
exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +
    'be a boolean';
exports.MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';
exports.MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';
exports.ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';
var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return "@postConstruct error in class " + clazz + ": " + errorMessage; };
exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return "@preDestroy error in class " + clazz + ": " + errorMessage; };
exports.PRE_DESTROY_ERROR = PRE_DESTROY_ERROR;
var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return "onDeactivation() error in class " + clazz + ": " + errorMessage; };
exports.ON_DEACTIVATION_ERROR = ON_DEACTIVATION_ERROR;
var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {
    return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with " +
        ("service identifier '" + serviceIdentifier + "'.");
};
exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
exports.STACK_OVERFLOW = 'Maximum call stack size exceeded';


/***/ }),

/***/ "../../node_modules/inversify/lib/constants/metadata_keys.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/inversify/lib/constants/metadata_keys.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
exports.NAMED_TAG = 'named';
exports.NAME_TAG = 'name';
exports.UNMANAGED_TAG = 'unmanaged';
exports.OPTIONAL_TAG = 'optional';
exports.INJECT_TAG = 'inject';
exports.MULTI_INJECT_TAG = 'multi_inject';
exports.TAGGED = 'inversify:tagged';
exports.TAGGED_PROP = 'inversify:tagged_props';
exports.PARAM_TYPES = 'inversify:paramtypes';
exports.DESIGN_PARAM_TYPES = 'design:paramtypes';
exports.POST_CONSTRUCT = 'post_construct';
exports.PRE_DESTROY = 'pre_destroy';
function getNonCustomTagKeys() {
    return [
        exports.INJECT_TAG,
        exports.MULTI_INJECT_TAG,
        exports.NAME_TAG,
        exports.UNMANAGED_TAG,
        exports.NAMED_TAG,
        exports.OPTIONAL_TAG,
    ];
}
exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();


/***/ }),

/***/ "../../node_modules/inversify/lib/planning/metadata.js":
/*!*************************************************************!*\
  !*** ../../node_modules/inversify/lib/planning/metadata.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Metadata = void 0;
var METADATA_KEY = __importStar(__webpack_require__(/*! ../constants/metadata_keys */ "../../node_modules/inversify/lib/constants/metadata_keys.js"));
var Metadata = (function () {
    function Metadata(key, value) {
        this.key = key;
        this.value = value;
    }
    Metadata.prototype.toString = function () {
        if (this.key === METADATA_KEY.NAMED_TAG) {
            return "named: " + String(this.value).toString() + " ";
        }
        else {
            return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
        }
    };
    return Metadata;
}());
exports.Metadata = Metadata;


/***/ }),

/***/ "../../node_modules/inversify/lib/utils/js.js":
/*!****************************************************!*\
  !*** ../../node_modules/inversify/lib/utils/js.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFirstArrayDuplicate = void 0;
function getFirstArrayDuplicate(array) {
    var seenValues = new Set();
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var entry = array_1[_i];
        if (seenValues.has(entry)) {
            return entry;
        }
        else {
            seenValues.add(entry);
        }
    }
    return undefined;
}
exports.getFirstArrayDuplicate = getFirstArrayDuplicate;


/***/ }),

/***/ "../../node_modules/kuler/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/kuler/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/**
 * Kuler: Color text using CSS colors
 *
 * @constructor
 * @param {String} text The text that needs to be styled
 * @param {String} color Optional color for alternate API.
 * @api public
 */
function Kuler(text, color) {
  if (color) return (new Kuler(text)).style(color);
  if (!(this instanceof Kuler)) return new Kuler(text);

  this.text = text;
}

/**
 * ANSI color codes.
 *
 * @type {String}
 * @private
 */
Kuler.prototype.prefix = '\x1b[';
Kuler.prototype.suffix = 'm';

/**
 * Parse a hex color string and parse it to it's RGB equiv.
 *
 * @param {String} color
 * @returns {Array}
 * @api private
 */
Kuler.prototype.hex = function hex(color) {
  color = color[0] === '#' ? color.substring(1) : color;

  //
  // Pre-parse for shorthand hex colors.
  //
  if (color.length === 3) {
    color = color.split('');

    color[5] = color[2]; // F60##0
    color[4] = color[2]; // F60#00
    color[3] = color[1]; // F60600
    color[2] = color[1]; // F66600
    color[1] = color[0]; // FF6600

    color = color.join('');
  }

  var r = color.substring(0, 2)
    , g = color.substring(2, 4)
    , b = color.substring(4, 6);

  return [ parseInt(r, 16), parseInt(g, 16), parseInt(b, 16) ];
};

/**
 * Transform a 255 RGB value to an RGV code.
 *
 * @param {Number} r Red color channel.
 * @param {Number} g Green color channel.
 * @param {Number} b Blue color channel.
 * @returns {String}
 * @api public
 */
Kuler.prototype.rgb = function rgb(r, g, b) {
  var red = r / 255 * 5
    , green = g / 255 * 5
    , blue = b / 255 * 5;

  return this.ansi(red, green, blue);
};

/**
 * Turns RGB 0-5 values into a single ANSI code.
 *
 * @param {Number} r Red color channel.
 * @param {Number} g Green color channel.
 * @param {Number} b Blue color channel.
 * @returns {String}
 * @api public
 */
Kuler.prototype.ansi = function ansi(r, g, b) {
  var red = Math.round(r)
    , green = Math.round(g)
    , blue = Math.round(b);

  return 16 + (red * 36) + (green * 6) + blue;
};

/**
 * Marks an end of color sequence.
 *
 * @returns {String} Reset sequence.
 * @api public
 */
Kuler.prototype.reset = function reset() {
  return this.prefix +'39;49'+ this.suffix;
};

/**
 * Colour the terminal using CSS.
 *
 * @param {String} color The HEX color code.
 * @returns {String} the escape code.
 * @api public
 */
Kuler.prototype.style = function style(color) {
  return this.prefix +'38;5;'+ this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
};


//
// Expose the actual interface.
//
module.exports = Kuler;


/***/ }),

/***/ "../../node_modules/logform/align.js":
/*!*******************************************!*\
  !*** ../../node_modules/logform/align.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

/*
 * function align (info)
 * Returns a new instance of the align Format which adds a `\t`
 * delimiter before the message to properly align it in the same place.
 * It was previously { align: true } in winston < 3.0.0
 */
module.exports = format(info => {
  info.message = `\t${info.message}`;
  return info;
});


/***/ }),

/***/ "../../node_modules/logform/cli.js":
/*!*****************************************!*\
  !*** ../../node_modules/logform/cli.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Colorizer } = __webpack_require__(/*! ./colorize */ "../../node_modules/logform/colorize.js");
const { Padder } = __webpack_require__(/*! ./pad-levels */ "../../node_modules/logform/pad-levels.js");
const { configs, MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");


/**
 * Cli format class that handles initial state for a a separate
 * Colorizer and Padder instance.
 */
class CliFormat {
  constructor(opts = {}) {
    if (!opts.levels) {
      opts.levels = configs.cli.levels;
    }

    this.colorizer = new Colorizer(opts);
    this.padder = new Padder(opts);
    this.options = opts;
  }

  /*
   * function transform (info, opts)
   * Attempts to both:
   * 1. Pad the { level }
   * 2. Colorize the { level, message }
   * of the given `logform` info object depending on the `opts`.
   */
  transform(info, opts) {
    this.colorizer.transform(
      this.padder.transform(info, opts),
      opts
    );

    info[MESSAGE] = `${info.level}:${info.message}`;
    return info;
  }
}

/*
 * function cli (opts)
 * Returns a new instance of the CLI format that turns a log
 * `info` object into the same format previously available
 * in `winston.cli()` in `winston < 3.0.0`.
 */
module.exports = opts => new CliFormat(opts);

//
// Attach the CliFormat for registration purposes
//
module.exports.Format = CliFormat;


/***/ }),

/***/ "../../node_modules/logform/colorize.js":
/*!**********************************************!*\
  !*** ../../node_modules/logform/colorize.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(/*! @colors/colors/safe */ "../../node_modules/@colors/colors/safe.js");
const { LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

//
// Fix colors not appearing in non-tty environments
//
colors.enabled = true;

/**
 * @property {RegExp} hasSpace
 * Simple regex to check for presence of spaces.
 */
const hasSpace = /\s+/;

/*
 * Colorizer format. Wraps the `level` and/or `message` properties
 * of the `info` objects with ANSI color codes based on a few options.
 */
class Colorizer {
  constructor(opts = {}) {
    if (opts.colors) {
      this.addColors(opts.colors);
    }

    this.options = opts;
  }

  /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */
  static addColors(clrs) {
    const nextColors = Object.keys(clrs).reduce((acc, level) => {
      acc[level] = hasSpace.test(clrs[level])
        ? clrs[level].split(hasSpace)
        : clrs[level];

      return acc;
    }, {});

    Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
    return Colorizer.allColors;
  }

  /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */
  addColors(clrs) {
    return Colorizer.addColors(clrs);
  }

  /*
   * function colorize (lookup, level, message)
   * Performs multi-step colorization using @colors/colors/safe
   */
  colorize(lookup, level, message) {
    if (typeof message === 'undefined') {
      message = level;
    }

    //
    // If the color for the level is just a string
    // then attempt to colorize the message with it.
    //
    if (!Array.isArray(Colorizer.allColors[lookup])) {
      return colors[Colorizer.allColors[lookup]](message);
    }

    //
    // If it is an Array then iterate over that Array, applying
    // the colors function for each item.
    //
    for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
      message = colors[Colorizer.allColors[lookup][i]](message);
    }

    return message;
  }

  /*
   * function transform (info, opts)
   * Attempts to colorize the { level, message } of the given
   * `logform` info object.
   */
  transform(info, opts) {
    if (opts.all && typeof info[MESSAGE] === 'string') {
      info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
    }

    if (opts.level || opts.all || !opts.message) {
      info.level = this.colorize(info[LEVEL], info.level);
    }

    if (opts.all || opts.message) {
      info.message = this.colorize(info[LEVEL], info.level, info.message);
    }

    return info;
  }
}

/*
 * function colorize (info)
 * Returns a new instance of the colorize Format that applies
 * level colors to `info` objects. This was previously exposed
 * as { colorize: true } to transports in `winston < 3.0.0`.
 */
module.exports = opts => new Colorizer(opts);

//
// Attach the Colorizer for registration purposes
//
module.exports.Colorizer
  = module.exports.Format
  = Colorizer;


/***/ }),

/***/ "../../node_modules/logform/combine.js":
/*!*********************************************!*\
  !*** ../../node_modules/logform/combine.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

/*
 * function cascade(formats)
 * Returns a function that invokes the `._format` function in-order
 * for the specified set of `formats`. In this manner we say that Formats
 * are "pipe-like", but not a pure pumpify implementation. Since there is no back
 * pressure we can remove all of the "readable" plumbing in Node streams.
 */
function cascade(formats) {
  if (!formats.every(isValidFormat)) {
    return;
  }

  return info => {
    let obj = info;
    for (let i = 0; i < formats.length; i++) {
      obj = formats[i].transform(obj, formats[i].options);
      if (!obj) {
        return false;
      }
    }

    return obj;
  };
}

/*
 * function isValidFormat(format)
 * If the format does not define a `transform` function throw an error
 * with more detailed usage.
 */
function isValidFormat(fmt) {
  if (typeof fmt.transform !== 'function') {
    throw new Error([
      'No transform function found on format. Did you create a format instance?',
      'const myFormat = format(formatFn);',
      'const instance = myFormat();'
    ].join('\n'));
  }

  return true;
}

/*
 * function combine (info)
 * Returns a new instance of the combine Format which combines the specified
 * formats into a new format. This is similar to a pipe-chain in transform streams.
 * We choose to combine the prototypes this way because there is no back pressure in
 * an in-memory transform chain.
 */
module.exports = (...formats) => {
  const combinedFormat = format(cascade(formats));
  const instance = combinedFormat();
  instance.Format = combinedFormat.Format;
  return instance;
};

//
// Export the cascade method for use in cli and other
// combined formats that should not be assumed to be
// singletons.
//
module.exports.cascade = cascade;


/***/ }),

/***/ "../../node_modules/logform/errors.js":
/*!********************************************!*\
  !*** ../../node_modules/logform/errors.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/*
 * function errors (info)
 * If the `message` property of the `info` object is an instance of `Error`,
 * replace the `Error` object its own `message` property.
 *
 * Optionally, the Error's `stack` and/or `cause` properties can also be appended to the `info` object.
 */
module.exports = format((einfo, { stack, cause }) => {
  if (einfo instanceof Error) {
    const info = Object.assign({}, einfo, {
      level: einfo.level,
      [LEVEL]: einfo[LEVEL] || einfo.level,
      message: einfo.message,
      [MESSAGE]: einfo[MESSAGE] || einfo.message
    });

    if (stack) info.stack = einfo.stack;
    if (cause) info.cause = einfo.cause;
    return info;
  }

  if (!(einfo.message instanceof Error)) return einfo;

  // Assign all enumerable properties and the
  // message property from the error provided.
  const err = einfo.message;
  Object.assign(einfo, err);
  einfo.message = err.message;
  einfo[MESSAGE] = err.message;

  // Assign the stack and/or cause if requested.
  if (stack) einfo.stack = err.stack;
  if (cause) einfo.cause = err.cause;
  return einfo;
});


/***/ }),

/***/ "../../node_modules/logform/format.js":
/*!********************************************!*\
  !*** ../../node_modules/logform/format.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


/*
 * Displays a helpful message and the source of
 * the format when it is invalid.
 */
class InvalidFormatError extends Error {
  constructor(formatFn) {
    super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split('\n')[0]}\n`);

    Error.captureStackTrace(this, InvalidFormatError);
  }
}

/*
 * function format (formatFn)
 * Returns a create function for the `formatFn`.
 */
module.exports = formatFn => {
  if (formatFn.length > 2) {
    throw new InvalidFormatError(formatFn);
  }

  /*
   * function Format (options)
   * Base prototype which calls a `_format`
   * function and pushes the result.
   */
  function Format(options = {}) {
    this.options = options;
  }

  Format.prototype.transform = formatFn;

  //
  // Create a function which returns new instances of
  // FormatWrap for simple syntax like:
  //
  // require('winston').formats.json();
  //
  function createFormatWrap(opts) {
    return new Format(opts);
  }

  //
  // Expose the FormatWrap through the create function
  // for testability.
  //
  createFormatWrap.Format = Format;
  return createFormatWrap;
};


/***/ }),

/***/ "../../node_modules/logform/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/logform/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/*
 * @api public
 * @property {function} format
 * Both the construction method and set of exposed
 * formats.
 */
const format = exports.format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

/*
 * @api public
 * @method {function} levels
 * Registers the specified levels with logform.
 */
exports.levels = __webpack_require__(/*! ./levels */ "../../node_modules/logform/levels.js");

/*
 * @api private
 * method {function} exposeFormat
 * Exposes a sub-format on the main format object
 * as a lazy-loaded getter.
 */
function exposeFormat(name, requireFormat) {
  Object.defineProperty(format, name, {
    get() {
      return requireFormat();
    },
    configurable: true
  });
}

//
// Setup all transports as lazy-loaded getters.
//
exposeFormat('align', function () { return __webpack_require__(/*! ./align */ "../../node_modules/logform/align.js"); });
exposeFormat('errors', function () { return __webpack_require__(/*! ./errors */ "../../node_modules/logform/errors.js"); });
exposeFormat('cli', function () { return __webpack_require__(/*! ./cli */ "../../node_modules/logform/cli.js"); });
exposeFormat('combine', function () { return __webpack_require__(/*! ./combine */ "../../node_modules/logform/combine.js"); });
exposeFormat('colorize', function () { return __webpack_require__(/*! ./colorize */ "../../node_modules/logform/colorize.js"); });
exposeFormat('json', function () { return __webpack_require__(/*! ./json */ "../../node_modules/logform/json.js"); });
exposeFormat('label', function () { return __webpack_require__(/*! ./label */ "../../node_modules/logform/label.js"); });
exposeFormat('logstash', function () { return __webpack_require__(/*! ./logstash */ "../../node_modules/logform/logstash.js"); });
exposeFormat('metadata', function () { return __webpack_require__(/*! ./metadata */ "../../node_modules/logform/metadata.js"); });
exposeFormat('ms', function () { return __webpack_require__(/*! ./ms */ "../../node_modules/logform/ms.js"); });
exposeFormat('padLevels', function () { return __webpack_require__(/*! ./pad-levels */ "../../node_modules/logform/pad-levels.js"); });
exposeFormat('prettyPrint', function () { return __webpack_require__(/*! ./pretty-print */ "../../node_modules/logform/pretty-print.js"); });
exposeFormat('printf', function () { return __webpack_require__(/*! ./printf */ "../../node_modules/logform/printf.js"); });
exposeFormat('simple', function () { return __webpack_require__(/*! ./simple */ "../../node_modules/logform/simple.js"); });
exposeFormat('splat', function () { return __webpack_require__(/*! ./splat */ "../../node_modules/logform/splat.js"); });
exposeFormat('timestamp', function () { return __webpack_require__(/*! ./timestamp */ "../../node_modules/logform/timestamp.js"); });
exposeFormat('uncolorize', function () { return __webpack_require__(/*! ./uncolorize */ "../../node_modules/logform/uncolorize.js"); });


/***/ }),

/***/ "../../node_modules/logform/json.js":
/*!******************************************!*\
  !*** ../../node_modules/logform/json.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const stringify = __webpack_require__(/*! safe-stable-stringify */ "../../node_modules/safe-stable-stringify/index.js");

/*
 * function replacer (key, value)
 * Handles proper stringification of Buffer and bigint output.
 */
function replacer(key, value) {
  // safe-stable-stringify does support BigInt, however, it doesn't wrap the value in quotes.
  // Leading to a loss in fidelity if the resulting string is parsed.
  // It would also be a breaking change for logform.
  if (typeof value === 'bigint')
    return value.toString();
  return value;
}

/*
 * function json (info)
 * Returns a new instance of the JSON format that turns a log `info`
 * object into pure JSON. This was previously exposed as { json: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  const jsonStringify = stringify.configure(opts);
  info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
  return info;
});


/***/ }),

/***/ "../../node_modules/logform/label.js":
/*!*******************************************!*\
  !*** ../../node_modules/logform/label.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

/*
 * function label (info)
 * Returns a new instance of the label Format which adds the specified
 * `opts.label` before the message. This was previously exposed as
 * { label: 'my label' } to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  if (opts.message) {
    info.message = `[${opts.label}] ${info.message}`;
    return info;
  }

  info.label = opts.label;
  return info;
});


/***/ }),

/***/ "../../node_modules/logform/levels.js":
/*!********************************************!*\
  !*** ../../node_modules/logform/levels.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Colorizer } = __webpack_require__(/*! ./colorize */ "../../node_modules/logform/colorize.js");

/*
 * Simple method to register colors with a simpler require
 * path within the module.
 */
module.exports = config => {
  Colorizer.addColors(config.colors || config);
  return config;
};


/***/ }),

/***/ "../../node_modules/logform/logstash.js":
/*!**********************************************!*\
  !*** ../../node_modules/logform/logstash.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const jsonStringify = __webpack_require__(/*! safe-stable-stringify */ "../../node_modules/safe-stable-stringify/index.js");

/*
 * function logstash (info)
 * Returns a new instance of the LogStash Format that turns a
 * log `info` object into pure JSON with the appropriate logstash
 * options. This was previously exposed as { logstash: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format(info => {
  const logstash = {};
  if (info.message) {
    logstash['@message'] = info.message;
    delete info.message;
  }

  if (info.timestamp) {
    logstash['@timestamp'] = info.timestamp;
    delete info.timestamp;
  }

  logstash['@fields'] = info;
  info[MESSAGE] = jsonStringify(logstash);
  return info;
});


/***/ }),

/***/ "../../node_modules/logform/metadata.js":
/*!**********************************************!*\
  !*** ../../node_modules/logform/metadata.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

function fillExcept(info, fillExceptKeys, metadataKey) {
  const savedKeys = fillExceptKeys.reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});
  const metadata = Object.keys(info).reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});

  Object.assign(info, savedKeys, {
    [metadataKey]: metadata
  });
  return info;
}

function fillWith(info, fillWithKeys, metadataKey) {
  info[metadataKey] = fillWithKeys.reduce((acc, key) => {
    acc[key] = info[key];
    delete info[key];
    return acc;
  }, {});
  return info;
}

/**
 * Adds in a "metadata" object to collect extraneous data, similar to the metadata
 * object in winston 2.x.
 */
module.exports = format((info, opts = {}) => {
  let metadataKey = 'metadata';
  if (opts.key) {
    metadataKey = opts.key;
  }

  let fillExceptKeys = [];
  if (!opts.fillExcept && !opts.fillWith) {
    fillExceptKeys.push('level');
    fillExceptKeys.push('message');
  }

  if (opts.fillExcept) {
    fillExceptKeys = opts.fillExcept;
  }

  if (fillExceptKeys.length > 0) {
    return fillExcept(info, fillExceptKeys, metadataKey);
  }

  if (opts.fillWith) {
    return fillWith(info, opts.fillWith, metadataKey);
  }

  return info;
});


/***/ }),

/***/ "../../node_modules/logform/ms.js":
/*!****************************************!*\
  !*** ../../node_modules/logform/ms.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const ms = __webpack_require__(/*! ms */ "../../node_modules/ms/index.js");

/*
 * function ms (info)
 * Returns an `info` with a `ms` property. The `ms` property holds the Value
 * of the time difference between two calls in milliseconds.
 */
module.exports = format(info => {
  const curr = +new Date();
  this.diff = curr - (this.prevTime || curr);
  this.prevTime = curr;
  info.ms = `+${ms(this.diff)}`;

  return info;
});


/***/ }),

/***/ "../../node_modules/logform/pad-levels.js":
/*!************************************************!*\
  !*** ../../node_modules/logform/pad-levels.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: 0 */


const { configs, LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

class Padder {
  constructor(opts = { levels: configs.npm.levels }) {
    this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
    this.options = opts;
  }

  /**
   * Returns the maximum length of keys in the specified `levels` Object.
   * @param  {Object} levels Set of all levels to calculate longest level against.
   * @returns {Number} Maximum length of the longest level string.
   */
  static getLongestLevel(levels) {
    const lvls = Object.keys(levels).map(level => level.length);
    return Math.max(...lvls);
  }

  /**
   * Returns the padding for the specified `level` assuming that the
   * maximum length of all levels it's associated with is `maxLength`.
   * @param  {String} level Level to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @param  {Number} maxLength Length of the longest level
   * @returns {String} Padding string for the `level`
   */
  static paddingForLevel(level, filler, maxLength) {
    const targetLen = maxLength + 1 - level.length;
    const rep = Math.floor(targetLen / filler.length);
    const padding = `${filler}${filler.repeat(rep)}`;
    return padding.slice(0, targetLen);
  }

  /**
   * Returns an object with the string paddings for the given `levels`
   * using the specified `filler`.
   * @param  {Object} levels Set of all levels to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @returns {Object} Mapping of level to desired padding.
   */
  static paddingForLevels(levels, filler = ' ') {
    const maxLength = Padder.getLongestLevel(levels);
    return Object.keys(levels).reduce((acc, level) => {
      acc[level] = Padder.paddingForLevel(level, filler, maxLength);
      return acc;
    }, {});
  }

  /**
   * Prepends the padding onto the `message` based on the `LEVEL` of
   * the `info`. This is based on the behavior of `winston@2` which also
   * prepended the level onto the message.
   *
   * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
   *
   * @param  {Info} info Logform info object
   * @param  {Object} opts Options passed along to this instance.
   * @returns {Info} Modified logform info object.
   */
  transform(info, opts) {
    info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
    if (info[MESSAGE]) {
      info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
    }

    return info;
  }
}

/*
 * function padLevels (info)
 * Returns a new instance of the padLevels Format which pads
 * levels to be the same length. This was previously exposed as
 * { padLevels: true } to transports in `winston < 3.0.0`.
 */
module.exports = opts => new Padder(opts);

module.exports.Padder
  = module.exports.Format
  = Padder;


/***/ }),

/***/ "../../node_modules/logform/pretty-print.js":
/*!**************************************************!*\
  !*** ../../node_modules/logform/pretty-print.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const inspect = (__webpack_require__(/*! util */ "util").inspect);
const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { LEVEL, MESSAGE, SPLAT } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/*
 * function prettyPrint (info)
 * Returns a new instance of the prettyPrint Format that "prettyPrint"
 * serializes `info` objects. This was previously exposed as
 * { prettyPrint: true } to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts = {}) => {
  //
  // info[{LEVEL, MESSAGE, SPLAT}] are enumerable here. Since they
  // are internal, we remove them before util.inspect so they
  // are not printed.
  //
  const stripped = Object.assign({}, info);

  // Remark (indexzero): update this technique in April 2019
  // when node@6 is EOL
  delete stripped[LEVEL];
  delete stripped[MESSAGE];
  delete stripped[SPLAT];

  info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
  return info;
});


/***/ }),

/***/ "../../node_modules/logform/printf.js":
/*!********************************************!*\
  !*** ../../node_modules/logform/printf.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

class Printf {
  constructor(templateFn) {
    this.template = templateFn;
  }

  transform(info) {
    info[MESSAGE] = this.template(info);
    return info;
  }
}

/*
 * function printf (templateFn)
 * Returns a new instance of the printf Format that creates an
 * intermediate prototype to store the template string-based formatter
 * function.
 */
module.exports = opts => new Printf(opts);

module.exports.Printf
  = module.exports.Format
  = Printf;


/***/ }),

/***/ "../../node_modules/logform/simple.js":
/*!********************************************!*\
  !*** ../../node_modules/logform/simple.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */


const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const jsonStringify = __webpack_require__(/*! safe-stable-stringify */ "../../node_modules/safe-stable-stringify/index.js");

/*
 * function simple (info)
 * Returns a new instance of the simple format TransformStream
 * which writes a simple representation of logs.
 *
 *    const { level, message, splat, ...rest } = info;
 *
 *    ${level}: ${message}                            if rest is empty
 *    ${level}: ${message} ${JSON.stringify(rest)}    otherwise
 */
module.exports = format(info => {
  const stringifiedRest = jsonStringify(Object.assign({}, info, {
    level: undefined,
    message: undefined,
    splat: undefined
  }));

  const padding = info.padding && info.padding[info.level] || '';
  if (stringifiedRest !== '{}') {
    info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
  } else {
    info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
  }

  return info;
});


/***/ }),

/***/ "../../node_modules/logform/splat.js":
/*!*******************************************!*\
  !*** ../../node_modules/logform/splat.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const { SPLAT } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */
const formatRegExp = /%[scdjifoO%]/g;

/**
 * Captures the number of escaped % signs in a format string (i.e. %s strings).
 * @type {RegExp}
 */
const escapedPercent = /%%/g;

class Splatter {
  constructor(opts) {
    this.options = opts;
  }

  /**
     * Check to see if tokens <= splat.length, assign { splat, meta } into the
     * `info` accordingly, and write to this instance.
     *
     * @param  {Info} info Logform info message.
     * @param  {String[]} tokens Set of string interpolation tokens.
     * @returns {Info} Modified info message
     * @private
     */
  _splat(info, tokens) {
    const msg = info.message;
    const splat = info[SPLAT] || info.splat || [];
    const percents = msg.match(escapedPercent);
    const escapes = percents && percents.length || 0;

    // The expected splat is the number of tokens minus the number of escapes
    // e.g.
    // - { expectedSplat: 3 } '%d %s %j'
    // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'
    //
    // Any "meta" will be arugments in addition to the expected splat size
    // regardless of type. e.g.
    //
    // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });
    // would result in splat of four (4), but only three (3) are expected. Therefore:
    //
    // extraSplat = 3 - 4 = -1
    // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);
    // splat = [100, 'wow', { such: 'js' }]
    const expectedSplat = tokens.length - escapes;
    const extraSplat = expectedSplat - splat.length;
    const metas = extraSplat < 0
      ? splat.splice(extraSplat, -1 * extraSplat)
      : [];

    // Now that { splat } has been separated from any potential { meta }. we
    // can assign this to the `info` object and write it to our format stream.
    // If the additional metas are **NOT** objects or **LACK** enumerable properties
    // you are going to have a bad time.
    const metalen = metas.length;
    if (metalen) {
      for (let i = 0; i < metalen; i++) {
        Object.assign(info, metas[i]);
      }
    }

    info.message = util.format(msg, ...splat);
    return info;
  }

  /**
    * Transforms the `info` message by using `util.format` to complete
    * any `info.message` provided it has string interpolation tokens.
    * If no tokens exist then `info` is immutable.
    *
    * @param  {Info} info Logform info message.
    * @param  {Object} opts Options for this instance.
    * @returns {Info} Modified info message
    */
  transform(info) {
    const msg = info.message;
    const splat = info[SPLAT] || info.splat;

    // No need to process anything if splat is undefined
    if (!splat || !splat.length) {
      return info;
    }

    // Extract tokens, if none available default to empty array to
    // ensure consistancy in expected results
    const tokens = msg && msg.match && msg.match(formatRegExp);

    // This condition will take care of inputs with info[SPLAT]
    // but no tokens present
    if (!tokens && (splat || splat.length)) {
      const metas = splat.length > 1
        ? splat.splice(0)
        : splat;

      // Now that { splat } has been separated from any potential { meta }. we
      // can assign this to the `info` object and write it to our format stream.
      // If the additional metas are **NOT** objects or **LACK** enumerable properties
      // you are going to have a bad time.
      const metalen = metas.length;
      if (metalen) {
        for (let i = 0; i < metalen; i++) {
          Object.assign(info, metas[i]);
        }
      }

      return info;
    }

    if (tokens) {
      return this._splat(info, tokens);
    }

    return info;
  }
}

/*
 * function splat (info)
 * Returns a new instance of the splat format TransformStream
 * which performs string interpolation from `info` objects. This was
 * previously exposed implicitly in `winston < 3.0.0`.
 */
module.exports = opts => new Splatter(opts);


/***/ }),

/***/ "../../node_modules/logform/timestamp.js":
/*!***********************************************!*\
  !*** ../../node_modules/logform/timestamp.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fecha = __webpack_require__(/*! fecha */ "../../node_modules/fecha/lib/fecha.js");
const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");

/*
 * function timestamp (info)
 * Returns a new instance of the timestamp Format which adds a timestamp
 * to the info. It was previously available in winston < 3.0.0 as:
 *
 * - { timestamp: true }             // `new Date.toISOString()`
 * - { timestamp: function:String }  // Value returned by `timestamp()`
 */
module.exports = format((info, opts = {}) => {
  if (opts.format) {
    info.timestamp = typeof opts.format === 'function'
      ? opts.format()
      : fecha.format(new Date(), opts.format);
  }

  if (!info.timestamp) {
    info.timestamp = new Date().toISOString();
  }

  if (opts.alias) {
    info[opts.alias] = info.timestamp;
  }

  return info;
});


/***/ }),

/***/ "../../node_modules/logform/uncolorize.js":
/*!************************************************!*\
  !*** ../../node_modules/logform/uncolorize.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(/*! @colors/colors/safe */ "../../node_modules/@colors/colors/safe.js");
const format = __webpack_require__(/*! ./format */ "../../node_modules/logform/format.js");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/*
 * function uncolorize (info)
 * Returns a new instance of the uncolorize Format that strips colors
 * from `info` objects. This was previously exposed as { stripColors: true }
 * to transports in `winston < 3.0.0`.
 */
module.exports = format((info, opts) => {
  if (opts.level !== false) {
    info.level = colors.strip(info.level);
  }

  if (opts.message !== false) {
    info.message = colors.strip(String(info.message));
  }

  if (opts.raw !== false && info[MESSAGE]) {
    info[MESSAGE] = colors.strip(String(info[MESSAGE]));
  }

  return info;
});


/***/ }),

/***/ "../../node_modules/ms/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ms/index.js ***!
  \**************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/one-time/index.js":
/*!********************************************!*\
  !*** ../../node_modules/one-time/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var name = __webpack_require__(/*! fn.name */ "../../node_modules/fn.name/index.js");

/**
 * Wrap callbacks to prevent double execution.
 *
 * @param {Function} fn Function that should only be called once.
 * @returns {Function} A wrapped callback which prevents multiple executions.
 * @public
 */
module.exports = function one(fn) {
  var called = 0
    , value;

  /**
   * The function that prevents double execution.
   *
   * @private
   */
  function onetime() {
    if (called) return value;

    called = 1;
    value = fn.apply(this, arguments);
    fn = null;

    return value;
  }

  //
  // To make debugging more easy we want to use the name of the supplied
  // function. So when you look at the functions that are assigned to event
  // listeners you don't see a load of `onetime` functions but actually the
  // names of the functions that this module will call.
  //
  // NOTE: We cannot override the `name` property, as that is `readOnly`
  // property, so displayName will have to do.
  //
  onetime.displayName = name(fn);
  return onetime;
};


/***/ }),

/***/ "../../node_modules/process/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/process/index.js ***!
  \*******************************************/
/***/ ((module) => {

// for now just expose the builtin process global from node.js
module.exports = global.process;


/***/ }),

/***/ "../../node_modules/reflect-metadata/Reflect.js":
/*!******************************************************!*\
  !*** ../../node_modules/reflect-metadata/Reflect.js ***!
  \******************************************************/
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process["env" + ""] && process["env" + ""]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "../../node_modules/safe-buffer/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/safe-buffer/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../../node_modules/safe-stable-stringify/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/safe-stable-stringify/index.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

"use strict";


const { hasOwnProperty } = Object.prototype

const stringify = configure()

// @ts-expect-error
stringify.configure = configure
// @ts-expect-error
stringify.stringify = stringify

// @ts-expect-error
stringify.default = stringify

// @ts-expect-error used for named export
exports.stringify = stringify
// @ts-expect-error used for named export
exports.configure = configure

module.exports = stringify

// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/

// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape (str) {
  // Some magic numbers that worked out fine while benchmarking with v8 8.0
  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
    return `"${str}"`
  }
  return JSON.stringify(str)
}

function sort (array, comparator) {
  // Insertion sort is very efficient for small input sizes, but it has a bad
  // worst case complexity. Thus, use native array sort for bigger values.
  if (array.length > 2e2 || comparator) {
    return array.sort(comparator)
  }
  for (let i = 1; i < array.length; i++) {
    const currentValue = array[i]
    let position = i
    while (position !== 0 && array[position - 1] > currentValue) {
      array[position] = array[position - 1]
      position--
    }
    array[position] = currentValue
  }
  return array
}

const typedArrayPrototypeGetSymbolToStringTag =
  Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get

function isTypedArrayWithEntries (value) {
  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
}

function stringifyTypedArray (array, separator, maximumBreadth) {
  if (array.length < maximumBreadth) {
    maximumBreadth = array.length
  }
  const whitespace = separator === ',' ? '' : ' '
  let res = `"0":${whitespace}${array[0]}`
  for (let i = 1; i < maximumBreadth; i++) {
    res += `${separator}"${i}":${whitespace}${array[i]}`
  }
  return res
}

function getCircularValueOption (options) {
  if (hasOwnProperty.call(options, 'circularValue')) {
    const circularValue = options.circularValue
    if (typeof circularValue === 'string') {
      return `"${circularValue}"`
    }
    if (circularValue == null) {
      return circularValue
    }
    if (circularValue === Error || circularValue === TypeError) {
      return {
        toString () {
          throw new TypeError('Converting circular structure to JSON')
        }
      }
    }
    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
  }
  return '"[Circular]"'
}

function getDeterministicOption (options) {
  let value
  if (hasOwnProperty.call(options, 'deterministic')) {
    value = options.deterministic
    if (typeof value !== 'boolean' && typeof value !== 'function') {
      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function')
    }
  }
  return value === undefined ? true : value
}

function getBooleanOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'boolean') {
      throw new TypeError(`The "${key}" argument must be of type boolean`)
    }
  }
  return value === undefined ? true : value
}

function getPositiveIntegerOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'number') {
      throw new TypeError(`The "${key}" argument must be of type number`)
    }
    if (!Number.isInteger(value)) {
      throw new TypeError(`The "${key}" argument must be an integer`)
    }
    if (value < 1) {
      throw new RangeError(`The "${key}" argument must be >= 1`)
    }
  }
  return value === undefined ? Infinity : value
}

function getItemCount (number) {
  if (number === 1) {
    return '1 item'
  }
  return `${number} items`
}

function getUniqueReplacerSet (replacerArray) {
  const replacerSet = new Set()
  for (const value of replacerArray) {
    if (typeof value === 'string' || typeof value === 'number') {
      replacerSet.add(String(value))
    }
  }
  return replacerSet
}

function getStrictOption (options) {
  if (hasOwnProperty.call(options, 'strict')) {
    const value = options.strict
    if (typeof value !== 'boolean') {
      throw new TypeError('The "strict" argument must be of type boolean')
    }
    if (value) {
      return (value) => {
        let message = `Object can not safely be stringified. Received type ${typeof value}`
        if (typeof value !== 'function') message += ` (${value.toString()})`
        throw new Error(message)
      }
    }
  }
}

function configure (options) {
  options = { ...options }
  const fail = getStrictOption(options)
  if (fail) {
    if (options.bigint === undefined) {
      options.bigint = false
    }
    if (!('circularValue' in options)) {
      options.circularValue = Error
    }
  }
  const circularValue = getCircularValueOption(options)
  const bigint = getBooleanOption(options, 'bigint')
  const deterministic = getDeterministicOption(options)
  const comparator = typeof deterministic === 'function' ? deterministic : undefined
  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')
  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')

  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
    let value = parent[key]

    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }
    value = replacer.call(parent, key, value)

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''
        let join = ','
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let whitespace = ''
        let separator = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (deterministic && !isTypedArrayWithEntries(value)) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        const originalIndentation = indentation
        let res = ''
        let join = ','

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }
        stack.push(value)
        let whitespace = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        let separator = ''
        for (const key of replacer) {
          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyIndent (key, value, stack, spacer, indentation) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again.
          if (typeof value !== 'object') {
            return stringifyIndent(key, value, stack, spacer, indentation)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          indentation += spacer
          let res = `\n${indentation}`
          const join = `,\n${indentation}`
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          res += `\n${originalIndentation}`
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        indentation += spacer
        const join = `,\n${indentation}`
        let res = ''
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, join, maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = join
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}: ${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (separator !== '') {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifySimple (key, value, stack) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again
          if (typeof value !== 'object') {
            return stringifySimple(key, value, stack)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''

        const hasLength = value.length !== undefined
        if (hasLength && Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifySimple(String(i), value[i], stack)
            res += tmp !== undefined ? tmp : 'null'
            res += ','
          }
          const tmp = stringifySimple(String(i), value[i], stack)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `,"... ${getItemCount(removedKeys)} not stringified"`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (hasLength && isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, ',', maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = ','
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifySimple(key, value[key], stack)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${tmp}`
            separator = ','
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringify (value, replacer, space) {
    if (arguments.length > 1) {
      let spacer = ''
      if (typeof space === 'number') {
        spacer = ' '.repeat(Math.min(space, 10))
      } else if (typeof space === 'string') {
        spacer = space.slice(0, 10)
      }
      if (replacer != null) {
        if (typeof replacer === 'function') {
          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
        }
        if (Array.isArray(replacer)) {
          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
        }
      }
      if (spacer.length !== 0) {
        return stringifyIndent('', value, [], spacer, '')
      }
    }
    return stringifySimple('', value, [])
  }

  return stringify
}


/***/ }),

/***/ "../../node_modules/simple-swizzle/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/simple-swizzle/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isArrayish = __webpack_require__(/*! is-arrayish */ "../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js");

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};


/***/ }),

/***/ "../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/action-handler.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/action-handler.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerActionHandlerRegistry = void 0;
/**
 * Use this service to register handlers to specific actions. The `DiagramServer` queries this registry
 * when an action is received from the client, and falls back to the built-in behavior if no handlers
 * are found.
 */
class ServerActionHandlerRegistry {
    constructor() {
        this.handlers = new Map();
    }
    /**
     * Returns the action handlers for the given action kind, or `undefined` if there are none.
     */
    getHandler(kind) {
        return this.handlers.get(kind);
    }
    /**
     * Add an action handler to be called when an action of the specified kind is received.
     */
    onAction(kind, handler) {
        if (this.handlers.has(kind)) {
            this.handlers.get(kind).push(handler);
        }
        else {
            this.handlers.set(kind, [handler]);
        }
    }
    /**
     * Remove an action handler that was previously added with `onAction`.
     */
    removeActionHandler(kind, handler) {
        const list = this.handlers.get(kind);
        if (list) {
            const index = list.indexOf(handler);
            if (index >= 0) {
                list.splice(index, 1);
            }
        }
    }
}
exports.ServerActionHandlerRegistry = ServerActionHandlerRegistry;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/actions.js":
/*!**********************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/actions.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
const object_1 = __webpack_require__(/*! ./utils/object */ "../../node_modules/sprotty-protocol/lib/utils/object.js");
function isActionMessage(object) {
    return (0, object_1.hasOwnProperty)(object, 'action');
}
exports.isActionMessage = isActionMessage;
function isAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'kind', 'string');
}
exports.isAction = isAction;
function isRequestAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'requestId', 'string');
}
exports.isRequestAction = isRequestAction;
let requestContext = '';
let nextRequestId = 1;
/**
 * Generate a unique `requestId` for a request action.
 */
function generateRequestId() {
    return `${requestContext}_${nextRequestId++}`;
}
exports.generateRequestId = generateRequestId;
/**
 * Configure the context in which request actions are created. This is typically either
 * 'client' or 'server' to avoid collisions of request IDs.
 */
function setRequestContext(context) {
    requestContext = context;
}
exports.setRequestContext = setRequestContext;
/**
 * A response action is sent to respond to a request action. The `responseId` must match
 * the `requestId` of the preceding request. In case the `responseId` is empty or undefined,
 * the action is handled as standalone, i.e. it was fired without a preceding request.
 */
function isResponseAction(object) {
    return (0, object_1.hasOwnProperty)(object, 'responseId', 'string') && object.responseId !== '';
}
exports.isResponseAction = isResponseAction;
var RejectAction;
(function (RejectAction) {
    RejectAction.KIND = 'rejectRequest';
    function create(options) {
        return {
            kind: RejectAction.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
        };
    }
    RejectAction.create = create;
})(RejectAction || (exports.RejectAction = RejectAction = {}));
var RequestModelAction;
(function (RequestModelAction) {
    RequestModelAction.KIND = 'requestModel';
    function create(options) {
        return {
            kind: RequestModelAction.KIND,
            options,
            requestId: generateRequestId()
        };
    }
    RequestModelAction.create = create;
})(RequestModelAction || (exports.RequestModelAction = RequestModelAction = {}));
var SetModelAction;
(function (SetModelAction) {
    SetModelAction.KIND = 'setModel';
    function create(newRoot, requestId = '') {
        return {
            kind: SetModelAction.KIND,
            newRoot,
            responseId: requestId
        };
    }
    SetModelAction.create = create;
})(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
var UpdateModelAction;
(function (UpdateModelAction) {
    UpdateModelAction.KIND = 'updateModel';
    function create(input, options = {}) {
        if (Array.isArray(input)) {
            return {
                kind: UpdateModelAction.KIND,
                matches: input,
                animate: options.animate,
                cause: options.cause
            };
        }
        else {
            return {
                kind: UpdateModelAction.KIND,
                newRoot: input,
                animate: options.animate,
                cause: options.cause
            };
        }
    }
    UpdateModelAction.create = create;
})(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
var RequestPopupModelAction;
(function (RequestPopupModelAction) {
    RequestPopupModelAction.KIND = 'requestPopupModel';
    function create(options) {
        return {
            kind: RequestPopupModelAction.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
        };
    }
    RequestPopupModelAction.create = create;
})(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
var SetPopupModelAction;
(function (SetPopupModelAction) {
    SetPopupModelAction.KIND = 'setPopupModel';
    function create(newRoot, requestId = '') {
        return {
            kind: SetPopupModelAction.KIND,
            newRoot,
            responseId: requestId
        };
    }
    SetPopupModelAction.create = create;
})(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
var SetBoundsAction;
(function (SetBoundsAction) {
    SetBoundsAction.KIND = 'setBounds';
    function create(bounds) {
        return {
            kind: SetBoundsAction.KIND,
            bounds
        };
    }
    SetBoundsAction.create = create;
})(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
var RequestBoundsAction;
(function (RequestBoundsAction) {
    RequestBoundsAction.KIND = 'requestBounds';
    function create(newRoot) {
        return {
            kind: RequestBoundsAction.KIND,
            newRoot,
            requestId: generateRequestId()
        };
    }
    RequestBoundsAction.create = create;
})(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
var ComputedBoundsAction;
(function (ComputedBoundsAction) {
    ComputedBoundsAction.KIND = 'computedBounds';
    function create(bounds, options = {}) {
        var _a;
        return {
            kind: ComputedBoundsAction.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a = options.requestId) !== null && _a !== void 0 ? _a : ''
        };
    }
    ComputedBoundsAction.create = create;
})(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
var LoggingAction;
(function (LoggingAction) {
    LoggingAction.KIND = 'logging';
    function create(options) {
        return Object.assign({ kind: LoggingAction.KIND }, options);
    }
    LoggingAction.create = create;
})(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
var SelectAction;
(function (SelectAction) {
    SelectAction.KIND = 'elementSelected';
    function create(options) {
        var _a, _b;
        return {
            kind: SelectAction.KIND,
            selectedElementsIDs: (_a = options.selectedElementsIDs) !== null && _a !== void 0 ? _a : [],
            deselectedElementsIDs: (_b = options.deselectedElementsIDs) !== null && _b !== void 0 ? _b : []
        };
    }
    SelectAction.create = create;
})(SelectAction || (exports.SelectAction = SelectAction = {}));
var SelectAllAction;
(function (SelectAllAction) {
    SelectAllAction.KIND = 'allSelected';
    function create(options = {}) {
        var _a;
        return {
            kind: SelectAllAction.KIND,
            select: (_a = options.select) !== null && _a !== void 0 ? _a : true
        };
    }
    SelectAllAction.create = create;
})(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
var GetSelectionAction;
(function (GetSelectionAction) {
    GetSelectionAction.KIND = 'getSelection';
    function create() {
        return {
            kind: GetSelectionAction.KIND,
            requestId: generateRequestId()
        };
    }
    GetSelectionAction.create = create;
})(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
var SelectionResult;
(function (SelectionResult) {
    SelectionResult.KIND = 'selectionResult';
    function create(selectedElementsIDs, requestId) {
        return {
            kind: SelectionResult.KIND,
            selectedElementsIDs,
            responseId: requestId
        };
    }
    SelectionResult.create = create;
})(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
var CollapseExpandAction;
(function (CollapseExpandAction) {
    CollapseExpandAction.KIND = 'collapseExpand';
    function create(options) {
        var _a, _b;
        return {
            kind: CollapseExpandAction.KIND,
            expandIds: (_a = options.expandIds) !== null && _a !== void 0 ? _a : [],
            collapseIds: (_b = options.collapseIds) !== null && _b !== void 0 ? _b : []
        };
    }
    CollapseExpandAction.create = create;
})(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
var CollapseExpandAllAction;
(function (CollapseExpandAllAction) {
    CollapseExpandAllAction.KIND = 'collapseExpandAll';
    function create(options = {}) {
        var _a;
        return {
            kind: CollapseExpandAllAction.KIND,
            expand: (_a = options.expand) !== null && _a !== void 0 ? _a : true
        };
    }
    CollapseExpandAllAction.create = create;
})(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
var OpenAction;
(function (OpenAction) {
    OpenAction.KIND = 'open';
    function create(elementId) {
        return {
            kind: OpenAction.KIND,
            elementId
        };
    }
    OpenAction.create = create;
})(OpenAction || (exports.OpenAction = OpenAction = {}));
var LayoutAction;
(function (LayoutAction) {
    LayoutAction.KIND = 'layout';
    function create(options = {}) {
        return {
            kind: LayoutAction.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
        };
    }
    LayoutAction.create = create;
})(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
var CenterAction;
(function (CenterAction) {
    CenterAction.KIND = 'center';
    function create(elementIds, options = {}) {
        var _a, _b;
        return {
            kind: CenterAction.KIND,
            elementIds,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            retainZoom: (_b = options.retainZoom) !== null && _b !== void 0 ? _b : false,
            zoomScale: options.zoomScale
        };
    }
    CenterAction.create = create;
})(CenterAction || (exports.CenterAction = CenterAction = {}));
var FitToScreenAction;
(function (FitToScreenAction) {
    FitToScreenAction.KIND = 'fit';
    function create(elementIds, options = {}) {
        var _a;
        return {
            kind: FitToScreenAction.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
        };
    }
    FitToScreenAction.create = create;
})(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
var SetViewportAction;
(function (SetViewportAction) {
    SetViewportAction.KIND = 'viewport';
    function create(elementId, newViewport, options = {}) {
        var _a;
        return {
            kind: SetViewportAction.KIND,
            elementId,
            newViewport,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true
        };
    }
    SetViewportAction.create = create;
})(SetViewportAction || (exports.SetViewportAction = SetViewportAction = {}));
var GetViewportAction;
(function (GetViewportAction) {
    GetViewportAction.KIND = 'getViewport';
    function create() {
        return {
            kind: GetViewportAction.KIND,
            requestId: generateRequestId()
        };
    }
    GetViewportAction.create = create;
})(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
var ViewportResult;
(function (ViewportResult) {
    ViewportResult.KIND = 'viewportResult';
    function create(viewport, canvasBounds, requestId) {
        return {
            kind: ViewportResult.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
        };
    }
    ViewportResult.create = create;
})(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
var BringToFrontAction;
(function (BringToFrontAction) {
    BringToFrontAction.KIND = 'bringToFront';
    function create(elementIDs) {
        return {
            kind: BringToFrontAction.KIND,
            elementIDs
        };
    }
    BringToFrontAction.create = create;
})(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
var UndoAction;
(function (UndoAction) {
    UndoAction.KIND = 'undo';
    function create() {
        return {
            kind: UndoAction.KIND
        };
    }
    UndoAction.create = create;
})(UndoAction || (exports.UndoAction = UndoAction = {}));
var RedoAction;
(function (RedoAction) {
    RedoAction.KIND = 'redo';
    function create() {
        return {
            kind: RedoAction.KIND
        };
    }
    RedoAction.create = create;
})(RedoAction || (exports.RedoAction = RedoAction = {}));
var MoveAction;
(function (MoveAction) {
    MoveAction.KIND = 'move';
    function create(moves, options = {}) {
        var _a, _b, _c;
        return {
            kind: MoveAction.KIND,
            moves,
            animate: (_a = options.animate) !== null && _a !== void 0 ? _a : true,
            finished: (_b = options.finished) !== null && _b !== void 0 ? _b : false,
            stoppable: (_c = options.stoppable) !== null && _c !== void 0 ? _c : false
        };
    }
    MoveAction.create = create;
})(MoveAction || (exports.MoveAction = MoveAction = {}));
var HoverFeedbackAction;
(function (HoverFeedbackAction) {
    HoverFeedbackAction.KIND = 'hoverFeedback';
    function create(options) {
        return {
            kind: HoverFeedbackAction.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
        };
    }
    HoverFeedbackAction.create = create;
})(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
var CreateElementAction;
(function (CreateElementAction) {
    CreateElementAction.KIND = 'createElement';
    function create(elementSchema, options) {
        return {
            kind: CreateElementAction.KIND,
            elementSchema,
            containerId: options.containerId
        };
    }
    CreateElementAction.create = create;
})(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
var DeleteElementAction;
(function (DeleteElementAction) {
    DeleteElementAction.KIND = 'delete';
    function create(elementIds) {
        return {
            kind: DeleteElementAction.KIND,
            elementIds
        };
    }
    DeleteElementAction.create = create;
})(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
var ApplyLabelEditAction;
(function (ApplyLabelEditAction) {
    ApplyLabelEditAction.KIND = 'applyLabelEdit';
    function create(labelId, text) {
        return {
            kind: ApplyLabelEditAction.KIND,
            labelId,
            text
        };
    }
    ApplyLabelEditAction.create = create;
})(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
var ReconnectAction;
(function (ReconnectAction) {
    ReconnectAction.KIND = 'reconnect';
    function create(options) {
        return {
            kind: ReconnectAction.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
        };
    }
    ReconnectAction.create = create;
})(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/diagram-server.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/diagram-server.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagramServer = void 0;
const actions_1 = __webpack_require__(/*! ./actions */ "../../node_modules/sprotty-protocol/lib/actions.js");
const async_1 = __webpack_require__(/*! ./utils/async */ "../../node_modules/sprotty-protocol/lib/utils/async.js");
const model_utils_1 = __webpack_require__(/*! ./utils/model-utils */ "../../node_modules/sprotty-protocol/lib/utils/model-utils.js");
/**
 * An instance of this class is responsible for handling a single diagram client. It holds the current
 * state of the diagram and manages communication with the client via actions.
 */
class DiagramServer {
    constructor(dispatch, services) {
        this.state = {
            currentRoot: {
                type: 'NONE',
                id: 'ROOT'
            },
            revision: 0
        };
        this.requests = new Map();
        this.dispatch = dispatch;
        this.diagramGenerator = services.DiagramGenerator;
        this.layoutEngine = services.ModelLayoutEngine;
        this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
    }
    /**
     * Set the model and submit it to the client.
     */
    setModel(newRoot) {
        newRoot.revision = ++this.state.revision;
        this.state.currentRoot = newRoot;
        return this.submitModel(newRoot, false);
    }
    /**
     * Update the model to a new state and submit it to the client.
     */
    updateModel(newRoot) {
        newRoot.revision = ++this.state.revision;
        this.state.currentRoot = newRoot;
        return this.submitModel(newRoot, true);
    }
    /**
     * Whether the client needs to compute the layout of parts of the model. This affects the behavior
     * of `submitModel`.
     *
     * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
     * from the client. If the client does not specify whether it needs client layout, the default value
     * is `true`.
     */
    get needsClientLayout() {
        if (this.state.options && this.state.options.needsClientLayout !== undefined) {
            return !!this.state.options.needsClientLayout;
        }
        return true;
    }
    /**
     * Whether the server needs to compute the layout of parts of the model. This affects the behavior
     * of `submitModel`.
     *
     * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
     * from the client. If the client does not specify whether it needs server layout, the default value
     * is `false`.
     */
    get needsServerLayout() {
        if (this.state.options && this.state.options.needsServerLayout !== undefined) {
            return !!this.state.options.needsServerLayout;
        }
        return false;
    }
    /**
     * Called when an action is received from the client.
     */
    accept(action) {
        if ((0, actions_1.isResponseAction)(action)) {
            const id = action.responseId;
            const future = this.requests.get(id);
            if (future) {
                this.requests.delete(id);
                if (action.kind === actions_1.RejectAction.KIND) {
                    const rejectAction = action;
                    future.reject(new Error(rejectAction.message));
                    console.warn(`Request with id ${action.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
                }
                else {
                    future.resolve(action);
                }
                return Promise.resolve();
            }
            console.info('No matching request for response:', action);
        }
        return this.handleAction(action);
    }
    /**
     * Send a request action to the client. The resulting promise is resolved when a matching
     * response is received and rejected when a `RejectAction` is received.
     */
    request(action) {
        if (!action.requestId) {
            action.requestId = 'server_' + (0, actions_1.generateRequestId)();
        }
        const future = new async_1.Deferred();
        this.requests.set(action.requestId, future);
        this.dispatch(action).catch(err => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.requests.delete(action.requestId);
            future.reject(err);
        });
        return future.promise;
    }
    /**
     * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
     */
    rejectRemoteRequest(action, error) {
        if (action && (0, actions_1.isRequestAction)(action)) {
            this.dispatch({
                kind: actions_1.RejectAction.KIND,
                responseId: action.requestId,
                message: error.message,
                detail: error.stack
            });
        }
    }
    handleAction(action) {
        var _a, _b;
        // Find a matching action handler in the registry
        const handlers = (_a = this.actionHandlerRegistry) === null || _a === void 0 ? void 0 : _a.getHandler(action.kind);
        if (handlers && handlers.length === 1) {
            return (_b = handlers[0](action, this.state, this)) !== null && _b !== void 0 ? _b : Promise.resolve();
        }
        else if (handlers && handlers.length > 1) {
            return Promise.all(handlers.map(h => { var _a; return (_a = h(action, this.state, this)) !== null && _a !== void 0 ? _a : Promise.resolve(); }));
        }
        // If no handler is registered, call one of the default handling methods
        switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
                return this.handleRequestModel(action);
            case actions_1.ComputedBoundsAction.KIND:
                return this.handleComputedBounds(action);
            case actions_1.LayoutAction.KIND:
                return this.handleLayout(action);
        }
        // We don't know this action kind, sigh
        console.warn(`Unhandled action from client: ${action.kind}`);
        return Promise.resolve();
    }
    async handleRequestModel(action) {
        var _a;
        this.state.options = action.options;
        try {
            const newRoot = await this.diagramGenerator.generate({
                options: (_a = this.state.options) !== null && _a !== void 0 ? _a : {},
                state: this.state
            });
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
            await this.submitModel(this.state.currentRoot, false, action);
        }
        catch (err) {
            this.rejectRemoteRequest(action, err);
            console.error('Failed to generate diagram:', err);
        }
    }
    /**
     * Submit a model to the client after it has been updated in the server state.
     */
    async submitModel(newRoot, update, cause) {
        if (this.needsClientLayout) {
            if (!this.needsServerLayout) {
                // In this case the client won't send us the computed bounds
                this.dispatch({ kind: actions_1.RequestBoundsAction.KIND, newRoot });
            }
            else {
                const request = actions_1.RequestBoundsAction.create(newRoot);
                const response = await this.request(request);
                const currentRoot = this.state.currentRoot;
                if (response.revision === currentRoot.revision) {
                    (0, model_utils_1.applyBounds)(currentRoot, response);
                    await this.doSubmitModel(currentRoot, update, cause);
                }
                else {
                    this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
                }
            }
        }
        else {
            await this.doSubmitModel(newRoot, update, cause);
        }
    }
    async doSubmitModel(newRoot, update, cause) {
        if (newRoot.revision !== this.state.revision) {
            return;
        }
        if (this.needsServerLayout && this.layoutEngine) {
            newRoot = await this.layoutEngine.layout(newRoot);
        }
        const modelType = newRoot.type;
        if (cause && cause.kind === actions_1.RequestModelAction.KIND) {
            const requestId = cause.requestId;
            const response = actions_1.SetModelAction.create(newRoot, requestId);
            await this.dispatch(response);
        }
        else if (update && modelType === this.state.lastSubmittedModelType) {
            await this.dispatch({ kind: actions_1.UpdateModelAction.KIND, newRoot, cause });
        }
        else {
            await this.dispatch({ kind: actions_1.SetModelAction.KIND, newRoot });
        }
        this.state.lastSubmittedModelType = modelType;
    }
    handleComputedBounds(action) {
        if (action.revision !== this.state.currentRoot.revision) {
            return Promise.reject();
        }
        (0, model_utils_1.applyBounds)(this.state.currentRoot, action);
        return Promise.resolve();
    }
    async handleLayout(action) {
        if (!this.layoutEngine) {
            return;
        }
        if (!this.needsServerLayout) {
            let newRoot = (0, model_utils_1.cloneModel)(this.state.currentRoot);
            newRoot = await this.layoutEngine.layout(newRoot);
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
        }
        await this.doSubmitModel(this.state.currentRoot, true, action);
    }
}
exports.DiagramServer = DiagramServer;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/diagram-services.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/diagram-services.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./action-handler */ "../../node_modules/sprotty-protocol/lib/action-handler.js"), exports);
__exportStar(__webpack_require__(/*! ./actions */ "../../node_modules/sprotty-protocol/lib/actions.js"), exports);
__exportStar(__webpack_require__(/*! ./diagram-server */ "../../node_modules/sprotty-protocol/lib/diagram-server.js"), exports);
__exportStar(__webpack_require__(/*! ./diagram-services */ "../../node_modules/sprotty-protocol/lib/diagram-services.js"), exports);
__exportStar(__webpack_require__(/*! ./model */ "../../node_modules/sprotty-protocol/lib/model.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/async */ "../../node_modules/sprotty-protocol/lib/utils/async.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/geometry */ "../../node_modules/sprotty-protocol/lib/utils/geometry.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/json */ "../../node_modules/sprotty-protocol/lib/utils/json.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/model-utils */ "../../node_modules/sprotty-protocol/lib/utils/model-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/object */ "../../node_modules/sprotty-protocol/lib/utils/object.js"), exports);


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/model.js":
/*!********************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/model.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021-2023 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isZoomable = exports.isScrollable = void 0;
const object_1 = __webpack_require__(/*! ./utils/object */ "../../node_modules/sprotty-protocol/lib/utils/object.js");
function isScrollable(element) {
    return (0, object_1.hasOwnProperty)(element, 'scroll');
}
exports.isScrollable = isScrollable;
function isZoomable(element) {
    return (0, object_1.hasOwnProperty)(element, 'zoom');
}
exports.isZoomable = isZoomable;
;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/utils/async.js":
/*!**************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/utils/async.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
class Deferred {
    constructor() {
        this._state = 'unresolved';
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
        this.promise.then(res => this._state = 'resolved', rej => this._state = 'rejected');
    }
    set state(state) {
        if (this._state === 'unresolved') {
            this._state = state;
        }
    }
    get state() {
        return this._state;
    }
}
exports.Deferred = Deferred;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/utils/geometry.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/utils/geometry.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
const object_1 = __webpack_require__(/*! ./object */ "../../node_modules/sprotty-protocol/lib/utils/object.js");
var Point;
(function (Point) {
    /**
     * (x,y) coordinates of the origin.
     */
    Point.ORIGIN = Object.freeze({
        x: 0,
        y: 0
    });
    /**
     * Adds two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The sum of the two points
     */
    function add(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    }
    Point.add = add;
    /**
     * Subtracts two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The difference of the two points
     */
    function subtract(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    }
    Point.subtract = subtract;
    /**
     * Specifies whether a point has exactly the same coordinates as another point.
     * @param {Point} point1 a point
     * @param {Point} point2 another point
     * @returns {boolean} `true` if `point1` has exactly the same `x` and `y` values as `point2`, `false` otherwise.
     */
    function equals(point1, point2) {
        return point1.x === point2.x && point1.y === point2.y;
    }
    Point.equals = equals;
    /**
     * Computes a point that is the original `point` shifted towards `refPoint` by the given `distance`.
     * @param {Point} point - Point to shift
     * @param {Point} refPoint - Point to shift towards
     * @param {Point} distance - Distance to shift
     */
    function shiftTowards(point, refPoint, distance) {
        const diff = subtract(refPoint, point);
        const normalized = normalize(diff);
        const shift = { x: normalized.x * distance, y: normalized.y * distance };
        return add(point, shift);
    }
    Point.shiftTowards = shiftTowards;
    /**
     * Computes the normalized vector from the vector given in `point`; that is, computing its unit vector.
     * @param {Point} point - Point representing the vector to be normalized
     * @returns {Point} The normalized point
     */
    function normalize(point) {
        const mag = magnitude(point);
        if (mag === 0 || mag === 1) {
            return Point.ORIGIN;
        }
        return {
            x: point.x / mag,
            y: point.y / mag
        };
    }
    Point.normalize = normalize;
    /**
     * Computes the magnitude of the vector given in `point`.
     * @param {Point} point - Point representing the vector to compute the magnitude for
     * @returns {number} The magnitude or also known as length of the `point`
     */
    function magnitude(point) {
        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
    }
    Point.magnitude = magnitude;
    /**
     * Calculates a linear combination of p0 and p1 using lambda, i.e.
     *   (1-lambda) * p0 + lambda * p1
     */
    function linear(p0, p1, lambda) {
        return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
        };
    }
    Point.linear = linear;
    /**
     * Returns the "straight line" distance between two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Eucledian distance
     */
    function euclideanDistance(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    Point.euclideanDistance = euclideanDistance;
    /**
     * Returns the distance between two points in a grid, using a
     * strictly vertical and/or horizontal path (versus straight line).
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Manhattan distance
     */
    function manhattanDistance(a, b) {
        return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);
    }
    Point.manhattanDistance = manhattanDistance;
    /**
     * Returns the maximum of the horizontal and the vertical distance.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The maximum distance
     */
    function maxDistance(a, b) {
        return Math.max(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }
    Point.maxDistance = maxDistance;
    /**
     * Returns the dot product of two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The dot product
     */
    function dotProduct(a, b) {
        return a.x * b.x + a.y * b.y;
    }
    Point.dotProduct = dotProduct;
})(Point || (exports.Point = Point = {}));
/**
 * Computes the angle in radians of the given point to the x-axis of the coordinate system.
 * The result is in the range [-pi, pi].
 * @param {Point} p - A point in the Eucledian plane
 */
function angleOfPoint(p) {
    return Math.atan2(p.y, p.x);
}
exports.angleOfPoint = angleOfPoint;
/**
 * Computes the angle in radians between the two given points (relative to the origin of the coordinate system).
 * The result is in the range [0, pi]. Returns NaN if the points are equal.
 * @param {Point} a - First point
 * @param {Point} b - Second point
 */
function angleBetweenPoints(a, b) {
    const lengthProduct = Math.sqrt((a.x * a.x + a.y * a.y) * (b.x * b.x + b.y * b.y));
    if (isNaN(lengthProduct) || lengthProduct === 0)
        return NaN;
    const dotProduct = a.x * b.x + a.y * b.y;
    return Math.acos(dotProduct / lengthProduct);
}
exports.angleBetweenPoints = angleBetweenPoints;
/**
 * Computes the center of the line segment spanned by the two given points.
 * @param {Point} s - Start point of the line
 * @param {Point} e - End point of the line
 */
function centerOfLine(s, e) {
    const b = {
        x: s.x > e.x ? e.x : s.x,
        y: s.y > e.y ? e.y : s.y,
        width: Math.abs(e.x - s.x),
        height: Math.abs(e.y - s.y)
    };
    return Bounds.center(b);
}
exports.centerOfLine = centerOfLine;
var Dimension;
(function (Dimension) {
    /**
     * A dimension with both width and height set to a negative value, which is considered as undefined.
     */
    Dimension.EMPTY = Object.freeze({
        width: -1,
        height: -1
    });
    /**
     * Checks whether the given dimention is valid, i.e. the width and height are non-zero.
     * @param {Dimension} b - Dimension object
     * @returns {boolean} `true` if the dimension is valid
     */
    function isValid(d) {
        return d.width >= 0 && d.height >= 0;
    }
    Dimension.isValid = isValid;
})(Dimension || (exports.Dimension = Dimension = {}));
function isBounds(element) {
    return (0, object_1.hasOwnProperty)(element, ['x', 'y', 'width', 'height']);
}
exports.isBounds = isBounds;
var Bounds;
(function (Bounds) {
    Bounds.EMPTY = Object.freeze({
        x: 0,
        y: 0,
        width: -1,
        height: -1
    });
    /**
     * Combines the bounds of two objects into one, so that the new bounds
     * are the minimum bounds that covers both of the original bounds.
     * @param {Bounds} b0 - First bounds object
     * @param {Bounds} b1 - Second bounds object
     * @returns {Bounds} The combined bounds
     */
    function combine(b0, b1) {
        if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds.EMPTY;
        if (!Dimension.isValid(b1))
            return b0;
        const minX = Math.min(b0.x, b1.x);
        const minY = Math.min(b0.y, b1.y);
        const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
        const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
        return {
            x: minX, y: minY, width: maxX - minX, height: maxY - minY
        };
    }
    Bounds.combine = combine;
    /**
     * Translates the given bounds.
     * @param {Bounds} b - Bounds object
     * @param {Point} p - Vector by which to translate the bounds
     * @returns {Bounds} The translated bounds
     */
    function translate(b, p) {
        return {
            x: b.x + p.x,
            y: b.y + p.y,
            width: b.width,
            height: b.height
        };
    }
    Bounds.translate = translate;
    /**
     * Returns the center point of the bounds of an object
     * @param {Bounds} b - Bounds object
     * @returns {Point} the center point
     */
    function center(b) {
        return {
            x: b.x + (b.width >= 0 ? 0.5 * b.width : 0),
            y: b.y + (b.height >= 0 ? 0.5 * b.height : 0)
        };
    }
    Bounds.center = center;
    /**
    * Checks whether the point p is included in the bounds b.
    */
    function includes(b, p) {
        return p.x >= b.x && p.x <= b.x + b.width && p.y >= b.y && p.y <= b.y + b.height;
    }
    Bounds.includes = includes;
})(Bounds || (exports.Bounds = Bounds = {}));
/**
 * Converts from radians to degrees
 * @param {number} a - A value in radians
 * @returns {number} The converted value
 */
function toDegrees(a) {
    return a * 180 / Math.PI;
}
exports.toDegrees = toDegrees;
/**
 * Converts from degrees to radians
 * @param {number} a - A value in degrees
 * @returns {number} The converted value
 */
function toRadians(a) {
    return a * Math.PI / 180;
}
exports.toRadians = toRadians;
/**
 * Returns whether two numbers are almost equal, within a small margin (0.001)
 * @param {number} a - First number
 * @param {number} b - Second number
 * @returns {boolean} True if the two numbers are almost equal
 */
function almostEquals(a, b) {
    return Math.abs(a - b) < 1e-3;
}
exports.almostEquals = almostEquals;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/utils/json.js":
/*!*************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/utils/json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2020-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/utils/model-utils.js":
/*!********************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/utils/model-utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
/**
 * Clone a given model. This function requires that the model is serializable, so it's
 * free of cycles and functions.
 */
function cloneModel(model) {
    return JSON.parse(JSON.stringify(model));
}
exports.cloneModel = cloneModel;
/**
 * Apply the computed bounds to the given model. This ensures that the model has complete
 * information about positions and sizes derived from its actual rendering in the frontend.
 */
function applyBounds(root, action) {
    const index = new SModelIndex();
    index.add(root);
    for (const b of action.bounds) {
        const element = index.getById(b.elementId);
        if (element) {
            const bae = element;
            if (b.newPosition) {
                bae.position = { x: b.newPosition.x, y: b.newPosition.y };
            }
            if (b.newSize) {
                bae.size = { width: b.newSize.width, height: b.newSize.height };
            }
        }
    }
    if (action.alignments) {
        for (const a of action.alignments) {
            const element = index.getById(a.elementId);
            if (element) {
                const alignable = element;
                alignable.alignment = { x: a.newAlignment.x, y: a.newAlignment.y };
            }
        }
    }
}
exports.applyBounds = applyBounds;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the basic type of a model element.
 */
function getBasicType(element) {
    if (!element.type) {
        return '';
    }
    const colonIndex = element.type.indexOf(':');
    return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
}
exports.getBasicType = getBasicType;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the sub-type of a model element.
 */
function getSubType(schema) {
    if (!schema.type) {
        return '';
    }
    const colonIndex = schema.type.indexOf(':');
    return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
}
exports.getSubType = getSubType;
/**
 * Find the element with the given identifier. If you need to find multiple elements, using an
 * `SModelIndex` might be more effective.
 */
function findElement(parent, elementId) {
    if (parent.id === elementId) {
        return parent;
    }
    if (parent.children) {
        for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== undefined) {
                return result;
            }
        }
    }
    return undefined;
}
exports.findElement = findElement;
/**
 * Used to speed up model element lookup by id.
 * This index implementation is for the serializable _external model_ defined in `sprotty-protocol`.
 */
class SModelIndex {
    constructor() {
        this.id2element = new Map();
        this.id2parent = new Map();
    }
    add(element) {
        if (!element.id) {
            throw new Error("Model element has no ID.");
        }
        else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
        }
        this.id2element.set(element.id, element);
        if (Array.isArray(element.children)) {
            for (const child of element.children) {
                this.add(child);
                this.id2parent.set(child.id, element);
            }
        }
        return this;
    }
    remove(element) {
        this.id2element.delete(element.id);
        if (Array.isArray(element.children)) {
            for (const child of element.children) {
                this.id2parent.delete(child.id);
                this.remove(child);
            }
        }
        return this;
    }
    contains(element) {
        return this.id2element.has(element.id);
    }
    getById(id) {
        return this.id2element.get(id);
    }
    getParent(id) {
        return this.id2parent.get(id);
    }
    getRoot(element) {
        let current = element;
        while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === undefined) {
                return current;
            }
            current = parent;
        }
        throw new Error("Element has no root");
    }
}
exports.SModelIndex = SModelIndex;


/***/ }),

/***/ "../../node_modules/sprotty-protocol/lib/utils/object.js":
/*!***************************************************************!*\
  !*** ../../node_modules/sprotty-protocol/lib/utils/object.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
function isObject(data) {
    return typeof data === 'object' && data !== null;
}
exports.isObject = isObject;
function hasOwnProperty(arg, key, type) {
    if (!isObject(arg)) {
        return false;
    }
    if (Array.isArray(key)) {
        for (const k of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k)) {
                return false;
            }
            if (typeof type === 'string' && typeof arg[k] !== type) {
                return false;
            }
            else if (typeof type === 'function' && !type(arg[k])) {
                return false;
            }
        }
    }
    else {
        if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
        }
        if (typeof type === 'string') {
            return typeof arg[key] === type;
        }
        if (typeof type === 'function') {
            return type(arg[key]);
        }
    }
    return true;
}
exports.hasOwnProperty = hasOwnProperty;
function safeAssign(target, partial) {
    return Object.assign(target, partial);
}
exports.safeAssign = safeAssign;


/***/ }),

/***/ "../../node_modules/stack-trace/lib/stack-trace.js":
/*!*********************************************************!*\
  !*** ../../node_modules/stack-trace/lib/stack-trace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.get = function(belowFn) {
  var oldLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;

  var dummyObject = {};

  var v8Handler = Error.prepareStackTrace;
  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
    return v8StackTrace;
  };
  Error.captureStackTrace(dummyObject, belowFn || exports.get);

  var v8StackTrace = dummyObject.stack;
  Error.prepareStackTrace = v8Handler;
  Error.stackTraceLimit = oldLimit;

  return v8StackTrace;
};

exports.parse = function(err) {
  if (!err.stack) {
    return [];
  }

  var self = this;
  var lines = err.stack.split('\n').slice(1);

  return lines
    .map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          'native': null,
        });
      }

      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }

      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = (lineMatch[5] === 'native');

      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf('.');
        if (functionName[methodStart-1] == '.')
          methodStart--;
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf('.Module');
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }

      if (method) {
        typeName = object;
        methodName = method;
      }

      if (method === '<anonymous>') {
        methodName = null;
        functionName = null;
      }

      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName: functionName,
        typeName: typeName,
        methodName: methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        'native': isNative,
      };

      return self._createParsedCallSite(properties);
    })
    .filter(function(callSite) {
      return !!callSite;
    });
};

function CallSite(properties) {
  for (var property in properties) {
    this[property] = properties[property];
  }
}

var strProperties = [
  'this',
  'typeName',
  'functionName',
  'methodName',
  'fileName',
  'lineNumber',
  'columnNumber',
  'function',
  'evalOrigin'
];
var boolProperties = [
  'topLevel',
  'eval',
  'native',
  'constructor'
];
strProperties.forEach(function (property) {
  CallSite.prototype[property] = null;
  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  }
});
boolProperties.forEach(function (property) {
  CallSite.prototype[property] = false;
  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {
    return this[property];
  }
});

exports._createParsedCallSite = function(properties) {
  return new CallSite(properties);
};


/***/ }),

/***/ "../../node_modules/string_decoder/lib/string_decoder.js":
/*!***************************************************************!*\
  !*** ../../node_modules/string_decoder/lib/string_decoder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "../../node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "../../node_modules/text-hex/index.js":
/*!********************************************!*\
  !*** ../../node_modules/text-hex/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


/***
 * Convert string to hex color.
 *
 * @param {String} str Text to hash and convert to hex.
 * @returns {String}
 * @api public
 */
module.exports = function hex(str) {
  for (
    var i = 0, hash = 0;
    i < str.length;
    hash = str.charCodeAt(i++) + ((hash << 5) - hash)
  );

  var color = Math.floor(
    Math.abs(
      (Math.sin(hash) * 10000) % 1 * 16777216
    )
  ).toString(16);

  return '#' + Array(6 - color.length + 1).join('0') + color;
};


/***/ }),

/***/ "../../node_modules/triple-beam/config/cli.js":
/*!****************************************************!*\
  !*** ../../node_modules/triple-beam/config/cli.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * cli.js: Config that conform to commonly used CLI logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the CLI configuration.
 * @type {Object}
 */
exports.levels = {
  error: 0,
  warn: 1,
  help: 2,
  data: 3,
  info: 4,
  debug: 5,
  prompt: 6,
  verbose: 7,
  input: 8,
  silly: 9
};

/**
 * Default colors for the CLI configuration.
 * @type {Object}
 */
exports.colors = {
  error: 'red',
  warn: 'yellow',
  help: 'cyan',
  data: 'grey',
  info: 'green',
  debug: 'blue',
  prompt: 'grey',
  verbose: 'cyan',
  input: 'grey',
  silly: 'magenta'
};


/***/ }),

/***/ "../../node_modules/triple-beam/config/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/triple-beam/config/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Export config set for the CLI.
 * @type {Object}
 */
Object.defineProperty(exports, "cli", ({
  value: __webpack_require__(/*! ./cli */ "../../node_modules/triple-beam/config/cli.js")
}));

/**
 * Export config set for npm.
 * @type {Object}
 */
Object.defineProperty(exports, "npm", ({
  value: __webpack_require__(/*! ./npm */ "../../node_modules/triple-beam/config/npm.js")
}));

/**
 * Export config set for the syslog.
 * @type {Object}
 */
Object.defineProperty(exports, "syslog", ({
  value: __webpack_require__(/*! ./syslog */ "../../node_modules/triple-beam/config/syslog.js")
}));


/***/ }),

/***/ "../../node_modules/triple-beam/config/npm.js":
/*!****************************************************!*\
  !*** ../../node_modules/triple-beam/config/npm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * npm.js: Config that conform to npm logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the npm configuration.
 * @type {Object}
 */
exports.levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  silly: 6
};

/**
 * Default levels for the npm configuration.
 * @type {Object}
 */
exports.colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'green',
  verbose: 'cyan',
  debug: 'blue',
  silly: 'magenta'
};


/***/ }),

/***/ "../../node_modules/triple-beam/config/syslog.js":
/*!*******************************************************!*\
  !*** ../../node_modules/triple-beam/config/syslog.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * syslog.js: Config that conform to syslog logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */
exports.levels = {
  emerg: 0,
  alert: 1,
  crit: 2,
  error: 3,
  warning: 4,
  notice: 5,
  info: 6,
  debug: 7
};

/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */
exports.colors = {
  emerg: 'red',
  alert: 'yellow',
  crit: 'red',
  error: 'red',
  warning: 'red',
  notice: 'yellow',
  info: 'green',
  debug: 'blue'
};


/***/ }),

/***/ "../../node_modules/triple-beam/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/triple-beam/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden level identifier
 * to allow the readable level property to be mutable for
 * operations like colorization
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "LEVEL", ({
  value: Symbol.for('level')
}));

/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the final message property to not have
 * side effects on another.
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "MESSAGE", ({
  value: Symbol.for('message')
}));

/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the extracted splat property be hidden
 *
 * @type {Symbol}
 */
Object.defineProperty(exports, "SPLAT", ({
  value: Symbol.for('splat')
}));

/**
 * A shareable object constant  that can be used
 * as a standard configuration for winston@3.
 *
 * @type {Object}
 */
Object.defineProperty(exports, "configs", ({
  value: __webpack_require__(/*! ./config */ "../../node_modules/triple-beam/config/index.js")
}));


/***/ }),

/***/ "../../node_modules/util-deprecate/node.js":
/*!*************************************************!*\
  !*** ../../node_modules/util-deprecate/node.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(/*! util */ "util").deprecate;


/***/ }),

/***/ "../../node_modules/uuid/index.js":
/*!****************************************!*\
  !*** ../../node_modules/uuid/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "../../node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "../../node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "../../node_modules/uuid/lib/bytesToUuid.js":
/*!**************************************************!*\
  !*** ../../node_modules/uuid/lib/bytesToUuid.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../node_modules/uuid/lib/rng.js":
/*!******************************************!*\
  !*** ../../node_modules/uuid/lib/rng.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "../../node_modules/uuid/v1.js":
/*!*************************************!*\
  !*** ../../node_modules/uuid/v1.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../../node_modules/uuid/v4.js":
/*!*************************************!*\
  !*** ../../node_modules/uuid/v4.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/browser.js":
/*!****************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/browser.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/browser/main */ "../../node_modules/vscode-jsonrpc/lib/browser/main.js");

/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/browser/main.js":
/*!*************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/browser/main.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
const ril_1 = __webpack_require__(/*! ./ril */ "../../node_modules/vscode-jsonrpc/lib/browser/ril.js");
// Install the browser runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js");
__exportStar(__webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class BrowserMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
            this._onData.fire(event.data);
        };
        port.addEventListener('error', (event) => this.fireError(event));
        port.onmessage = this._messageListener;
    }
    listen(callback) {
        return this._onData.event(callback);
    }
}
exports.BrowserMessageReader = BrowserMessageReader;
class BrowserMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.addEventListener('error', (event) => this.fireError(event));
    }
    write(msg) {
        try {
            this.port.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.BrowserMessageWriter = BrowserMessageWriter;
function createMessageConnection(reader, writer, logger, options) {
    if (logger === undefined) {
        logger = api_1.NullLogger;
    }
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/browser/ril.js":
/*!************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/browser/ril.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const api_1 = __webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js");
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
        this.asciiDecoder = new TextDecoder('ascii');
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, _encoding) {
        return (new TextEncoder()).encode(value);
    }
    toString(value, encoding) {
        if (encoding === 'ascii') {
            return this.asciiDecoder.decode(value);
        }
        else {
            return (new TextDecoder(encoding)).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer;
        }
        else {
            return buffer.slice(0, length);
        }
    }
    allocNative(length) {
        return new Uint8Array(length);
    }
}
MessageBuffer.emptyBuffer = new Uint8Array(0);
class ReadableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
                this._onData.fire(new Uint8Array(buffer));
            }, () => {
                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
        };
        this.socket.addEventListener('message', this._messageListener);
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    onData(listener) {
        return this._onData.event(listener);
    }
}
class WritableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    write(data, encoding) {
        if (typeof data === 'string') {
            if (encoding !== undefined && encoding !== 'utf-8') {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
        }
        else {
            this.socket.send(data);
        }
        return Promise.resolve();
    }
    end() {
        this.socket.close();
    }
}
const _textEncoder = new TextEncoder();
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                if (options.charset !== 'utf-8') {
                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                }
                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                if (!(buffer instanceof Uint8Array)) {
                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                }
                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        },
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/api.js":
/*!***********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../../node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "../../node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../../node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const sharedArrayCancellation_1 = __webpack_require__(/*! ./sharedArrayCancellation */ "../../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js");
Object.defineProperty(exports, "SharedArraySenderStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } }));
Object.defineProperty(exports, "SharedArrayReceiverStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../../node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../../node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const messageBuffer_1 = __webpack_require__(/*! ./messageBuffer */ "../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
Object.defineProperty(exports, "AbstractMessageBuffer", ({ enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "../../node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
Object.defineProperty(exports, "MessageStrategy", ({ enumerable: true, get: function () { return connection_1.MessageStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../../node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../../node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace || (exports.Trace = Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues || (exports.TraceValues = TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace || (exports.Trace = Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
var IdCancellationReceiverStrategy;
(function (IdCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    IdCancellationReceiverStrategy.is = is;
})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
var RequestCancellationReceiverStrategy;
(function (RequestCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    RequestCancellationReceiverStrategy.is = is;
})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
var MessageStrategy;
(function (MessageStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
    }
    MessageStrategy.is = is;
})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
        }
        else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
        }
        else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
        }
        else {
            handleInvalidMessage(message);
        }
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
                messageStrategy.handleMessage(message, handleMessage);
            }
            else {
                handleMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
                logger.error(`Sending notification failed.`);
                throw error;
            });
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            // This should not await but simple return to ensure that we don't have another
            // async scheduling. Otherwise one send could overtake another send.
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const requestMessage = {
                jsonrpc: version,
                id: id,
                method: method,
                params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                try {
                    await messageWriter.write(requestMessage);
                    responsePromises.set(id, responsePromise);
                }
                catch (error) {
                    logger.error(`Sending request failed.`);
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                    throw error;
                }
            });
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable || (exports.Disposable = Disposable = {}));


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event || (exports.Event = Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/is.js":
/*!**********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch || (exports.Touch = Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error(`Message header must separate key and value using ':'\n${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/common/events.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "../../node_modules/vscode-jsonrpc/lib/common/semaphore.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader || (exports.MessageReader = MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        try {
            this.buffer.append(data);
            while (true) {
                if (this.nextMessageLength === -1) {
                    const headers = this.buffer.tryReadHeaders(true);
                    if (!headers) {
                        return;
                    }
                    const contentLength = headers.get('content-length');
                    if (!contentLength) {
                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                        return;
                    }
                    const length = parseInt(contentLength);
                    if (isNaN(length)) {
                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                        return;
                    }
                    this.nextMessageLength = length;
                }
                const body = this.buffer.tryReadBody(this.nextMessageLength);
                if (body === undefined) {
                    /** We haven't received the full message yet. */
                    this.setPartialMessageTimer();
                    return;
                }
                this.clearPartialMessageTimer();
                this.nextMessageLength = -1;
                // Make sure that we convert one received message after the
                // other. Otherwise it could happen that a decoding of a second
                // smaller message finished before the decoding of a first larger
                // message and then we would deliver the second message first.
                this.readSemaphore.lock(async () => {
                    const bytes = this.options.contentDecoder !== undefined
                        ? await this.options.contentDecoder.decode(body)
                        : body;
                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                    this.callback(message);
                }).catch((error) => {
                    this.fireError(error);
                });
            }
        }
        catch (error) {
            this.fireError(error);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "../../node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message || (exports.Message = Message = {}));


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!***********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../../node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../../node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancellationState;
(function (CancellationState) {
    CancellationState.Continue = 0;
    CancellationState.Cancelled = 1;
})(CancellationState || (CancellationState = {}));
class SharedArraySenderStrategy {
    constructor() {
        this.buffers = new Map();
    }
    enableCancellation(request) {
        if (request.id === null) {
            return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === undefined) {
            return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
        this.buffers.delete(id);
    }
    dispose() {
        this.buffers.clear();
    }
}
exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
class SharedArrayBufferCancellationToken {
    constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
}
class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
}
class SharedArrayReceiverStrategy {
    constructor() {
        this.kind = 'request';
    }
    createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === undefined) {
            return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
    }
}
exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/node/main.js":
/*!**********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "../../node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
const api_1 = __webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js");
__exportStar(__webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
        super();
        this.onData = new api_1.Emitter;
        port.on('close', () => this.fireClose);
        port.on('error', (error) => this.fireError(error));
        port.on('message', (message) => {
            this.onData.fire(message);
        });
    }
    listen(callback) {
        return this.onData.event(callback);
    }
}
exports.PortMessageReader = PortMessageReader;
class PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on('close', () => this.fireClose());
        port.on('error', (error) => this.fireError(error));
    }
    write(msg) {
        try {
            this.port.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.PortMessageWriter = PortMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(/*! util */ "util");
const api_1 = __webpack_require__(/*! ../common/api */ "../../node_modules/vscode-jsonrpc/lib/common/api.js");
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return api_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/node.js":
/*!*************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/node.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "../../node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "../../node_modules/winston-transport/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/winston-transport/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Expose modern transport directly as the export
module.exports = __webpack_require__(/*! ./modern */ "../../node_modules/winston-transport/modern.js");

// Expose legacy stream
module.exports.LegacyTransportStream = __webpack_require__(/*! ./legacy */ "../../node_modules/winston-transport/legacy.js");


/***/ }),

/***/ "../../node_modules/winston-transport/legacy.js":
/*!******************************************************!*\
  !*** ../../node_modules/winston-transport/legacy.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const { LEVEL } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const TransportStream = __webpack_require__(/*! ./modern */ "../../node_modules/winston-transport/modern.js");

/**
 * Constructor function for the LegacyTransportStream. This is an internal
 * wrapper `winston >= 3` uses to wrap older transports implementing
 * log(level, message, meta).
 * @param {Object} options - Options for this TransportStream instance.
 * @param {Transpot} options.transport - winston@2 or older Transport to wrap.
 */

const LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
  TransportStream.call(this, options);
  if (!options.transport || typeof options.transport.log !== 'function') {
    throw new Error('Invalid transport, must be an object with a log method.');
  }

  this.transport = options.transport;
  this.level = this.level || options.transport.level;
  this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;

  // Display our deprecation notice.
  this._deprecated();

  // Properly bubble up errors from the transport to the
  // LegacyTransportStream instance, but only once no matter how many times
  // this transport is shared.
  function transportError(err) {
    this.emit('error', err, this.transport);
  }

  if (!this.transport.__winstonError) {
    this.transport.__winstonError = transportError.bind(this);
    this.transport.on('error', this.transport.__winstonError);
  }
};

/*
 * Inherit from TransportStream using Node.js built-ins
 */
util.inherits(LegacyTransportStream, TransportStream);

/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */
LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
  if (this.silent || (info.exception === true && !this.handleExceptions)) {
    return callback(null);
  }

  // Remark: This has to be handled in the base transport now because we
  // cannot conditionally write to our pipe targets as stream.
  if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
    this.transport.log(info[LEVEL], info.message, info, this._nop);
  }

  callback(null);
};

/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */
LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
  for (let i = 0; i < chunks.length; i++) {
    if (this._accept(chunks[i])) {
      this.transport.log(
        chunks[i].chunk[LEVEL],
        chunks[i].chunk.message,
        chunks[i].chunk,
        this._nop
      );
      chunks[i].callback();
    }
  }

  return callback(null);
};

/**
 * Displays a deprecation notice. Defined as a function so it can be
 * overriden in tests.
 * @returns {undefined}
 */
LegacyTransportStream.prototype._deprecated = function _deprecated() {
  // eslint-disable-next-line no-console
  console.error([
    `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
    '- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md'
  ].join('\n'));
};

/**
 * Clean up error handling state on the legacy transport associated
 * with this instance.
 * @returns {undefined}
 */
LegacyTransportStream.prototype.close = function close() {
  if (this.transport.close) {
    this.transport.close();
  }

  if (this.transport.__winstonError) {
    this.transport.removeListener('error', this.transport.__winstonError);
    this.transport.__winstonError = null;
  }
};


/***/ }),

/***/ "../../node_modules/winston-transport/modern.js":
/*!******************************************************!*\
  !*** ../../node_modules/winston-transport/modern.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js");
const { LEVEL } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/**
 * Constructor function for the TransportStream. This is the base prototype
 * that all `winston >= 3` transports should inherit from.
 * @param {Object} options - Options for this TransportStream instance
 * @param {String} options.level - Highest level according to RFC5424.
 * @param {Boolean} options.handleExceptions - If true, info with
 * { exception: true } will be written.
 * @param {Function} options.log - Custom log function for simple Transport
 * creation
 * @param {Function} options.close - Called on "unpipe" from parent.
 */
const TransportStream = module.exports = function TransportStream(options = {}) {
  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });

  this.format = options.format;
  this.level = options.level;
  this.handleExceptions = options.handleExceptions;
  this.handleRejections = options.handleRejections;
  this.silent = options.silent;

  if (options.log) this.log = options.log;
  if (options.logv) this.logv = options.logv;
  if (options.close) this.close = options.close;

  // Get the levels from the source we are piped from.
  this.once('pipe', logger => {
    // Remark (indexzero): this bookkeeping can only support multiple
    // Logger parents with the same `levels`. This comes into play in
    // the `winston.Container` code in which `container.add` takes
    // a fully realized set of options with pre-constructed TransportStreams.
    this.levels = logger.levels;
    this.parent = logger;
  });

  // If and/or when the transport is removed from this instance
  this.once('unpipe', src => {
    // Remark (indexzero): this bookkeeping can only support multiple
    // Logger parents with the same `levels`. This comes into play in
    // the `winston.Container` code in which `container.add` takes
    // a fully realized set of options with pre-constructed TransportStreams.
    if (src === this.parent) {
      this.parent = null;
      if (this.close) {
        this.close();
      }
    }
  });
};

/*
 * Inherit from Writeable using Node.js built-ins
 */
util.inherits(TransportStream, Writable);

/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */
TransportStream.prototype._write = function _write(info, enc, callback) {
  if (this.silent || (info.exception === true && !this.handleExceptions)) {
    return callback(null);
  }

  // Remark: This has to be handled in the base transport now because we
  // cannot conditionally write to our pipe targets as stream. We always
  // prefer any explicit level set on the Transport itself falling back to
  // any level set on the parent.
  const level = this.level || (this.parent && this.parent.level);

  if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
    if (info && !this.format) {
      return this.log(info, callback);
    }

    let errState;
    let transformed;

    // We trap(and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      transformed = this.format.transform(Object.assign({}, info), this.format.options);
    } catch (err) {
      errState = err;
    }

    if (errState || !transformed) {
      // eslint-disable-next-line callback-return
      callback();
      if (errState) throw errState;
      return;
    }

    return this.log(transformed, callback);
  }
  this._writableState.sync = false;
  return callback(null);
};

/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */
TransportStream.prototype._writev = function _writev(chunks, callback) {
  if (this.logv) {
    const infos = chunks.filter(this._accept, this);
    if (!infos.length) {
      return callback(null);
    }

    // Remark (indexzero): from a performance perspective if Transport
    // implementers do choose to implement logv should we make it their
    // responsibility to invoke their format?
    return this.logv(infos, callback);
  }

  for (let i = 0; i < chunks.length; i++) {
    if (!this._accept(chunks[i])) continue;

    if (chunks[i].chunk && !this.format) {
      this.log(chunks[i].chunk, chunks[i].callback);
      continue;
    }

    let errState;
    let transformed;

    // We trap(and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      transformed = this.format.transform(
        Object.assign({}, chunks[i].chunk),
        this.format.options
      );
    } catch (err) {
      errState = err;
    }

    if (errState || !transformed) {
      // eslint-disable-next-line callback-return
      chunks[i].callback();
      if (errState) {
        // eslint-disable-next-line callback-return
        callback(null);
        throw errState;
      }
    } else {
      this.log(transformed, chunks[i].callback);
    }
  }

  return callback(null);
};

/**
 * Predicate function that returns true if the specfied `info` on the
 * WriteReq, `write`, should be passed down into the derived
 * TransportStream's I/O via `.log(info, callback)`.
 * @param {WriteReq} write - winston@3 Node.js WriteReq for the `info` object
 * representing the log message.
 * @returns {Boolean} - Value indicating if the `write` should be accepted &
 * logged.
 */
TransportStream.prototype._accept = function _accept(write) {
  const info = write.chunk;
  if (this.silent) {
    return false;
  }

  // We always prefer any explicit level set on the Transport itself
  // falling back to any level set on the parent.
  const level = this.level || (this.parent && this.parent.level);

  // Immediately check the average case: log level filtering.
  if (
    info.exception === true ||
    !level ||
    this.levels[level] >= this.levels[info[LEVEL]]
  ) {
    // Ensure the info object is valid based on `{ exception }`:
    // 1. { handleExceptions: true }: all `info` objects are valid
    // 2. { exception: false }: accepted by all transports.
    if (this.handleExceptions || info.exception !== true) {
      return true;
    }
  }

  return false;
};

/**
 * _nop is short for "No operation"
 * @returns {Boolean} Intentionally false.
 */
TransportStream.prototype._nop = function _nop() {
  // eslint-disable-next-line no-undefined
  return void undefined;
};


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Keep this file as an alias for the full stream module.
module.exports = __webpack_require__(/*! ./stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/stream.js").Writable


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { isNodeStream, isWebStream, kControllerErrorFunction } = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
const { ERR_INVALID_ARG_TYPE } = codes
let addAbortListener

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
}
module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
  validateAbortSignal(signal, 'signal')
  if (!isNodeStream(stream) && !isWebStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  return module.exports.addAbortSignalNoValidate(signal, stream)
}
module.exports.addAbortSignalNoValidate = function (signal, stream) {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    return stream
  }
  const onAbort = isNodeStream(stream)
    ? () => {
        stream.destroy(
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
    : () => {
        stream[kControllerErrorFunction](
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
  if (signal.aborted) {
    onAbort()
  } else {
    addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").addAbortListener)
    const disposable = addAbortListener(signal, onAbort)
    eos(stream, disposable[SymbolDispose])
  }
  return stream
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { Buffer } = __webpack_require__(/*! buffer */ "buffer")
const { inspect } = __webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
module.exports = class BufferList {
  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }
  push(v) {
    const entry = {
      data: v,
      next: null
    }
    if (this.length > 0) this.tail.next = entry
    else this.head = entry
    this.tail = entry
    ++this.length
  }
  unshift(v) {
    const entry = {
      data: v,
      next: this.head
    }
    if (this.length === 0) this.tail = entry
    this.head = entry
    ++this.length
  }
  shift() {
    if (this.length === 0) return
    const ret = this.head.data
    if (this.length === 1) this.head = this.tail = null
    else this.head = this.head.next
    --this.length
    return ret
  }
  clear() {
    this.head = this.tail = null
    this.length = 0
  }
  join(s) {
    if (this.length === 0) return ''
    let p = this.head
    let ret = '' + p.data
    while ((p = p.next) !== null) ret += s + p.data
    return ret
  }
  concat(n) {
    if (this.length === 0) return Buffer.alloc(0)
    const ret = Buffer.allocUnsafe(n >>> 0)
    let p = this.head
    let i = 0
    while (p) {
      TypedArrayPrototypeSet(ret, p.data, i)
      i += p.data.length
      p = p.next
    }
    return ret
  }

  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n, hasStrings) {
    const data = this.head.data
    if (n < data.length) {
      // `slice` is the same for buffers and strings.
      const slice = data.slice(0, n)
      this.head.data = data.slice(n)
      return slice
    }
    if (n === data.length) {
      // First chunk is a perfect match.
      return this.shift()
    }
    // Result spans more than one buffer.
    return hasStrings ? this._getString(n) : this._getBuffer(n)
  }
  first() {
    return this.head.data
  }
  *[SymbolIterator]() {
    for (let p = this.head; p; p = p.next) {
      yield p.data
    }
  }

  // Consumes a specified amount of characters from the buffered data.
  _getString(n) {
    let ret = ''
    let p = this.head
    let c = 0
    do {
      const str = p.data
      if (n > str.length) {
        ret += str
        n -= str.length
      } else {
        if (n === str.length) {
          ret += str
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          ret += StringPrototypeSlice(str, 0, n)
          this.head = p
          p.data = StringPrototypeSlice(str, n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n) {
    const ret = Buffer.allocUnsafe(n)
    const retLen = n
    let p = this.head
    let c = 0
    do {
      const buf = p.data
      if (n > buf.length) {
        TypedArrayPrototypeSet(ret, buf, retLen - n)
        n -= buf.length
      } else {
        if (n === buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n)
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)
          this.head = p
          p.data = buf.slice(n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for('nodejs.util.inspect.custom')](_, options) {
    return inspect(this, {
      ...options,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    })
  }
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/compose.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/compose.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { pipeline } = __webpack_require__(/*! ./pipeline */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js")
const Duplex = __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
const { destroyer } = __webpack_require__(/*! ./destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const {
  isNodeStream,
  isReadable,
  isWritable,
  isWebStream,
  isTransformStream,
  isWritableStream,
  isReadableStream
} = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const {
  AbortError,
  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
module.exports = function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS('streams')
  }
  if (streams.length === 1) {
    return Duplex.from(streams[0])
  }
  const orgStreams = [...streams]
  if (typeof streams[0] === 'function') {
    streams[0] = Duplex.from(streams[0])
  }
  if (typeof streams[streams.length - 1] === 'function') {
    const idx = streams.length - 1
    streams[idx] = Duplex.from(streams[idx])
  }
  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
      // TODO(ronag): Add checks for non streams.
      continue
    }
    if (
      n < streams.length - 1 &&
      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))
    ) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')
    }
    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')
    }
  }
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    } else if (!readable && !writable) {
      d.destroy()
    }
  }
  const head = streams[0]
  const tail = pipeline(streams, onfinished)
  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))
  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
    writable,
    readable
  })
  if (writable) {
    if (isNodeStream(head)) {
      d._write = function (chunk, encoding, callback) {
        if (head.write(chunk, encoding)) {
          callback()
        } else {
          ondrain = callback
        }
      }
      d._final = function (callback) {
        head.end()
        onfinish = callback
      }
      head.on('drain', function () {
        if (ondrain) {
          const cb = ondrain
          ondrain = null
          cb()
        }
      })
    } else if (isWebStream(head)) {
      const writable = isTransformStream(head) ? head.writable : head
      const writer = writable.getWriter()
      d._write = async function (chunk, encoding, callback) {
        try {
          await writer.ready
          writer.write(chunk).catch(() => {})
          callback()
        } catch (err) {
          callback(err)
        }
      }
      d._final = async function (callback) {
        try {
          await writer.ready
          writer.close().catch(() => {})
          onfinish = callback
        } catch (err) {
          callback(err)
        }
      }
    }
    const toRead = isTransformStream(tail) ? tail.readable : tail
    eos(toRead, () => {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    if (isNodeStream(tail)) {
      tail.on('readable', function () {
        if (onreadable) {
          const cb = onreadable
          onreadable = null
          cb()
        }
      })
      tail.on('end', function () {
        d.push(null)
      })
      d._read = function () {
        while (true) {
          const buf = tail.read()
          if (buf === null) {
            onreadable = d._read
            return
          }
          if (!d.push(buf)) {
            return
          }
        }
      }
    } else if (isWebStream(tail)) {
      const readable = isTransformStream(tail) ? tail.readable : tail
      const reader = readable.getReader()
      d._read = async function () {
        while (true) {
          try {
            const { value, done } = await reader.read()
            if (!d.push(value)) {
              return
            }
            if (done) {
              d.push(null)
              return
            }
          } catch {
            return
          }
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      if (isNodeStream(tail)) {
        destroyer(tail, err)
      }
    }
  }
  return d
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */

const {
  aggregateTwoErrors,
  codes: { ERR_MULTIPLE_CALLBACK },
  AbortError
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { Symbol } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const kDestroy = Symbol('kDestroy')
const kConstruct = Symbol('kConstruct')
function checkError(err, w, r) {
  if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
  }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
function destroy(err, cb) {
  const r = this._readableState
  const w = this._writableState
  // With duplex streams we use the writable side for state.
  const s = w || r
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    if (typeof cb === 'function') {
      cb()
    }
    return this
  }

  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks
  checkError(err, w, r)
  if (w) {
    w.destroyed = true
  }
  if (r) {
    r.destroyed = true
  }

  // If still constructing then defer calling _destroy.
  if (!s.constructed) {
    this.once(kDestroy, function (er) {
      _destroy(this, aggregateTwoErrors(er, err), cb)
    })
  } else {
    _destroy(this, err, cb)
  }
  return this
}
function _destroy(self, err, cb) {
  let called = false
  function onDestroy(err) {
    if (called) {
      return
    }
    called = true
    const r = self._readableState
    const w = self._writableState
    checkError(err, w, r)
    if (w) {
      w.closed = true
    }
    if (r) {
      r.closed = true
    }
    if (typeof cb === 'function') {
      cb(err)
    }
    if (err) {
      process.nextTick(emitErrorCloseNT, self, err)
    } else {
      process.nextTick(emitCloseNT, self)
    }
  }
  try {
    self._destroy(err || null, onDestroy)
  } catch (err) {
    onDestroy(err)
  }
}
function emitErrorCloseNT(self, err) {
  emitErrorNT(self, err)
  emitCloseNT(self)
}
function emitCloseNT(self) {
  const r = self._readableState
  const w = self._writableState
  if (w) {
    w.closeEmitted = true
  }
  if (r) {
    r.closeEmitted = true
  }
  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {
    self.emit('close')
  }
}
function emitErrorNT(self, err) {
  const r = self._readableState
  const w = self._writableState
  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {
    return
  }
  if (w) {
    w.errorEmitted = true
  }
  if (r) {
    r.errorEmitted = true
  }
  self.emit('error', err)
}
function undestroy() {
  const r = this._readableState
  const w = this._writableState
  if (r) {
    r.constructed = true
    r.closed = false
    r.closeEmitted = false
    r.destroyed = false
    r.errored = null
    r.errorEmitted = false
    r.reading = false
    r.ended = r.readable === false
    r.endEmitted = r.readable === false
  }
  if (w) {
    w.constructed = true
    w.destroyed = false
    w.closed = false
    w.closeEmitted = false
    w.errored = null
    w.errorEmitted = false
    w.finalCalled = false
    w.prefinished = false
    w.ended = w.writable === false
    w.ending = w.writable === false
    w.finished = w.writable === false
  }
}
function errorOrDestroy(stream, err, sync) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  const r = stream._readableState
  const w = stream._writableState
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    return this
  }
  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))
    stream.destroy(err)
  else if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
    if (sync) {
      process.nextTick(emitErrorNT, stream, err)
    } else {
      emitErrorNT(stream, err)
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== 'function') {
    return
  }
  const r = stream._readableState
  const w = stream._writableState
  if (r) {
    r.constructed = false
  }
  if (w) {
    w.constructed = false
  }
  stream.once(kConstruct, cb)
  if (stream.listenerCount(kConstruct) > 1) {
    // Duplex
    return
  }
  process.nextTick(constructNT, stream)
}
function constructNT(stream) {
  let called = false
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    const r = stream._readableState
    const w = stream._writableState
    const s = w || r
    if (r) {
      r.constructed = true
    }
    if (w) {
      w.constructed = true
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err)
    } else if (err) {
      errorOrDestroy(stream, err, true)
    } else {
      process.nextTick(emitConstructNT, stream)
    }
  }
  try {
    stream._construct((err) => {
      process.nextTick(onConstruct, err)
    })
  } catch (err) {
    process.nextTick(onConstruct, err)
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct)
}
function isRequest(stream) {
  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'
}
function emitCloseLegacy(stream) {
  stream.emit('close')
}
function emitErrorCloseLegacy(stream, err) {
  stream.emit('error', err)
  process.nextTick(emitCloseLegacy, stream)
}

// Normalize destroy for legacy.
function destroyer(stream, err) {
  if (!stream || isDestroyed(stream)) {
    return
  }
  if (!err && !isFinished(stream)) {
    err = new AbortError()
  }

  // TODO: Remove isRequest branches.
  if (isServerRequest(stream)) {
    stream.socket = null
    stream.destroy(err)
  } else if (isRequest(stream)) {
    stream.abort()
  } else if (isRequest(stream.req)) {
    stream.req.abort()
  } else if (typeof stream.destroy === 'function') {
    stream.destroy(err)
  } else if (typeof stream.close === 'function') {
    // TODO: Don't lose err?
    stream.close()
  } else if (err) {
    process.nextTick(emitErrorCloseLegacy, stream, err)
  } else {
    process.nextTick(emitCloseLegacy, stream)
  }
  if (!stream.destroyed) {
    stream[kIsDestroyed] = true
  }
}
module.exports = {
  construct,
  destroyer,
  destroy,
  undestroy,
  errorOrDestroy
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototype inheritance, this class
// prototypically inherits from Readable, and then parasitically from
// Writable.



const {
  ObjectDefineProperties,
  ObjectGetOwnPropertyDescriptor,
  ObjectKeys,
  ObjectSetPrototypeOf
} = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
module.exports = Duplex
const Readable = __webpack_require__(/*! ./readable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js")
const Writable = __webpack_require__(/*! ./writable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js")
ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)
ObjectSetPrototypeOf(Duplex, Readable)
{
  const keys = ObjectKeys(Writable.prototype)
  // Allow the keys array to be GC'ed.
  for (let i = 0; i < keys.length; i++) {
    const method = keys[i]
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options)
  Readable.call(this, options)
  Writable.call(this, options)
  if (options) {
    this.allowHalfOpen = options.allowHalfOpen !== false
    if (options.readable === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if (options.writable === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  } else {
    this.allowHalfOpen = true
  }
}
ObjectDefineProperties(Duplex.prototype, {
  writable: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')
  },
  writableHighWaterMark: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')
  },
  writableObjectMode: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')
  },
  writableBuffer: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')
  },
  writableLength: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')
  },
  writableFinished: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')
  },
  writableCorked: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')
  },
  writableEnded: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')
  },
  writableNeedDrain: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')
  },
  destroyed: {
    __proto__: null,
    get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false
      }
      return this._readableState.destroyed && this._writableState.destroyed
    },
    set(value) {
      // Backward compatibility, the user is explicitly
      // managing destroyed.
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value
        this._writableState.destroyed = value
      }
    }
  }
})
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Duplex.fromWeb = function (pair, options) {
  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)
}
Duplex.toWeb = function (duplex) {
  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)
}
let duplexify
Duplex.from = function (body) {
  if (!duplexify) {
    duplexify = __webpack_require__(/*! ./duplexify */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplexify.js")
  }
  return duplexify(body, 'body')
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplexify.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplexify.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */

;('use strict')
const bufferModule = __webpack_require__(/*! buffer */ "buffer")
const {
  isReadable,
  isWritable,
  isIterable,
  isNodeStream,
  isReadableNodeStream,
  isWritableNodeStream,
  isDuplexNodeStream,
  isReadableStream,
  isWritableStream
} = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
const {
  AbortError,
  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { destroyer } = __webpack_require__(/*! ./destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const Duplex = __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
const Readable = __webpack_require__(/*! ./readable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js")
const Writable = __webpack_require__(/*! ./writable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js")
const { createDeferredPromise } = __webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const from = __webpack_require__(/*! ./from */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js")
const Blob = globalThis.Blob || bufferModule.Blob
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
const AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js").AbortController)
const { FunctionPrototypeCall } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")

// This is needed for pre node 17.
class Duplexify extends Duplex {
  constructor(options) {
    super(options)

    // https://github.com/nodejs/node/pull/34385

    if ((options === null || options === undefined ? undefined : options.readable) === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if ((options === null || options === undefined ? undefined : options.writable) === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  }
}
module.exports = function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({
      readable: body
    })
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({
      writable: body
    })
  }
  if (isNodeStream(body)) {
    return _duplexify({
      writable: false,
      readable: false
    })
  }
  if (isReadableStream(body)) {
    return _duplexify({
      readable: Readable.fromWeb(body)
    })
  }
  if (isWritableStream(body)) {
    return _duplexify({
      writable: Writable.fromWeb(body)
    })
  }
  if (typeof body === 'function') {
    const { value, write, final, destroy } = fromAsyncGen(body)
    if (isIterable(value)) {
      return from(Duplexify, value, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        write,
        final,
        destroy
      })
    }
    const then = value === null || value === undefined ? undefined : value.then
    if (typeof then === 'function') {
      let d
      const promise = FunctionPrototypeCall(
        then,
        value,
        (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)
          }
        },
        (err) => {
          destroyer(d, err)
        }
      )
      return (d = new Duplexify({
        // TODO (ronag): highWaterMark?
        objectMode: true,
        readable: false,
        write,
        final(cb) {
          final(async () => {
            try {
              await promise
              process.nextTick(cb, null)
            } catch (err) {
              process.nextTick(cb, err)
            }
          })
        },
        destroy
      }))
    }
    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer())
  }
  if (isIterable(body)) {
    return from(Duplexify, body, {
      // TODO (ronag): highWaterMark?
      objectMode: true,
      writable: false
    })
  }
  if (
    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&
    isWritableStream(body === null || body === undefined ? undefined : body.writable)
  ) {
    return Duplexify.fromWeb(body)
  }
  if (
    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||
    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'
  ) {
    const readable =
      body !== null && body !== undefined && body.readable
        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)
          ? body === null || body === undefined
            ? undefined
            : body.readable
          : duplexify(body.readable)
        : undefined
    const writable =
      body !== null && body !== undefined && body.writable
        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)
          ? body === null || body === undefined
            ? undefined
            : body.writable
          : duplexify(body.writable)
        : undefined
    return _duplexify({
      readable,
      writable
    })
  }
  const then = body === null || body === undefined ? undefined : body.then
  if (typeof then === 'function') {
    let d
    FunctionPrototypeCall(
      then,
      body,
      (val) => {
        if (val != null) {
          d.push(val)
        }
        d.push(null)
      },
      (err) => {
        destroyer(d, err)
      }
    )
    return (d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {}
    }))
  }
  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      'Blob',
      'ReadableStream',
      'WritableStream',
      'Stream',
      'Iterable',
      'AsyncIterable',
      'Function',
      '{ readable, writable } pair',
      'Promise'
    ],
    body
  )
}
function fromAsyncGen(fn) {
  let { promise, resolve } = createDeferredPromise()
  const ac = new AbortController()
  const signal = ac.signal
  const value = fn(
    (async function* () {
      while (true) {
        const _promise = promise
        promise = null
        const { chunk, done, cb } = await _promise
        process.nextTick(cb)
        if (done) return
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          })
        ;({ promise, resolve } = createDeferredPromise())
        yield chunk
      }
    })(),
    {
      signal
    }
  )
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        chunk,
        done: false,
        cb
      })
    },
    final(cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        done: true,
        cb
      })
    },
    destroy(err, cb) {
      ac.abort()
      cb(err)
    }
  }
}
function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable
  const w = pair.writable
  let readable = !!isReadable(r)
  let writable = !!isWritable(w)
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    }
  }

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplexify({
    // TODO (ronag): highWaterMark?
    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
    readable,
    writable
  })
  if (writable) {
    eos(w, (err) => {
      writable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    d._write = function (chunk, encoding, callback) {
      if (w.write(chunk, encoding)) {
        callback()
      } else {
        ondrain = callback
      }
    }
    d._final = function (callback) {
      w.end()
      onfinish = callback
    }
    w.on('drain', function () {
      if (ondrain) {
        const cb = ondrain
        ondrain = null
        cb()
      }
    })
    w.on('finish', function () {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    eos(r, (err) => {
      readable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    r.on('readable', function () {
      if (onreadable) {
        const cb = onreadable
        onreadable = null
        cb()
      }
    })
    r.on('end', function () {
      d.push(null)
    })
    d._read = function () {
      while (true) {
        const buf = r.read()
        if (buf === null) {
          onreadable = d._read
          return
        }
        if (!d.push(buf)) {
          return
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      destroyer(w, err)
      destroyer(r, err)
    }
  }
  return d
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { AbortError, codes } = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes
const { kEmptyObject, once } = __webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = __webpack_require__(/*! ../validators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js")
const { Promise, PromisePrototypeThen, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const {
  isClosed,
  isReadable,
  isReadableNodeStream,
  isReadableStream,
  isReadableFinished,
  isReadableErrored,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableFinished,
  isWritableErrored,
  isNodeStream,
  willEmitClose: _willEmitClose,
  kIsClosedPromise
} = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
let addAbortListener
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function'
}
const nop = () => {}
function eos(stream, options, callback) {
  var _options$readable, _options$writable
  if (arguments.length === 2) {
    callback = options
    options = kEmptyObject
  } else if (options == null) {
    options = kEmptyObject
  } else {
    validateObject(options, 'options')
  }
  validateFunction(callback, 'callback')
  validateAbortSignal(options.signal, 'options.signal')
  callback = once(callback)
  if (isReadableStream(stream) || isWritableStream(stream)) {
    return eosWeb(stream, options, callback)
  }
  if (!isNodeStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  const readable =
    (_options$readable = options.readable) !== null && _options$readable !== undefined
      ? _options$readable
      : isReadableNodeStream(stream)
  const writable =
    (_options$writable = options.writable) !== null && _options$writable !== undefined
      ? _options$writable
      : isWritableNodeStream(stream)
  const wState = stream._writableState
  const rState = stream._readableState
  const onlegacyfinish = () => {
    if (!stream.writable) {
      onfinish()
    }
  }

  // TODO (ronag): Improve soft detection to include core modules and
  // common ecosystem modules that do properly emit 'close' but fail
  // this generic check.
  let willEmitClose =
    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable
  let writableFinished = isWritableFinished(stream, false)
  const onfinish = () => {
    writableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.readable || readable)) {
      return
    }
    if (!readable || readableFinished) {
      callback.call(stream)
    }
  }
  let readableFinished = isReadableFinished(stream, false)
  const onend = () => {
    readableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.writable || writable)) {
      return
    }
    if (!writable || writableFinished) {
      callback.call(stream)
    }
  }
  const onerror = (err) => {
    callback.call(stream, err)
  }
  let closed = isClosed(stream)
  const onclose = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    callback.call(stream)
  }
  const onclosed = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    callback.call(stream)
  }
  const onrequest = () => {
    stream.req.on('finish', onfinish)
  }
  if (isRequest(stream)) {
    stream.on('complete', onfinish)
    if (!willEmitClose) {
      stream.on('abort', onclose)
    }
    if (stream.req) {
      onrequest()
    } else {
      stream.on('request', onrequest)
    }
  } else if (writable && !wState) {
    // legacy streams
    stream.on('end', onlegacyfinish)
    stream.on('close', onlegacyfinish)
  }

  // Not all streams will emit 'close' after 'aborted'.
  if (!willEmitClose && typeof stream.aborted === 'boolean') {
    stream.on('aborted', onclose)
  }
  stream.on('end', onend)
  stream.on('finish', onfinish)
  if (options.error !== false) {
    stream.on('error', onerror)
  }
  stream.on('close', onclose)
  if (closed) {
    process.nextTick(onclose)
  } else if (
    (wState !== null && wState !== undefined && wState.errorEmitted) ||
    (rState !== null && rState !== undefined && rState.errorEmitted)
  ) {
    if (!willEmitClose) {
      process.nextTick(onclosed)
    }
  } else if (
    !readable &&
    (!willEmitClose || isReadable(stream)) &&
    (writableFinished || isWritable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (
    !writable &&
    (!willEmitClose || isWritable(stream)) &&
    (readableFinished || isReadable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (rState && stream.req && stream.aborted) {
    process.nextTick(onclosed)
  }
  const cleanup = () => {
    callback = nop
    stream.removeListener('aborted', onclose)
    stream.removeListener('complete', onfinish)
    stream.removeListener('abort', onclose)
    stream.removeListener('request', onrequest)
    if (stream.req) stream.req.removeListener('finish', onfinish)
    stream.removeListener('end', onlegacyfinish)
    stream.removeListener('close', onlegacyfinish)
    stream.removeListener('finish', onfinish)
    stream.removeListener('end', onend)
    stream.removeListener('error', onerror)
    stream.removeListener('close', onclose)
  }
  if (options.signal && !closed) {
    const abort = () => {
      // Keep it because cleanup removes it.
      const endCallback = callback
      cleanup()
      endCallback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").addAbortListener)
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) => {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  return cleanup
}
function eosWeb(stream, options, callback) {
  let isAborted = false
  let abort = nop
  if (options.signal) {
    abort = () => {
      isAborted = true
      callback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").addAbortListener)
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) => {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  const resolverFn = (...args) => {
    if (!isAborted) {
      process.nextTick(() => callback.apply(stream, args))
    }
  }
  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)
  return nop
}
function finished(stream, opts) {
  var _opts
  let autoCleanup = false
  if (opts === null) {
    opts = kEmptyObject
  }
  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
    validateBoolean(opts.cleanup, 'cleanup')
    autoCleanup = opts.cleanup
  }
  return new Promise((resolve, reject) => {
    const cleanup = eos(stream, opts, (err) => {
      if (autoCleanup) {
        cleanup()
      }
      if (err) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}
module.exports = eos
module.exports.finished = finished


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */

const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { Buffer } = __webpack_require__(/*! buffer */ "buffer")
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = (__webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js").codes)
function from(Readable, iterable, opts) {
  let iterator
  if (typeof iterable === 'string' || iterable instanceof Buffer) {
    return new Readable({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable)
        this.push(null)
      }
    })
  }
  let isAsync
  if (iterable && iterable[SymbolAsyncIterator]) {
    isAsync = true
    iterator = iterable[SymbolAsyncIterator]()
  } else if (iterable && iterable[SymbolIterator]) {
    isAsync = false
    iterator = iterable[SymbolIterator]()
  } else {
    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)
  }
  const readable = new Readable({
    objectMode: true,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...opts
  })

  // Flag to protect against _read
  // being called before last iteration completion.
  let reading = false
  readable._read = function () {
    if (!reading) {
      reading = true
      next()
    }
  }
  readable._destroy = function (error, cb) {
    PromisePrototypeThen(
      close(error),
      () => process.nextTick(cb, error),
      // nextTick is here in case cb throws
      (e) => process.nextTick(cb, e || error)
    )
  }
  async function close(error) {
    const hadError = error !== undefined && error !== null
    const hasThrow = typeof iterator.throw === 'function'
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error)
      await value
      if (done) {
        return
      }
    }
    if (typeof iterator.return === 'function') {
      const { value } = await iterator.return()
      await value
    }
  }
  async function next() {
    for (;;) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next()
        if (done) {
          readable.push(null)
        } else {
          const res = value && typeof value.then === 'function' ? await value : value
          if (res === null) {
            reading = false
            throw new ERR_STREAM_NULL_VALUES()
          } else if (readable.push(res)) {
            continue
          } else {
            reading = false
          }
        }
      } catch (err) {
        readable.destroy(err)
      }
      break
    }
  }
  return readable
}
module.exports = from


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ArrayIsArray, ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { EventEmitter: EE } = __webpack_require__(/*! events */ "events")
function Stream(opts) {
  EE.call(this, opts)
}
ObjectSetPrototypeOf(Stream.prototype, EE.prototype)
ObjectSetPrototypeOf(Stream, EE)
Stream.prototype.pipe = function (dest, options) {
  const source = this
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause()
    }
  }
  source.on('data', ondata)
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume()
    }
  }
  dest.on('drain', ondrain)

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend)
    source.on('close', onclose)
  }
  let didOnEnd = false
  function onend() {
    if (didOnEnd) return
    didOnEnd = true
    dest.end()
  }
  function onclose() {
    if (didOnEnd) return
    didOnEnd = true
    if (typeof dest.destroy === 'function') dest.destroy()
  }

  // Don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup()
    if (EE.listenerCount(this, 'error') === 0) {
      this.emit('error', er)
    }
  }
  prependListener(source, 'error', onerror)
  prependListener(dest, 'error', onerror)

  // Remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata)
    dest.removeListener('drain', ondrain)
    source.removeListener('end', onend)
    source.removeListener('close', onclose)
    source.removeListener('error', onerror)
    dest.removeListener('error', onerror)
    source.removeListener('end', cleanup)
    source.removeListener('close', cleanup)
    dest.removeListener('close', cleanup)
  }
  source.on('end', cleanup)
  source.on('close', cleanup)
  dest.on('close', cleanup)
  dest.emit('pipe', source)

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest
}
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)
  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)
  else emitter._events[event] = [fn, emitter._events[event]]
}
module.exports = {
  Stream,
  prependListener
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/operators.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/operators.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js").AbortController)
const {
  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
  AbortError
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { validateAbortSignal, validateInteger, validateObject } = __webpack_require__(/*! ../validators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js")
const kWeakHandler = (__webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js").Symbol)('kWeak')
const kResistStopPropagation = (__webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js").Symbol)('kResistStopPropagation')
const { finished } = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
const staticCompose = __webpack_require__(/*! ./compose */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/compose.js")
const { addAbortSignalNoValidate } = __webpack_require__(/*! ./add-abort-signal */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js")
const { isWritable, isNodeStream } = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const { deprecate } = __webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const {
  ArrayPrototypePush,
  Boolean,
  MathFloor,
  Number,
  NumberIsNaN,
  Promise,
  PromiseReject,
  PromiseResolve,
  PromisePrototypeThen,
  Symbol
} = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const kEmpty = Symbol('kEmpty')
const kEof = Symbol('kEof')
function compose(stream, options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  if (isNodeStream(stream) && !isWritable(stream)) {
    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')
  }
  const composedStream = staticCompose(this, stream)
  if (options !== null && options !== undefined && options.signal) {
    // Not validating as we already validated before
    addAbortSignalNoValidate(options.signal, composedStream)
  }
  return composedStream
}
function map(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let concurrency = 1
  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
    concurrency = MathFloor(options.concurrency)
  }
  let highWaterMark = concurrency - 1
  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
    highWaterMark = MathFloor(options.highWaterMark)
  }
  validateInteger(concurrency, 'options.concurrency', 1)
  validateInteger(highWaterMark, 'options.highWaterMark', 0)
  highWaterMark += concurrency
  return async function* map() {
    const signal = (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").AbortSignalAny)(
      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)
    )
    const stream = this
    const queue = []
    const signalOpt = {
      signal
    }
    let next
    let resume
    let done = false
    let cnt = 0
    function onCatch() {
      done = true
      afterItemProcessed()
    }
    function afterItemProcessed() {
      cnt -= 1
      maybeResume()
    }
    function maybeResume() {
      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
        resume()
        resume = null
      }
    }
    async function pump() {
      try {
        for await (let val of stream) {
          if (done) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          try {
            val = fn(val, signalOpt)
            if (val === kEmpty) {
              continue
            }
            val = PromiseResolve(val)
          } catch (err) {
            val = PromiseReject(err)
          }
          cnt += 1
          PromisePrototypeThen(val, afterItemProcessed, onCatch)
          queue.push(val)
          if (next) {
            next()
            next = null
          }
          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
            await new Promise((resolve) => {
              resume = resolve
            })
          }
        }
        queue.push(kEof)
      } catch (err) {
        const val = PromiseReject(err)
        PromisePrototypeThen(val, afterItemProcessed, onCatch)
        queue.push(val)
      } finally {
        done = true
        if (next) {
          next()
          next = null
        }
      }
    }
    pump()
    try {
      while (true) {
        while (queue.length > 0) {
          const val = await queue[0]
          if (val === kEof) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          if (val !== kEmpty) {
            yield val
          }
          queue.shift()
          maybeResume()
        }
        await new Promise((resolve) => {
          next = resolve
        })
      }
    } finally {
      done = true
      if (resume) {
        resume()
        resume = null
      }
    }
  }.call(this)
}
function asIndexedPairs(options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  return async function* asIndexedPairs() {
    let index = 0
    for await (const val of this) {
      var _options$signal
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal = options.signal) !== null &&
        _options$signal !== undefined &&
        _options$signal.aborted
      ) {
        throw new AbortError({
          cause: options.signal.reason
        })
      }
      yield [index++, val]
    }
  }.call(this)
}
async function some(fn, options = undefined) {
  for await (const unused of filter.call(this, fn, options)) {
    return true
  }
  return false
}
async function every(fn, options = undefined) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws
  return !(await some.call(
    this,
    async (...args) => {
      return !(await fn(...args))
    },
    options
  ))
}
async function find(fn, options) {
  for await (const result of filter.call(this, fn, options)) {
    return result
  }
  return undefined
}
async function forEach(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function forEachFn(value, options) {
    await fn(value, options)
    return kEmpty
  }
  // eslint-disable-next-line no-unused-vars
  for await (const unused of map.call(this, forEachFn, options));
}
function filter(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function filterFn(value, options) {
    if (await fn(value, options)) {
      return value
    }
    return kEmpty
  }
  return map.call(this, filterFn, options)
}

// Specific to provide better error to reduce since the argument is only
// missing if the stream has no items in it - but the code is still appropriate
class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
  constructor() {
    super('reduce')
    this.message = 'Reduce of an empty stream requires an initial value'
  }
}
async function reduce(reducer, initialValue, options) {
  var _options$signal2
  if (typeof reducer !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let hasInitialValue = arguments.length > 1
  if (
    options !== null &&
    options !== undefined &&
    (_options$signal2 = options.signal) !== null &&
    _options$signal2 !== undefined &&
    _options$signal2.aborted
  ) {
    const err = new AbortError(undefined, {
      cause: options.signal.reason
    })
    this.once('error', () => {}) // The error is already propagated
    await finished(this.destroy(err))
    throw err
  }
  const ac = new AbortController()
  const signal = ac.signal
  if (options !== null && options !== undefined && options.signal) {
    const opts = {
      once: true,
      [kWeakHandler]: this,
      [kResistStopPropagation]: true
    }
    options.signal.addEventListener('abort', () => ac.abort(), opts)
  }
  let gotAnyItemFromStream = false
  try {
    for await (const value of this) {
      var _options$signal3
      gotAnyItemFromStream = true
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal3 = options.signal) !== null &&
        _options$signal3 !== undefined &&
        _options$signal3.aborted
      ) {
        throw new AbortError()
      }
      if (!hasInitialValue) {
        initialValue = value
        hasInitialValue = true
      } else {
        initialValue = await reducer(initialValue, value, {
          signal
        })
      }
    }
    if (!gotAnyItemFromStream && !hasInitialValue) {
      throw new ReduceAwareErrMissingArgs()
    }
  } finally {
    ac.abort()
  }
  return initialValue
}
async function toArray(options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  const result = []
  for await (const val of this) {
    var _options$signal4
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal4 = options.signal) !== null &&
      _options$signal4 !== undefined &&
      _options$signal4.aborted
    ) {
      throw new AbortError(undefined, {
        cause: options.signal.reason
      })
    }
    ArrayPrototypePush(result, val)
  }
  return result
}
function flatMap(fn, options) {
  const values = map.call(this, fn, options)
  return async function* flatMap() {
    for await (const val of values) {
      yield* val
    }
  }.call(this)
}
function toIntegerOrInfinity(number) {
  // We coerce here to align with the spec
  // https://github.com/tc39/proposal-iterator-helpers/issues/169
  number = Number(number)
  if (NumberIsNaN(number)) {
    return 0
  }
  if (number < 0) {
    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)
  }
  return number
}
function drop(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* drop() {
    var _options$signal5
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal5 = options.signal) !== null &&
      _options$signal5 !== undefined &&
      _options$signal5.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal6
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal6 = options.signal) !== null &&
        _options$signal6 !== undefined &&
        _options$signal6.aborted
      ) {
        throw new AbortError()
      }
      if (number-- <= 0) {
        yield val
      }
    }
  }.call(this)
}
function take(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* take() {
    var _options$signal7
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal7 = options.signal) !== null &&
      _options$signal7 !== undefined &&
      _options$signal7.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal8
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal8 = options.signal) !== null &&
        _options$signal8 !== undefined &&
        _options$signal8.aborted
      ) {
        throw new AbortError()
      }
      if (number-- > 0) {
        yield val
      }

      // Don't get another item from iterator in case we reached the end
      if (number <= 0) {
        return
      }
    }
  }.call(this)
}
module.exports.streamReturningOperators = {
  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),
  drop,
  filter,
  flatMap,
  map,
  take,
  compose
}
module.exports.promiseReturningOperators = {
  every,
  forEach,
  reduce,
  toArray,
  some,
  find
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/passthrough.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/passthrough.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



const { ObjectSetPrototypeOf } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
module.exports = PassThrough
const Transform = __webpack_require__(/*! ./transform */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/transform.js")
ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)
ObjectSetPrototypeOf(PassThrough, Transform)
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options)
  Transform.call(this, options)
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk)
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
const { once } = __webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const destroyImpl = __webpack_require__(/*! ./destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const Duplex = __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_PREMATURE_CLOSE
  },
  AbortError
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { validateFunction, validateAbortSignal } = __webpack_require__(/*! ../validators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js")
const {
  isIterable,
  isReadable,
  isReadableNodeStream,
  isNodeStream,
  isTransformStream,
  isWebStream,
  isReadableStream,
  isReadableFinished
} = __webpack_require__(/*! ./utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js").AbortController)
let PassThrough
let Readable
let addAbortListener
function destroyer(stream, reading, writing) {
  let finished = false
  stream.on('close', () => {
    finished = true
  })
  const cleanup = eos(
    stream,
    {
      readable: reading,
      writable: writing
    },
    (err) => {
      finished = !err
    }
  )
  return {
    destroy: (err) => {
      if (finished) return
      finished = true
      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))
    },
    cleanup
  }
}
function popCallback(streams) {
  // Streams should never be an empty array. It should always contain at least
  // a single stream. Therefore optimize for the average case instead of
  // checking for length === 0 as well.
  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')
  return streams.pop()
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val
  } else if (isReadableNodeStream(val)) {
    // Legacy streams are not Iterable.
    return fromReadable(val)
  }
  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)
}
async function* fromReadable(val) {
  if (!Readable) {
    Readable = __webpack_require__(/*! ./readable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js")
  }
  yield* Readable.prototype[SymbolAsyncIterator].call(val)
}
async function pumpToNode(iterable, writable, finish, { end }) {
  let error
  let onresolve = null
  const resume = (err) => {
    if (err) {
      error = err
    }
    if (onresolve) {
      const callback = onresolve
      onresolve = null
      callback()
    }
  }
  const wait = () =>
    new Promise((resolve, reject) => {
      if (error) {
        reject(error)
      } else {
        onresolve = () => {
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        }
      }
    })
  writable.on('drain', resume)
  const cleanup = eos(
    writable,
    {
      readable: false
    },
    resume
  )
  try {
    if (writable.writableNeedDrain) {
      await wait()
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait()
      }
    }
    if (end) {
      writable.end()
      await wait()
    }
    finish()
  } catch (err) {
    finish(error !== err ? aggregateTwoErrors(error, err) : err)
  } finally {
    cleanup()
    writable.off('drain', resume)
  }
}
async function pumpToWeb(readable, writable, finish, { end }) {
  if (isTransformStream(writable)) {
    writable = writable.writable
  }
  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure
  const writer = writable.getWriter()
  try {
    for await (const chunk of readable) {
      await writer.ready
      writer.write(chunk).catch(() => {})
    }
    await writer.ready
    if (end) {
      await writer.close()
    }
    finish()
  } catch (err) {
    try {
      await writer.abort(err)
      finish(err)
    } catch (err) {
      finish(err)
    }
  }
}
function pipeline(...streams) {
  return pipelineImpl(streams, once(popCallback(streams)))
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length === 1 && ArrayIsArray(streams[0])) {
    streams = streams[0]
  }
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams')
  }
  const ac = new AbortController()
  const signal = ac.signal
  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal

  // Need to cleanup event listeners if last stream is readable
  // https://github.com/nodejs/node/issues/35452
  const lastStreamCleanup = []
  validateAbortSignal(outerSignal, 'options.signal')
  function abort() {
    finishImpl(new AbortError())
  }
  addAbortListener = addAbortListener || (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").addAbortListener)
  let disposable
  if (outerSignal) {
    disposable = addAbortListener(outerSignal, abort)
  }
  let error
  let value
  const destroys = []
  let finishCount = 0
  function finish(err) {
    finishImpl(err, --finishCount === 0)
  }
  function finishImpl(err, final) {
    var _disposable
    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
      error = err
    }
    if (!error && !final) {
      return
    }
    while (destroys.length) {
      destroys.shift()(error)
    }
    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()
    ac.abort()
    if (final) {
      if (!error) {
        lastStreamCleanup.forEach((fn) => fn())
      }
      process.nextTick(callback, error, value)
    }
  }
  let ret
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i]
    const reading = i < streams.length - 1
    const writing = i > 0
    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false
    const isLastStream = i === streams.length - 1
    if (isNodeStream(stream)) {
      if (end) {
        const { destroy, cleanup } = destroyer(stream, reading, writing)
        destroys.push(destroy)
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }

      // Catch stream errors that occur after pipe/pump has completed.
      function onError(err) {
        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
          finish(err)
        }
      }
      stream.on('error', onError)
      if (isReadable(stream) && isLastStream) {
        lastStreamCleanup.push(() => {
          stream.removeListener('error', onError)
        })
      }
    }
    if (i === 0) {
      if (typeof stream === 'function') {
        ret = stream({
          signal
        })
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
        ret = stream
      } else {
        ret = Duplex.from(stream)
      }
    } else if (typeof stream === 'function') {
      if (isTransformStream(ret)) {
        var _ret
        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)
      } else {
        ret = makeAsyncIterable(ret)
      }
      ret = stream(ret, {
        signal
      })
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)
        }
      } else {
        var _ret2
        if (!PassThrough) {
          PassThrough = __webpack_require__(/*! ./passthrough */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/passthrough.js")
        }

        // If the last argument to pipeline is not a stream
        // we must create a proxy stream so that pipeline(...)
        // always returns a stream which can be further
        // composed through `.pipe(stream)`.

        const pt = new PassThrough({
          objectMode: true
        })

        // Handle Promises/A+ spec, `then` could be a getter that throws on
        // second use.
        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then
        if (typeof then === 'function') {
          finishCount++
          then.call(
            ret,
            (val) => {
              value = val
              if (val != null) {
                pt.write(val)
              }
              if (end) {
                pt.end()
              }
              process.nextTick(finish)
            },
            (err) => {
              pt.destroy(err)
              process.nextTick(finish, err)
            }
          )
        } else if (isIterable(ret, true)) {
          finishCount++
          pumpToNode(ret, pt, finish, {
            end
          })
        } else if (isReadableStream(ret) || isTransformStream(ret)) {
          const toRead = ret.readable || ret
          finishCount++
          pumpToNode(toRead, pt, finish, {
            end
          })
        } else {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)
        }
        ret = pt
        const { destroy, cleanup } = destroyer(ret, false, true)
        destroys.push(destroy)
        if (isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount += 2
        const cleanup = pipe(ret, stream, finish, {
          end
        })
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      } else if (isTransformStream(ret) || isReadableStream(ret)) {
        const toRead = ret.readable || ret
        finishCount++
        pumpToNode(toRead, stream, finish, {
          end
        })
      } else if (isIterable(ret)) {
        finishCount++
        pumpToNode(ret, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else if (isWebStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount++
        pumpToWeb(makeAsyncIterable(ret), stream, finish, {
          end
        })
      } else if (isReadableStream(ret) || isIterable(ret)) {
        finishCount++
        pumpToWeb(ret, stream, finish, {
          end
        })
      } else if (isTransformStream(ret)) {
        finishCount++
        pumpToWeb(ret.readable, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else {
      ret = Duplex.from(stream)
    }
  }
  if (
    (signal !== null && signal !== undefined && signal.aborted) ||
    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
  ) {
    process.nextTick(abort)
  }
  return ret
}
function pipe(src, dst, finish, { end }) {
  let ended = false
  dst.on('close', () => {
    if (!ended) {
      // Finish if the destination closes before the source has completed.
      finish(new ERR_STREAM_PREMATURE_CLOSE())
    }
  })
  src.pipe(dst, {
    end: false
  }) // If end is true we already will have a listener to end dst.

  if (end) {
    // Compat. Before node v10.12.0 stdio used to throw an error so
    // pipe() did/does not end() stdio destinations.
    // Now they allow it but "secretly" don't close the underlying fd.

    function endFn() {
      ended = true
      dst.end()
    }
    if (isReadableFinished(src)) {
      // End the destination if the source has already ended.
      process.nextTick(endFn)
    } else {
      src.once('end', endFn)
    }
  } else {
    finish()
  }
  eos(
    src,
    {
      readable: true,
      writable: false
    },
    (err) => {
      const rState = src._readableState
      if (
        err &&
        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
        rState &&
        rState.ended &&
        !rState.errored &&
        !rState.errorEmitted
      ) {
        // Some readable streams will emit 'close' before 'end'. However, since
        // this is on the readable side 'end' should still be emitted if the
        // stream has been ended and no error emitted. This should be allowed in
        // favor of backwards compatibility. Since the stream is piped to a
        // destination this should not result in any observable difference.
        // We don't need to check if this is a writable premature close since
        // eos will only fail with premature close on the reading side for
        // duplex streams.
        src.once('end', finish).once('error', finish)
      } else {
        finish(err)
      }
    }
  )
  return eos(
    dst,
    {
      readable: false,
      writable: true
    },
    finish
  )
}
module.exports = {
  pipelineImpl,
  pipeline
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const {
  ArrayPrototypeIndexOf,
  NumberIsInteger,
  NumberIsNaN,
  NumberParseInt,
  ObjectDefineProperties,
  ObjectKeys,
  ObjectSetPrototypeOf,
  Promise,
  SafeSet,
  SymbolAsyncDispose,
  SymbolAsyncIterator,
  Symbol
} = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
module.exports = Readable
Readable.ReadableState = ReadableState
const { EventEmitter: EE } = __webpack_require__(/*! events */ "events")
const { Stream, prependListener } = __webpack_require__(/*! ./legacy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js")
const { Buffer } = __webpack_require__(/*! buffer */ "buffer")
const { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js")
const eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
let debug = (__webpack_require__(/*! ../../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").debuglog)('stream', (fn) => {
  debug = fn
})
const BufferList = __webpack_require__(/*! ./buffer_list */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js")
const destroyImpl = __webpack_require__(/*! ./destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js")
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_OUT_OF_RANGE,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT
  },
  AbortError
} = __webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { validateObject } = __webpack_require__(/*! ../validators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js")
const kPaused = Symbol('kPaused')
const { StringDecoder } = __webpack_require__(/*! string_decoder */ "string_decoder")
const from = __webpack_require__(/*! ./from */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js")
ObjectSetPrototypeOf(Readable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Readable, Stream)
const nop = () => {}
const { errorOrDestroy } = destroyImpl
const kObjectMode = 1 << 0
const kEnded = 1 << 1
const kEndEmitted = 1 << 2
const kReading = 1 << 3
const kConstructed = 1 << 4
const kSync = 1 << 5
const kNeedReadable = 1 << 6
const kEmittedReadable = 1 << 7
const kReadableListening = 1 << 8
const kResumeScheduled = 1 << 9
const kErrorEmitted = 1 << 10
const kEmitClose = 1 << 11
const kAutoDestroy = 1 << 12
const kDestroyed = 1 << 13
const kClosed = 1 << 14
const kCloseEmitted = 1 << 15
const kMultiAwaitDrain = 1 << 16
const kReadingMore = 1 << 17
const kDataEmitted = 1 << 18

// TODO(benjamingr) it is likely slower to do it this way than with free functions
function makeBitMapDescriptor(bit) {
  return {
    enumerable: false,
    get() {
      return (this.state & bit) !== 0
    },
    set(value) {
      if (value) this.state |= bit
      else this.state &= ~bit
    }
  }
}
ObjectDefineProperties(ReadableState.prototype, {
  objectMode: makeBitMapDescriptor(kObjectMode),
  ended: makeBitMapDescriptor(kEnded),
  endEmitted: makeBitMapDescriptor(kEndEmitted),
  reading: makeBitMapDescriptor(kReading),
  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  constructed: makeBitMapDescriptor(kConstructed),
  // A flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  sync: makeBitMapDescriptor(kSync),
  // Whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  needReadable: makeBitMapDescriptor(kNeedReadable),
  emittedReadable: makeBitMapDescriptor(kEmittedReadable),
  readableListening: makeBitMapDescriptor(kReadableListening),
  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
  // True if the error was already emitted and should not be thrown again.
  errorEmitted: makeBitMapDescriptor(kErrorEmitted),
  emitClose: makeBitMapDescriptor(kEmitClose),
  autoDestroy: makeBitMapDescriptor(kAutoDestroy),
  // Has it been destroyed.
  destroyed: makeBitMapDescriptor(kDestroyed),
  // Indicates whether the stream has finished destroying.
  closed: makeBitMapDescriptor(kClosed),
  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  closeEmitted: makeBitMapDescriptor(kCloseEmitted),
  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
  // If true, a maybeReadMore has been scheduled.
  readingMore: makeBitMapDescriptor(kReadingMore),
  dataEmitted: makeBitMapDescriptor(kDataEmitted)
})
function ReadableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")

  // Bit map field to store ReadableState more effciently with 1 bit per field
  // instead of a V8 slot per field.
  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync
  // Object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away.
  if (options && options.objectMode) this.state |= kObjectMode
  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode

  // The point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift().
  this.buffer = new BufferList()
  this.length = 0
  this.pipes = []
  this.flowing = null
  this[kPaused] = null

  // Should close be emitted on destroy. Defaults to true.
  if (options && options.emitClose === false) this.state &= ~kEmitClose

  // Should .destroy() be called after 'end' (and potentially 'finish').
  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy

  // Indicates whether the stream has errored. When true no further
  // _read calls, 'data' or 'readable' events should occur. This is needed
  // since when autoDestroy is disabled we need a way to tell whether the
  // stream has failed.
  this.errored = null

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Ref the piped dest which we need a drain event on it
  // type: null | Writable | Set<Writable>.
  this.awaitDrainWriters = null
  this.decoder = null
  this.encoding = null
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding)
    this.encoding = options.encoding
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options)

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
  this._readableState = new ReadableState(options, this, isDuplex)
  if (options) {
    if (typeof options.read === 'function') this._read = options.read
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState)
    }
  })
}
Readable.prototype.destroy = destroyImpl.destroy
Readable.prototype._undestroy = destroyImpl.undestroy
Readable.prototype._destroy = function (err, cb) {
  cb(err)
}
Readable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}
Readable.prototype[SymbolAsyncDispose] = function () {
  let error
  if (!this.destroyed) {
    error = this.readableEnded ? null : new AbortError()
    this.destroy(error)
  }
  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false)
}

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true)
}
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug('readableAddChunk', chunk)
  const state = stream._readableState
  let err
  if ((state.state & kObjectMode) === 0) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          // When unshifting, if state.encoding is set, we have to save
          // the string in the BufferList with the state encoding.
          chunk = Buffer.from(chunk, encoding).toString(state.encoding)
        } else {
          chunk = Buffer.from(chunk, encoding)
          encoding = ''
        }
      }
    } else if (chunk instanceof Buffer) {
      encoding = ''
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = ''
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  if (err) {
    errorOrDestroy(stream, err)
  } else if (chunk === null) {
    state.state &= ~kReading
    onEofChunk(stream, state)
  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {
    if (addToFront) {
      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())
      else if (state.destroyed || state.errored) return false
      else addChunk(stream, state, chunk, true)
    } else if (state.ended) {
      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())
    } else if (state.destroyed || state.errored) {
      return false
    } else {
      state.state &= ~kReading
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk)
        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)
        else maybeReadMore(stream, state)
      } else {
        addChunk(stream, state, chunk, false)
      }
    }
  } else if (!addToFront) {
    state.state &= ~kReading
    maybeReadMore(stream, state)
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0)
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {
    // Use the guard to avoid creating `Set()` repeatedly
    // when we have multiple pipes.
    if ((state.state & kMultiAwaitDrain) !== 0) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
    state.dataEmitted = true
    stream.emit('data', chunk)
  } else {
    // Update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length
    if (addToFront) state.buffer.unshift(chunk)
    else state.buffer.push(chunk)
    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)
  }
  maybeReadMore(stream, state)
}
Readable.prototype.isPaused = function () {
  const state = this._readableState
  return state[kPaused] === true || state.flowing === false
}

// Backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  const decoder = new StringDecoder(enc)
  this._readableState.decoder = decoder
  // If setEncoding(null), decoder.encoding equals utf8.
  this._readableState.encoding = this._readableState.decoder.encoding
  const buffer = this._readableState.buffer
  // Iterate over current buffer to convert already stored Buffers:
  let content = ''
  for (const data of buffer) {
    content += decoder.write(data)
  }
  buffer.clear()
  if (content !== '') buffer.push(content)
  this._readableState.length = content.length
  return this
}

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000
function computeNewHighWaterMark(n) {
  if (n > MAX_HWM) {
    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts.
    n--
    n |= n >>> 1
    n |= n >>> 2
    n |= n >>> 4
    n |= n >>> 8
    n |= n >>> 16
    n++
  }
  return n
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || (state.length === 0 && state.ended)) return 0
  if ((state.state & kObjectMode) !== 0) return 1
  if (NumberIsNaN(n)) {
    // Only flow one buffer at a time.
    if (state.flowing && state.length) return state.buffer.first().length
    return state.length
  }
  if (n <= state.length) return n
  return state.ended ? state.length : 0
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n)
  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
  // in this scenario, so we are doing it manually.
  if (n === undefined) {
    n = NaN
  } else if (!NumberIsInteger(n)) {
    n = NumberParseInt(n, 10)
  }
  const state = this._readableState
  const nOrig = n

  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)
  if (n !== 0) state.state &= ~kEmittedReadable

  // If we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (
    n === 0 &&
    state.needReadable &&
    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
  ) {
    debug('read: emitReadable', state.length, state.ended)
    if (state.length === 0 && state.ended) endReadable(this)
    else emitReadable(this)
    return null
  }
  n = howMuchToRead(n, state)

  // If we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this)
    return null
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  let doRead = (state.state & kNeedReadable) !== 0
  debug('need readable', doRead)

  // If we currently have less than the highWaterMark, then also read some.
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true
    debug('length less than watermark', doRead)
  }

  // However, if we've ended, then there's no point, if we're already
  // reading, then it's unnecessary, if we're constructing we have to wait,
  // and if we're destroyed or errored, then it's not allowed,
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false
    debug('reading, ended or constructing', doRead)
  } else if (doRead) {
    debug('do read')
    state.state |= kReading | kSync
    // If the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.state |= kNeedReadable

    // Call internal read method
    try {
      this._read(state.highWaterMark)
    } catch (err) {
      errorOrDestroy(this, err)
    }
    state.state &= ~kSync

    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state)
  }
  let ret
  if (n > 0) ret = fromList(n, state)
  else ret = null
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark
    n = 0
  } else {
    state.length -= n
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this)
  }
  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
    state.dataEmitted = true
    this.emit('data', ret)
  }
  return ret
}
function onEofChunk(stream, state) {
  debug('onEofChunk')
  if (state.ended) return
  if (state.decoder) {
    const chunk = state.decoder.end()
    if (chunk && chunk.length) {
      state.buffer.push(chunk)
      state.length += state.objectMode ? 1 : chunk.length
    }
  }
  state.ended = true
  if (state.sync) {
    // If we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call.
    emitReadable(stream)
  } else {
    // Emit 'readable' now to make sure it gets picked up.
    state.needReadable = false
    state.emittedReadable = true
    // We have to emit readable now that we are EOF. Modules
    // in the ecosystem (e.g. dicer) rely on this event being sync.
    emitReadable_(stream)
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  const state = stream._readableState
  debug('emitReadable', state.needReadable, state.emittedReadable)
  state.needReadable = false
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing)
    state.emittedReadable = true
    process.nextTick(emitReadable_, stream)
  }
}
function emitReadable_(stream) {
  const state = stream._readableState
  debug('emitReadable_', state.destroyed, state.length, state.ended)
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit('readable')
    state.emittedReadable = false
  }

  // The stream needs another readable event if:
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark
  flow(stream)
}

// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true
    process.nextTick(maybeReadMore_, stream, state)
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (
    !state.reading &&
    !state.ended &&
    (state.length < state.highWaterMark || (state.flowing && state.length === 0))
  ) {
    const len = state.length
    debug('maybeReadMore read 0')
    stream.read(0)
    if (len === state.length)
      // Didn't get any data, stop spinning.
      break
  }
  state.readingMore = false
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')
}
Readable.prototype.pipe = function (dest, pipeOpts) {
  const src = this
  const state = this._readableState
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true
      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])
    }
  }
  state.pipes.push(dest)
  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr
  const endFn = doEnd ? onend : unpipe
  if (state.endEmitted) process.nextTick(endFn)
  else src.once('end', endFn)
  dest.on('unpipe', onunpipe)
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe')
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true
        cleanup()
      }
    }
  }
  function onend() {
    debug('onend')
    dest.end()
  }
  let ondrain
  let cleanedUp = false
  function cleanup() {
    debug('cleanup')
    // Cleanup event handlers once the pipe is broken.
    dest.removeListener('close', onclose)
    dest.removeListener('finish', onfinish)
    if (ondrain) {
      dest.removeListener('drain', ondrain)
    }
    dest.removeListener('error', onerror)
    dest.removeListener('unpipe', onunpipe)
    src.removeListener('end', onend)
    src.removeListener('end', unpipe)
    src.removeListener('data', ondata)
    cleanedUp = true

    // If the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()
  }
  function pause() {
    // If the user unpiped during `dest.write()`, it is possible
    // to get stuck in a permanently paused state if that write
    // also returned false.
    // => Check whether `dest` is still a piping destination.
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug('false write response, pause', 0)
        state.awaitDrainWriters = dest
        state.multiAwaitDrain = false
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug('false write response, pause', state.awaitDrainWriters.size)
        state.awaitDrainWriters.add(dest)
      }
      src.pause()
    }
    if (!ondrain) {
      // When the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      ondrain = pipeOnDrain(src, dest)
      dest.on('drain', ondrain)
    }
  }
  src.on('data', ondata)
  function ondata(chunk) {
    debug('ondata')
    const ret = dest.write(chunk)
    debug('dest.write', ret)
    if (ret === false) {
      pause()
    }
  }

  // If the dest has an error, then stop piping into it.
  // However, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er)
    unpipe()
    dest.removeListener('error', onerror)
    if (dest.listenerCount('error') === 0) {
      const s = dest._writableState || dest._readableState
      if (s && !s.errorEmitted) {
        // User incorrectly emitted 'error' directly on the stream.
        errorOrDestroy(dest, er)
      } else {
        dest.emit('error', er)
      }
    }
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror)

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish)
    unpipe()
  }
  dest.once('close', onclose)
  function onfinish() {
    debug('onfinish')
    dest.removeListener('close', onclose)
    unpipe()
  }
  dest.once('finish', onfinish)
  function unpipe() {
    debug('unpipe')
    src.unpipe(dest)
  }

  // Tell the dest that it's being piped to.
  dest.emit('pipe', src)

  // Start the flow if it hasn't been started already.

  if (dest.writableNeedDrain === true) {
    pause()
  } else if (!state.flowing) {
    debug('pipe resume')
    src.resume()
  }
  return dest
}
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState

    // `ondrain` will call directly,
    // `this` maybe not a reference to dest,
    // so we use the real dest here.
    if (state.awaitDrainWriters === dest) {
      debug('pipeOnDrain', 1)
      state.awaitDrainWriters = null
    } else if (state.multiAwaitDrain) {
      debug('pipeOnDrain', state.awaitDrainWriters.size)
      state.awaitDrainWriters.delete(dest)
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {
      src.resume()
    }
  }
}
Readable.prototype.unpipe = function (dest) {
  const state = this._readableState
  const unpipeInfo = {
    hasUnpiped: false
  }

  // If we're not piping anywhere, then do nothing.
  if (state.pipes.length === 0) return this
  if (!dest) {
    // remove all.
    const dests = state.pipes
    state.pipes = []
    this.pause()
    for (let i = 0; i < dests.length; i++)
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      })
    return this
  }

  // Try to find the right one.
  const index = ArrayPrototypeIndexOf(state.pipes, dest)
  if (index === -1) return this
  state.pipes.splice(index, 1)
  if (state.pipes.length === 0) this.pause()
  dest.emit('unpipe', this, unpipeInfo)
  return this
}

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function (ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn)
  const state = this._readableState
  if (ev === 'data') {
    // Update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0

    // Try start flowing on next tick if stream isn't explicitly paused.
    if (state.flowing !== false) this.resume()
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true
      state.flowing = false
      state.emittedReadable = false
      debug('on readable', state.length, state.reading)
      if (state.length) {
        emitReadable(this)
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this)
      }
    }
  }
  return res
}
Readable.prototype.addListener = Readable.prototype.on
Readable.prototype.removeListener = function (ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn)
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
Readable.prototype.off = Readable.prototype.removeListener
Readable.prototype.removeAllListeners = function (ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments)
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
function updateReadableListening(self) {
  const state = self._readableState
  state.readableListening = self.listenerCount('readable') > 0
  if (state.resumeScheduled && state[kPaused] === false) {
    // Flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true

    // Crude way to check if we should resume.
  } else if (self.listenerCount('data') > 0) {
    self.resume()
  } else if (!state.readableListening) {
    state.flowing = null
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0')
  self.read(0)
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  const state = this._readableState
  if (!state.flowing) {
    debug('resume')
    // We flow only if there is no one listening
    // for readable, but we still have to call
    // resume().
    state.flowing = !state.readableListening
    resume(this, state)
  }
  state[kPaused] = false
  return this
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true
    process.nextTick(resume_, stream, state)
  }
}
function resume_(stream, state) {
  debug('resume', state.reading)
  if (!state.reading) {
    stream.read(0)
  }
  state.resumeScheduled = false
  stream.emit('resume')
  flow(stream)
  if (state.flowing && !state.reading) stream.read(0)
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing)
  if (this._readableState.flowing !== false) {
    debug('pause')
    this._readableState.flowing = false
    this.emit('pause')
  }
  this._readableState[kPaused] = true
  return this
}
function flow(stream) {
  const state = stream._readableState
  debug('flow', state.flowing)
  while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  let paused = false

  // TODO (ronag): Should this.destroy(err) emit
  // 'error' on the wrapped stream? Would require
  // a static factory method, e.g. Readable.wrap(stream).

  stream.on('data', (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', () => {
    this.push(null)
  })
  stream.on('error', (err) => {
    errorOrDestroy(this, err)
  })
  stream.on('close', () => {
    this.destroy()
  })
  stream.on('destroy', () => {
    this.destroy()
  })
  this._read = () => {
    if (paused && stream.resume) {
      paused = false
      stream.resume()
    }
  }

  // Proxy all the other methods. Important when wrapping filters and duplexes.
  const streamKeys = ObjectKeys(stream)
  for (let j = 1; j < streamKeys.length; j++) {
    const i = streamKeys[j]
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = stream[i].bind(stream)
    }
  }
  return this
}
Readable.prototype[SymbolAsyncIterator] = function () {
  return streamToAsyncIterator(this)
}
Readable.prototype.iterator = function (options) {
  if (options !== undefined) {
    validateObject(options, 'options')
  }
  return streamToAsyncIterator(this, options)
}
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== 'function') {
    stream = Readable.wrap(stream, {
      objectMode: true
    })
  }
  const iter = createAsyncIterator(stream, options)
  iter.stream = stream
  return iter
}
async function* createAsyncIterator(stream, options) {
  let callback = nop
  function next(resolve) {
    if (this === stream) {
      callback()
      callback = nop
    } else {
      callback = resolve
    }
  }
  stream.on('readable', next)
  let error
  const cleanup = eos(
    stream,
    {
      writable: false
    },
    (err) => {
      error = err ? aggregateTwoErrors(error, err) : null
      callback()
      callback = nop
    }
  )
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read()
      if (chunk !== null) {
        yield chunk
      } else if (error) {
        throw error
      } else if (error === null) {
        return
      } else {
        await new Promise(next)
      }
    }
  } catch (err) {
    error = aggregateTwoErrors(error, err)
    throw error
  } finally {
    if (
      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&
      (error === undefined || stream._readableState.autoDestroy)
    ) {
      destroyImpl.destroyer(stream, null)
    } else {
      stream.off('readable', next)
      cleanup()
    }
  }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
ObjectDefineProperties(Readable.prototype, {
  readable: {
    __proto__: null,
    get() {
      const r = this._readableState
      // r.readable === false means that this is part of a Duplex stream
      // where the readable side was disabled upon construction.
      // Compat. The user might manually disable readable side through
      // deprecated setter.
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted
    },
    set(val) {
      // Backwards compat.
      if (this._readableState) {
        this._readableState.readable = !!val
      }
    }
  },
  readableDidRead: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.dataEmitted
    }
  },
  readableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._readableState.readable !== false &&
        (this._readableState.destroyed || this._readableState.errored) &&
        !this._readableState.endEmitted
      )
    }
  },
  readableHighWaterMark: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.highWaterMark
    }
  },
  readableBuffer: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState && this._readableState.buffer
    }
  },
  readableFlowing: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.flowing
    },
    set: function (state) {
      if (this._readableState) {
        this._readableState.flowing = state
      }
    }
  },
  readableLength: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState.length
    }
  },
  readableObjectMode: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false
    }
  },
  readableEncoding: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.errored : null
    }
  },
  closed: {
    __proto__: null,
    get() {
      return this._readableState ? this._readableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.destroyed : false
    },
    set(value) {
      // We ignore the value if the stream
      // has not been initialized yet.
      if (!this._readableState) {
        return
      }

      // Backward compatibility, the user is explicitly
      // managing destroyed.
      this._readableState.destroyed = value
    }
  },
  readableEnded: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false
    }
  }
})
ObjectDefineProperties(ReadableState.prototype, {
  // Legacy getter for `pipesCount`.
  pipesCount: {
    __proto__: null,
    get() {
      return this.pipes.length
    }
  },
  // Legacy property for `paused`.
  paused: {
    __proto__: null,
    get() {
      return this[kPaused] !== false
    },
    set(value) {
      this[kPaused] = !!value
    }
  }
})

// Exposed for testing purposes only.
Readable._fromList = fromList

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered.
  if (state.length === 0) return null
  let ret
  if (state.objectMode) ret = state.buffer.shift()
  else if (!n || n >= state.length) {
    // Read it all, truncate the list.
    if (state.decoder) ret = state.buffer.join('')
    else if (state.buffer.length === 1) ret = state.buffer.first()
    else ret = state.buffer.concat(state.length)
    state.buffer.clear()
  } else {
    // read part of list.
    ret = state.buffer.consume(n, state.decoder)
  }
  return ret
}
function endReadable(stream) {
  const state = stream._readableState
  debug('endReadable', state.endEmitted)
  if (!state.endEmitted) {
    state.ended = true
    process.nextTick(endReadableNT, state, stream)
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length)

  // Check that we didn't get one last unshift.
  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true
    stream.emit('end')
    if (stream.writable && stream.allowHalfOpen === false) {
      process.nextTick(endWritableNT, stream)
    } else if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well.
      const wState = stream._writableState
      const autoDestroy =
        !wState ||
        (wState.autoDestroy &&
          // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false))
      if (autoDestroy) {
        stream.destroy()
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed
  if (writable) {
    stream.end()
  }
}
Readable.from = function (iterable, opts) {
  return from(Readable, iterable, opts)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Readable.fromWeb = function (readableStream, options) {
  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)
}
Readable.toWeb = function (streamReadable, options) {
  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)
}
Readable.wrap = function (src, options) {
  var _ref, _src$readableObjectMo
  return new Readable({
    objectMode:
      (_ref =
        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined
          ? _src$readableObjectMo
          : src.objectMode) !== null && _ref !== undefined
        ? _ref
        : true,
    ...options,
    destroy(err, callback) {
      destroyImpl.destroyer(src, err)
      callback(err)
    }
  }).wrap(src)
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { MathFloor, NumberIsInteger } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { validateInteger } = __webpack_require__(/*! ../validators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js")
const { ERR_INVALID_ARG_VALUE } = (__webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js").codes)
let defaultHighWaterMarkBytes = 16 * 1024
let defaultHighWaterMarkObjectMode = 16
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes
}
function setDefaultHighWaterMark(objectMode, value) {
  validateInteger(value, 'value', 0)
  if (objectMode) {
    defaultHighWaterMarkObjectMode = value
  } else {
    defaultHighWaterMarkBytes = value
  }
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)
  if (hwm != null) {
    if (!NumberIsInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'
      throw new ERR_INVALID_ARG_VALUE(name, hwm)
    }
    return MathFloor(hwm)
  }

  // Default value
  return getDefaultHighWaterMark(state.objectMode)
}
module.exports = {
  getHighWaterMark,
  getDefaultHighWaterMark,
  setDefaultHighWaterMark
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/transform.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/transform.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



const { ObjectSetPrototypeOf, Symbol } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
module.exports = Transform
const { ERR_METHOD_NOT_IMPLEMENTED } = (__webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js").codes)
const Duplex = __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
const { getHighWaterMark } = __webpack_require__(/*! ./state */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js")
ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)
ObjectSetPrototypeOf(Transform, Duplex)
const kCallback = Symbol('kCallback')
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options)

  // TODO (ronag): This should preferably always be
  // applied but would be semver-major. Or even better;
  // make Transform a Readable with the Writable interface.
  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null
  if (readableHighWaterMark === 0) {
    // A Duplex will buffer both on the writable and readable side while
    // a Transform just wants to buffer hwm number of elements. To avoid
    // buffering twice we disable buffering on the writable side.
    options = {
      ...options,
      highWaterMark: null,
      readableHighWaterMark,
      // TODO (ronag): 0 is not optimal since we have
      // a "bug" where we check needDrain before calling _write and not after.
      // Refs: https://github.com/nodejs/node/pull/32887
      // Refs: https://github.com/nodejs/node/pull/35941
      writableHighWaterMark: options.writableHighWaterMark || 0
    }
  }
  Duplex.call(this, options)

  // We have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false
  this[kCallback] = null
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform
    if (typeof options.flush === 'function') this._flush = options.flush
  }

  // When the writable side finishes, then flush out anything remaining.
  // Backwards compat. Some Transform streams incorrectly implement _final
  // instead of or in addition to _flush. By using 'prefinish' instead of
  // implementing _final we continue supporting this unfortunate use case.
  this.on('prefinish', prefinish)
}
function final(cb) {
  if (typeof this._flush === 'function' && !this.destroyed) {
    this._flush((er, data) => {
      if (er) {
        if (cb) {
          cb(er)
        } else {
          this.destroy(er)
        }
        return
      }
      if (data != null) {
        this.push(data)
      }
      this.push(null)
      if (cb) {
        cb()
      }
    })
  } else {
    this.push(null)
    if (cb) {
      cb()
    }
  }
}
function prefinish() {
  if (this._final !== final) {
    final.call(this)
  }
}
Transform.prototype._final = final
Transform.prototype._transform = function (chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')
}
Transform.prototype._write = function (chunk, encoding, callback) {
  const rState = this._readableState
  const wState = this._writableState
  const length = rState.length
  this._transform(chunk, encoding, (err, val) => {
    if (err) {
      callback(err)
      return
    }
    if (val != null) {
      this.push(val)
    }
    if (
      wState.ended ||
      // Backwards compat.
      length === rState.length ||
      // Backwards compat.
      rState.length < rState.highWaterMark
    ) {
      callback()
    } else {
      this[kCallback] = callback
    }
  })
}
Transform.prototype._read = function () {
  if (this[kCallback]) {
    const callback = this[kCallback]
    this[kCallback] = null
    callback()
  }
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { SymbolAsyncIterator, SymbolIterator, SymbolFor } = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")

// We need to use SymbolFor to make these globally available
// for interopt with readable-stream, i.e. readable-stream
// and node core needs to be able to read/write private state
// from each other for proper interoperability.
const kIsDestroyed = SymbolFor('nodejs.stream.destroyed')
const kIsErrored = SymbolFor('nodejs.stream.errored')
const kIsReadable = SymbolFor('nodejs.stream.readable')
const kIsWritable = SymbolFor('nodejs.stream.writable')
const kIsDisturbed = SymbolFor('nodejs.stream.disturbed')
const kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')
const kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')
function isReadableNodeStream(obj, strict = false) {
  var _obj$_readableState
  return !!(
    (
      obj &&
      typeof obj.pipe === 'function' &&
      typeof obj.on === 'function' &&
      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&
      (!obj._writableState ||
        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined
          ? undefined
          : _obj$_readableState.readable) !== false) &&
      // Duplex
      (!obj._writableState || obj._readableState)
    ) // Writable has .pipe.
  )
}

function isWritableNodeStream(obj) {
  var _obj$_writableState
  return !!(
    (
      obj &&
      typeof obj.write === 'function' &&
      typeof obj.on === 'function' &&
      (!obj._readableState ||
        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined
          ? undefined
          : _obj$_writableState.writable) !== false)
    ) // Duplex
  )
}

function isDuplexNodeStream(obj) {
  return !!(
    obj &&
    typeof obj.pipe === 'function' &&
    obj._readableState &&
    typeof obj.on === 'function' &&
    typeof obj.write === 'function'
  )
}
function isNodeStream(obj) {
  return (
    obj &&
    (obj._readableState ||
      obj._writableState ||
      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))
  )
}
function isReadableStream(obj) {
  return !!(
    obj &&
    !isNodeStream(obj) &&
    typeof obj.pipeThrough === 'function' &&
    typeof obj.getReader === 'function' &&
    typeof obj.cancel === 'function'
  )
}
function isWritableStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')
}
function isTransformStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')
}
function isWebStream(obj) {
  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)
}
function isIterable(obj, isAsync) {
  if (obj == null) return false
  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'
  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'
  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'
}
function isDestroyed(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))
}

// Have been end():d.
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableEnded === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null
  return wState.ended
}

// Have emitted 'finish'.
function isWritableFinished(stream, strict) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableFinished === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null
  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))
}

// Have been push(null):d.
function isReadableEnded(stream) {
  if (!isReadableNodeStream(stream)) return null
  if (stream.readableEnded === true) return true
  const rState = stream._readableState
  if (!rState || rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null
  return rState.ended
}

// Have emitted 'end'.
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream)) return null
  const rState = stream._readableState
  if (rState !== null && rState !== undefined && rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null
  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))
}
function isReadable(stream) {
  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]
  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)
}
function isWritable(stream) {
  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]
  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)
}
function isFinished(stream, opts) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (isDestroyed(stream)) {
    return true
  }
  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
    return false
  }
  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
    return false
  }
  return true
}
function isWritableErrored(stream) {
  var _stream$_writableStat, _stream$_writableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.writableErrored) {
    return stream.writableErrored
  }
  return (_stream$_writableStat =
    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined
      ? undefined
      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined
    ? _stream$_writableStat
    : null
}
function isReadableErrored(stream) {
  var _stream$_readableStat, _stream$_readableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.readableErrored) {
    return stream.readableErrored
  }
  return (_stream$_readableStat =
    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined
      ? undefined
      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined
    ? _stream$_readableStat
    : null
}
function isClosed(stream) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (typeof stream.closed === 'boolean') {
    return stream.closed
  }
  const wState = stream._writableState
  const rState = stream._readableState
  if (
    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||
    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'
  ) {
    return (
      (wState === null || wState === undefined ? undefined : wState.closed) ||
      (rState === null || rState === undefined ? undefined : rState.closed)
    )
  }
  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
    return stream._closed
  }
  return null
}
function isOutgoingMessage(stream) {
  return (
    typeof stream._closed === 'boolean' &&
    typeof stream._defaultKeepAlive === 'boolean' &&
    typeof stream._removedConnection === 'boolean' &&
    typeof stream._removedContLen === 'boolean'
  )
}
function isServerResponse(stream) {
  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)
}
function isServerRequest(stream) {
  var _stream$req
  return (
    typeof stream._consuming === 'boolean' &&
    typeof stream._dumped === 'boolean' &&
    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===
      undefined
  )
}
function willEmitClose(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return (
    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)
  )
}
function isDisturbed(stream) {
  var _stream$kIsDisturbed
  return !!(
    stream &&
    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined
      ? _stream$kIsDisturbed
      : stream.readableDidRead || stream.readableAborted)
  )
}
function isErrored(stream) {
  var _ref,
    _ref2,
    _ref3,
    _ref4,
    _ref5,
    _stream$kIsErrored,
    _stream$_readableStat3,
    _stream$_writableStat3,
    _stream$_readableStat4,
    _stream$_writableStat4
  return !!(
    stream &&
    ((_ref =
      (_ref2 =
        (_ref3 =
          (_ref4 =
            (_ref5 =
              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined
                ? _stream$kIsErrored
                : stream.readableErrored) !== null && _ref5 !== undefined
              ? _ref5
              : stream.writableErrored) !== null && _ref4 !== undefined
            ? _ref4
            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined
            ? undefined
            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined
          ? _ref3
          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined
          ? undefined
          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined
        ? _ref2
        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined
        ? undefined
        : _stream$_readableStat4.errored) !== null && _ref !== undefined
      ? _ref
      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined
      ? undefined
      : _stream$_writableStat4.errored)
  )
}
module.exports = {
  isDestroyed,
  kIsDestroyed,
  isDisturbed,
  kIsDisturbed,
  isErrored,
  kIsErrored,
  isReadable,
  kIsReadable,
  kIsClosedPromise,
  kControllerErrorFunction,
  kIsWritable,
  isClosed,
  isDuplexNodeStream,
  isFinished,
  isIterable,
  isReadableNodeStream,
  isReadableStream,
  isReadableEnded,
  isReadableFinished,
  isReadableErrored,
  isNodeStream,
  isWebStream,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableEnded,
  isWritableFinished,
  isWritableErrored,
  isServerRequest,
  isServerResponse,
  willEmitClose,
  isTransformStream
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const process = __webpack_require__(/*! process/ */ "../../node_modules/process/index.js")

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

;('use strict')
const {
  ArrayPrototypeSlice,
  Error,
  FunctionPrototypeSymbolHasInstance,
  ObjectDefineProperty,
  ObjectDefineProperties,
  ObjectSetPrototypeOf,
  StringPrototypeToLowerCase,
  Symbol,
  SymbolHasInstance
} = __webpack_require__(/*! ../../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
module.exports = Writable
Writable.WritableState = WritableState
const { EventEmitter: EE } = __webpack_require__(/*! events */ "events")
const Stream = (__webpack_require__(/*! ./legacy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js").Stream)
const { Buffer } = __webpack_require__(/*! buffer */ "buffer")
const destroyImpl = __webpack_require__(/*! ./destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const { addAbortSignal } = __webpack_require__(/*! ./add-abort-signal */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js")
const { getHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./state */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js")
const {
  ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED,
  ERR_STREAM_ALREADY_FINISHED,
  ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING
} = (__webpack_require__(/*! ../../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js").codes)
const { errorOrDestroy } = destroyImpl
ObjectSetPrototypeOf(Writable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Writable, Stream)
function nop() {}
const kOnFinished = Symbol('kOnFinished')
function WritableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")

  // Object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!(options && options.objectMode)
  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)

  // The point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write().
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // if _final has been called.
  this.finalCalled = false

  // drain event flag.
  this.needDrain = false
  // At the start of calling end()
  this.ending = false
  // When end() has been called, and returned.
  this.ended = false
  // When 'finish' is emitted.
  this.finished = false

  // Has it been destroyed
  this.destroyed = false

  // Should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  const noDecode = !!(options && options.decodeStrings === false)
  this.decodeStrings = !noDecode

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0

  // A flag to see when we're in the middle of a write.
  this.writing = false

  // When true all writes will be buffered until .uncork() call.
  this.corked = 0

  // A flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true

  // A flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false

  // The callback that's passed to _write(chunk, cb).
  this.onwrite = onwrite.bind(undefined, stream)

  // The callback that the user supplies to write(chunk, encoding, cb).
  this.writecb = null

  // The amount that is being written when _write is called.
  this.writelen = 0

  // Storage for data passed to the afterWrite() callback in case of
  // synchronous _write() completion.
  this.afterWriteTickInfo = null
  resetBuffer(this)

  // Number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted.
  this.pendingcb = 0

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true

  // Emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams.
  this.prefinished = false

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false

  // Should .destroy() be called after 'finish' (and potentially 'end').
  this.autoDestroy = !options || options.autoDestroy !== false

  // Indicates whether the stream has errored. When true all write() calls
  // should return false. This is needed since when autoDestroy
  // is disabled we need a way to tell whether the stream has failed.
  this.errored = null

  // Indicates whether the stream has finished destroying.
  this.closed = false

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false
  this[kOnFinished] = []
}
function resetBuffer(state) {
  state.buffered = []
  state.bufferedIndex = 0
  state.allBuffers = true
  state.allNoop = true
}
WritableState.prototype.getBuffer = function getBuffer() {
  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)
}
ObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {
  __proto__: null,
  get() {
    return this.buffered.length - this.bufferedIndex
  }
})
function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof __webpack_require__(/*! ./duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)
  this._writableState = new WritableState(options, this, isDuplex)
  if (options) {
    if (typeof options.write === 'function') this._write = options.write
    if (typeof options.writev === 'function') this._writev = options.writev
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.final === 'function') this._final = options.final
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    const state = this._writableState
    if (!state.writing) {
      clearBuffer(this, state)
    }
    finishMaybe(this, state)
  })
}
ObjectDefineProperty(Writable, SymbolHasInstance, {
  __proto__: null,
  value: function (object) {
    if (FunctionPrototypeSymbolHasInstance(this, object)) return true
    if (this !== Writable) return false
    return object && object._writableState instanceof WritableState
  }
})

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())
}
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState
  if (typeof encoding === 'function') {
    cb = encoding
    encoding = state.defaultEncoding
  } else {
    if (!encoding) encoding = state.defaultEncoding
    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
    if (typeof cb !== 'function') cb = nop
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES()
  } else if (!state.objectMode) {
    if (typeof chunk === 'string') {
      if (state.decodeStrings !== false) {
        chunk = Buffer.from(chunk, encoding)
        encoding = 'buffer'
      }
    } else if (chunk instanceof Buffer) {
      encoding = 'buffer'
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = 'buffer'
    } else {
      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  let err
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END()
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('write')
  }
  if (err) {
    process.nextTick(cb, err)
    errorOrDestroy(stream, err, true)
    return err
  }
  state.pendingcb++
  return writeOrBuffer(stream, state, chunk, encoding, cb)
}
Writable.prototype.write = function (chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true
}
Writable.prototype.cork = function () {
  this._writableState.corked++
}
Writable.prototype.uncork = function () {
  const state = this._writableState
  if (state.corked) {
    state.corked--
    if (!state.writing) clearBuffer(this, state)
  }
}
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)
  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
  this._writableState.defaultEncoding = encoding
  return this
}

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length
  state.length += len

  // stream._write resets state.length
  const ret = state.length < state.highWaterMark
  // We must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({
      chunk,
      encoding,
      callback
    })
    if (state.allBuffers && encoding !== 'buffer') {
      state.allBuffers = false
    }
    if (state.allNoop && callback !== nop) {
      state.allNoop = false
    }
  } else {
    state.writelen = len
    state.writecb = callback
    state.writing = true
    state.sync = true
    stream._write(chunk, encoding, state.onwrite)
    state.sync = false
  }

  // Return false if errored or destroyed in order to break
  // any synchronous while(stream.write(data)) loops.
  return ret && !state.errored && !state.destroyed
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len
  state.writecb = cb
  state.writing = true
  state.sync = true
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))
  else if (writev) stream._writev(chunk, state.onwrite)
  else stream._write(chunk, encoding, state.onwrite)
  state.sync = false
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb
  cb(er)
  // Ensure callbacks are invoked even when autoDestroy is
  // not enabled. Passing `er` here doesn't make sense since
  // it's related to one specific write, not to the buffered
  // writes.
  errorBuffer(state)
  // This can emit error, but error must always follow cb.
  errorOrDestroy(stream, er)
}
function onwrite(stream, er) {
  const state = stream._writableState
  const sync = state.sync
  const cb = state.writecb
  if (typeof cb !== 'function') {
    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())
    return
  }
  state.writing = false
  state.writecb = null
  state.length -= state.writelen
  state.writelen = 0
  if (er) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    er.stack // eslint-disable-line no-unused-expressions

    if (!state.errored) {
      state.errored = er
    }

    // In case of duplex streams we need to notify the readable side of the
    // error.
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er
    }
    if (sync) {
      process.nextTick(onwriteError, stream, state, er, cb)
    } else {
      onwriteError(stream, state, er, cb)
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state)
    }
    if (sync) {
      // It is a common case that the callback passed to .write() is always
      // the same. In that case, we do not schedule a new nextTick(), but
      // rather just increase a counter, to improve performance and avoid
      // memory allocations.
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++
      } else {
        state.afterWriteTickInfo = {
          count: 1,
          cb,
          stream,
          state
        }
        process.nextTick(afterWriteTick, state.afterWriteTickInfo)
      }
    } else {
      afterWrite(stream, state, 1, cb)
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null
  return afterWrite(stream, state, count, cb)
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain
  if (needDrain) {
    state.needDrain = false
    stream.emit('drain')
  }
  while (count-- > 0) {
    state.pendingcb--
    cb()
  }
  if (state.destroyed) {
    errorBuffer(state)
  }
  finishMaybe(stream, state)
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
  if (state.writing) {
    return
  }
  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    var _state$errored
    const { chunk, callback } = state.buffered[n]
    const len = state.objectMode ? 1 : chunk.length
    state.length -= len
    callback(
      (_state$errored = state.errored) !== null && _state$errored !== undefined
        ? _state$errored
        : new ERR_STREAM_DESTROYED('write')
    )
  }
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    var _state$errored2
    onfinishCallbacks[i](
      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined
        ? _state$errored2
        : new ERR_STREAM_DESTROYED('end')
    )
  }
  resetBuffer(state)
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return
  }
  const { buffered, bufferedIndex, objectMode } = state
  const bufferedLength = buffered.length - bufferedIndex
  if (!bufferedLength) {
    return
  }
  let i = bufferedIndex
  state.bufferProcessing = true
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1
    const callback = state.allNoop
      ? nop
      : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err)
          }
        }
    // Make a copy of `buffered` if it's going to be used by `callback` above,
    // since `doWrite` will mutate the array.
    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)
    chunks.allBuffers = state.allBuffers
    doWrite(stream, state, true, state.length, chunks, '', callback)
    resetBuffer(state)
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i]
      buffered[i++] = null
      const len = objectMode ? 1 : chunk.length
      doWrite(stream, state, false, len, chunk, encoding, callback)
    } while (i < buffered.length && !state.writing)
    if (i === buffered.length) {
      resetBuffer(state)
    } else if (i > 256) {
      buffered.splice(0, i)
      state.bufferedIndex = 0
    } else {
      state.bufferedIndex = i
    }
  }
  state.bufferProcessing = false
}
Writable.prototype._write = function (chunk, encoding, cb) {
  if (this._writev) {
    this._writev(
      [
        {
          chunk,
          encoding
        }
      ],
      cb
    )
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')
  }
}
Writable.prototype._writev = null
Writable.prototype.end = function (chunk, encoding, cb) {
  const state = this._writableState
  if (typeof chunk === 'function') {
    cb = chunk
    chunk = null
    encoding = null
  } else if (typeof encoding === 'function') {
    cb = encoding
    encoding = null
  }
  let err
  if (chunk !== null && chunk !== undefined) {
    const ret = _write(this, chunk, encoding)
    if (ret instanceof Error) {
      err = ret
    }
  }

  // .end() fully uncorks.
  if (state.corked) {
    state.corked = 1
    this.uncork()
  }
  if (err) {
    // Do nothing...
  } else if (!state.errored && !state.ending) {
    // This is forgiving in terms of unnecessary calls to end() and can hide
    // logic errors. However, usually such errors are harmless and causing a
    // hard error can be disproportionately destructive. It is not always
    // trivial for the user to determine whether end() needs to be called
    // or not.

    state.ending = true
    finishMaybe(this, state, true)
    state.ended = true
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED('end')
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('end')
  }
  if (typeof cb === 'function') {
    if (err || state.finished) {
      process.nextTick(cb, err)
    } else {
      state[kOnFinished].push(cb)
    }
  }
  return this
}
function needFinish(state) {
  return (
    state.ending &&
    !state.destroyed &&
    state.constructed &&
    state.length === 0 &&
    !state.errored &&
    state.buffered.length === 0 &&
    !state.finished &&
    !state.writing &&
    !state.errorEmitted &&
    !state.closeEmitted
  )
}
function callFinal(stream, state) {
  let called = false
  function onFinish(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    state.pendingcb--
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0)
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err)
      }
      errorOrDestroy(stream, err, state.sync)
    } else if (needFinish(state)) {
      state.prefinished = true
      stream.emit('prefinish')
      // Backwards compat. Don't check state.sync here.
      // Some streams assume 'finish' will be emitted
      // asynchronously relative to _final callback.
      state.pendingcb++
      process.nextTick(finish, stream, state)
    }
  }
  state.sync = true
  state.pendingcb++
  try {
    stream._final(onFinish)
  } catch (err) {
    onFinish(err)
  }
  state.sync = false
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.finalCalled = true
      callFinal(stream, state)
    } else {
      state.prefinished = true
      stream.emit('prefinish')
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state)
    if (state.pendingcb === 0) {
      if (sync) {
        state.pendingcb++
        process.nextTick(
          (stream, state) => {
            if (needFinish(state)) {
              finish(stream, state)
            } else {
              state.pendingcb--
            }
          },
          stream,
          state
        )
      } else if (needFinish(state)) {
        state.pendingcb++
        finish(stream, state)
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--
  state.finished = true
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]()
  }
  stream.emit('finish')
  if (state.autoDestroy) {
    // In case of duplex streams we need a way to detect
    // if the readable side is ready for autoDestroy as well.
    const rState = stream._readableState
    const autoDestroy =
      !rState ||
      (rState.autoDestroy &&
        // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false))
    if (autoDestroy) {
      stream.destroy()
    }
  }
}
ObjectDefineProperties(Writable.prototype, {
  closed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.destroyed : false
    },
    set(value) {
      // Backward compatibility, the user is explicitly managing destroyed.
      if (this._writableState) {
        this._writableState.destroyed = value
      }
    }
  },
  writable: {
    __proto__: null,
    get() {
      const w = this._writableState
      // w.writable === false means that this is part of a Duplex stream
      // where the writable side was disabled upon construction.
      // Compat. The user might manually disable writable side through
      // deprecated setter.
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended
    },
    set(val) {
      // Backwards compatible.
      if (this._writableState) {
        this._writableState.writable = !!val
      }
    }
  },
  writableFinished: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.finished : false
    }
  },
  writableObjectMode: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.objectMode : false
    }
  },
  writableBuffer: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.getBuffer()
    }
  },
  writableEnded: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.ending : false
    }
  },
  writableNeedDrain: {
    __proto__: null,
    get() {
      const wState = this._writableState
      if (!wState) return false
      return !wState.destroyed && !wState.ending && wState.needDrain
    }
  },
  writableHighWaterMark: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.highWaterMark
    }
  },
  writableCorked: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.corked : 0
    }
  },
  writableLength: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.length
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._writableState ? this._writableState.errored : null
    }
  },
  writableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._writableState.writable !== false &&
        (this._writableState.destroyed || this._writableState.errored) &&
        !this._writableState.finished
      )
    }
  }
})
const destroy = destroyImpl.destroy
Writable.prototype.destroy = function (err, cb) {
  const state = this._writableState

  // Invoke pending callbacks.
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    process.nextTick(errorBuffer, state)
  }
  destroy.call(this, err, cb)
  return this
}
Writable.prototype._undestroy = destroyImpl.undestroy
Writable.prototype._destroy = function (err, cb) {
  cb(err)
}
Writable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Writable.fromWeb = function (writableStream, options) {
  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)
}
Writable.toWeb = function (streamWritable) {
  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint jsdoc/require-jsdoc: "error" */



const {
  ArrayIsArray,
  ArrayPrototypeIncludes,
  ArrayPrototypeJoin,
  ArrayPrototypeMap,
  NumberIsInteger,
  NumberIsNaN,
  NumberMAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER,
  NumberParseInt,
  ObjectPrototypeHasOwnProperty,
  RegExpPrototypeExec,
  String,
  StringPrototypeToUpperCase,
  StringPrototypeTrim
} = __webpack_require__(/*! ../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const {
  hideStackFrames,
  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
} = __webpack_require__(/*! ../ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const { normalizeEncoding } = __webpack_require__(/*! ../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const { isAsyncFunction, isArrayBufferView } = (__webpack_require__(/*! ../ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js").types)
const signals = {}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isInt32(value) {
  return value === (value | 0)
}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isUint32(value) {
  return value === value >>> 0
}
const octalReg = /^[0-7]+$/
const modeDesc = 'must be a 32-bit unsigned integer or an octal string'

/**
 * Parse and validate values that will be converted into mode_t (the S_*
 * constants). Only valid numbers and octal strings are allowed. They could be
 * converted to 32-bit unsigned integers or non-negative signed integers in the
 * C++ land, but any value higher than 0o777 will result in platform-specific
 * behaviors.
 * @param {*} value Values to be validated
 * @param {string} name Name of the argument
 * @param {number} [def] If specified, will be returned for invalid values
 * @returns {number}
 */
function parseFileMode(value, name, def) {
  if (typeof value === 'undefined') {
    value = def
  }
  if (typeof value === 'string') {
    if (RegExpPrototypeExec(octalReg, value) === null) {
      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)
    }
    value = NumberParseInt(value, 8)
  }
  validateUint32(value, name)
  return value
}

/**
 * @callback validateInteger
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInteger} */
const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
})

/**
 * @callback validateInt32
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInt32} */
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
  // The defaults for min and max correspond to the limits of 32-bit integers.
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateUint32
 * @param {*} value
 * @param {string} name
 * @param {number|boolean} [positive=false]
 * @returns {asserts value is number}
 */

/** @type {validateUint32} */
const validateUint32 = hideStackFrames((value, name, positive = false) => {
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  const min = positive ? 1 : 0
  // 2 ** 32 === 4294967296
  const max = 4294967295
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateString
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string}
 */

/** @type {validateString} */
function validateString(value, name) {
  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)
}

/**
 * @callback validateNumber
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateNumber} */
function validateNumber(value, name, min = undefined, max) {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (
    (min != null && value < min) ||
    (max != null && value > max) ||
    ((min != null || max != null) && NumberIsNaN(value))
  ) {
    throw new ERR_OUT_OF_RANGE(
      name,
      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
      value
    )
  }
}

/**
 * @callback validateOneOf
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} oneOf
 */

/** @type {validateOneOf} */
const validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!ArrayPrototypeIncludes(oneOf, value)) {
    const allowed = ArrayPrototypeJoin(
      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),
      ', '
    )
    const reason = 'must be one of: ' + allowed
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateBoolean
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean}
 */

/** @type {validateBoolean} */
function validateBoolean(value, name) {
  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)
}

/**
 * @param {any} options
 * @param {string} key
 * @param {boolean} defaultValue
 * @returns {boolean}
 */
function getOwnPropertyValueOrDefault(options, key, defaultValue) {
  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]
}

/**
 * @callback validateObject
 * @param {*} value
 * @param {string} name
 * @param {{
 *   allowArray?: boolean,
 *   allowFunction?: boolean,
 *   nullable?: boolean
 * }} [options]
 */

/** @type {validateObject} */
const validateObject = hideStackFrames((value, name, options = null) => {
  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)
  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)
  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)
  if (
    (!nullable && value === null) ||
    (!allowArray && ArrayIsArray(value)) ||
    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))
  ) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)
  }
})

/**
 * @callback validateDictionary - We are using the Web IDL Standard definition
 *                                of "dictionary" here, which means any value
 *                                whose Type is either Undefined, Null, or
 *                                Object (which includes functions).
 * @param {*} value
 * @param {string} name
 * @see https://webidl.spec.whatwg.org/#es-dictionary
 * @see https://tc39.es/ecma262/#table-typeof-operator-results
 */

/** @type {validateDictionary} */
const validateDictionary = hideStackFrames((value, name) => {
  if (value != null && typeof value !== 'object' && typeof value !== 'function') {
    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)
  }
})

/**
 * @callback validateArray
 * @param {*} value
 * @param {string} name
 * @param {number} [minLength]
 * @returns {asserts value is any[]}
 */

/** @type {validateArray} */
const validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!ArrayIsArray(value)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateStringArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string[]}
 */

/** @type {validateStringArray} */
function validateStringArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateString(value[i], `${name}[${i}]`)
  }
}

/**
 * @callback validateBooleanArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean[]}
 */

/** @type {validateBooleanArray} */
function validateBooleanArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateBoolean(value[i], `${name}[${i}]`)
  }
}

/**
 * @callback validateAbortSignalArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is AbortSignal[]}
 */

/** @type {validateAbortSignalArray} */
function validateAbortSignalArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    const signal = value[i]
    const indexedName = `${name}[${i}]`
    if (signal == null) {
      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)
    }
    validateAbortSignal(signal, indexedName)
  }
}

/**
 * @param {*} signal
 * @param {string} [name='signal']
 * @returns {asserts signal is keyof signals}
 */
function validateSignalName(signal, name = 'signal') {
  validateString(signal, name)
  if (signals[signal] === undefined) {
    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')
    }
    throw new ERR_UNKNOWN_SIGNAL(signal)
  }
}

/**
 * @callback validateBuffer
 * @param {*} buffer
 * @param {string} [name='buffer']
 * @returns {asserts buffer is ArrayBufferView}
 */

/** @type {validateBuffer} */
const validateBuffer = hideStackFrames((buffer, name = 'buffer') => {
  if (!isArrayBufferView(buffer)) {
    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)
  }
})

/**
 * @param {string} data
 * @param {string} encoding
 */
function validateEncoding(data, encoding) {
  const normalizedEncoding = normalizeEncoding(encoding)
  const length = data.length
  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)
  }
}

/**
 * Check that the port number is not NaN when coerced to a number,
 * is an integer and that it falls within the legal range of port numbers.
 * @param {*} port
 * @param {string} [name='Port']
 * @param {boolean} [allowZero=true]
 * @returns {number}
 */
function validatePort(port, name = 'Port', allowZero = true) {
  if (
    (typeof port !== 'number' && typeof port !== 'string') ||
    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||
    +port !== +port >>> 0 ||
    port > 0xffff ||
    (port === 0 && !allowZero)
  ) {
    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)
  }
  return port | 0
}

/**
 * @callback validateAbortSignal
 * @param {*} signal
 * @param {string} name
 */

/** @type {validateAbortSignal} */
const validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
})

/**
 * @callback validateFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validateFunction} */
const validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validatePlainFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validatePlainFunction} */
const validatePlainFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validateUndefined
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is undefined}
 */

/** @type {validateUndefined} */
const validateUndefined = hideStackFrames((value, name) => {
  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)
})

/**
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} union
 */
function validateUnion(value, name, union) {
  if (!ArrayPrototypeIncludes(union, value)) {
    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)
  }
}

/*
  The rules for the Link header field are described here:
  https://www.rfc-editor.org/rfc/rfc8288.html#section-3

  This regex validates any string surrounded by angle brackets
  (not necessarily a valid URI reference) followed by zero or more
  link-params separated by semicolons.
*/
const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/

/**
 * @param {any} value
 * @param {string} name
 */
function validateLinkHeaderFormat(value, name) {
  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {
    throw new ERR_INVALID_ARG_VALUE(
      name,
      value,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    )
  }
}

/**
 * @param {any} hints
 * @return {string}
 */
function validateLinkHeaderValue(hints) {
  if (typeof hints === 'string') {
    validateLinkHeaderFormat(hints, 'hints')
    return hints
  } else if (ArrayIsArray(hints)) {
    const hintsLength = hints.length
    let result = ''
    if (hintsLength === 0) {
      return result
    }
    for (let i = 0; i < hintsLength; i++) {
      const link = hints[i]
      validateLinkHeaderFormat(link, 'hints')
      result += link
      if (i !== hintsLength - 1) {
        result += ', '
      }
    }
    return result
  }
  throw new ERR_INVALID_ARG_VALUE(
    'hints',
    hints,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  )
}
module.exports = {
  isInt32,
  isUint32,
  parseFileMode,
  validateArray,
  validateStringArray,
  validateBooleanArray,
  validateAbortSignalArray,
  validateBoolean,
  validateBuffer,
  validateDictionary,
  validateEncoding,
  validateFunction,
  validateInt32,
  validateInteger,
  validateNumber,
  validateObject,
  validateOneOf,
  validatePlainFunction,
  validatePort,
  validateSignalName,
  validateString,
  validateUint32,
  validateUndefined,
  validateUnion,
  validateAbortSignal,
  validateLinkHeaderValue
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { format, inspect, AggregateError: CustomAggregateError } = __webpack_require__(/*! ./util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")

/*
  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/errors.js

  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)
  with the upstream file.
*/

const AggregateError = globalThis.AggregateError || CustomAggregateError
const kIsNodeError = Symbol('kIsNodeError')
const kTypes = [
  'string',
  'function',
  'number',
  'object',
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  'Function',
  'Object',
  'boolean',
  'bigint',
  'symbol'
]
const classRegExp = /^([A-Z][a-z0-9]*)+$/
const nodeInternalPrefix = '__node_internal_'
const codes = {}
function assert(value, message) {
  if (!value) {
    throw new codes.ERR_INTERNAL_ASSERTION(message)
  }
}

// Only use this for integers! Decimal numbers do not work with this function.
function addNumericalSeparator(val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}
function getMessage(key, msg, args) {
  if (typeof msg === 'function') {
    assert(
      msg.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
    )
    return msg(...args)
  }
  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length
  assert(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  )
  if (args.length === 0) {
    return msg
  }
  return format(msg, ...args)
}
function E(code, message, Base) {
  if (!Base) {
    Base = Error
  }
  class NodeError extends Base {
    constructor(...args) {
      super(getMessage(code, message, args))
    }
    toString() {
      return `${this.name} [${code}]: ${this.message}`
    }
  }
  Object.defineProperties(NodeError.prototype, {
    name: {
      value: Base.name,
      writable: true,
      enumerable: false,
      configurable: true
    },
    toString: {
      value() {
        return `${this.name} [${code}]: ${this.message}`
      },
      writable: true,
      enumerable: false,
      configurable: true
    }
  })
  NodeError.prototype.code = code
  NodeError.prototype[kIsNodeError] = true
  codes[code] = NodeError
}
function hideStackFrames(fn) {
  // We rename the functions that will be hidden to cut off the stacktrace
  // at the outermost one
  const hidden = nodeInternalPrefix + fn.name
  Object.defineProperty(fn, 'name', {
    value: hidden
  })
  return fn
}
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      // If `outerError` is already an `AggregateError`.
      outerError.errors.push(innerError)
      return outerError
    }
    const err = new AggregateError([outerError, innerError], outerError.message)
    err.code = outerError.code
    return err
  }
  return innerError || outerError
}
class AbortError extends Error {
  constructor(message = 'The operation was aborted', options = undefined) {
    if (options !== undefined && typeof options !== 'object') {
      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)
    }
    super(message, options)
    this.code = 'ABORT_ERR'
    this.name = 'AbortError'
  }
}
E('ERR_ASSERTION', '%s', Error)
E(
  'ERR_INVALID_ARG_TYPE',
  (name, expected, actual) => {
    assert(typeof name === 'string', "'name' must be a string")
    if (!Array.isArray(expected)) {
      expected = [expected]
    }
    let msg = 'The '
    if (name.endsWith(' argument')) {
      // For cases like 'first argument'
      msg += `${name} `
    } else {
      msg += `"${name}" ${name.includes('.') ? 'property' : 'argument'} `
    }
    msg += 'must be '
    const types = []
    const instances = []
    const other = []
    for (const value of expected) {
      assert(typeof value === 'string', 'All expected entries have to be of type string')
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase())
      } else if (classRegExp.test(value)) {
        instances.push(value)
      } else {
        assert(value !== 'object', 'The value "object" should be written as "Object"')
        other.push(value)
      }
    }

    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
      const pos = types.indexOf('object')
      if (pos !== -1) {
        types.splice(types, pos, 1)
        instances.push('Object')
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`
          break
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`
          break
        default: {
          const last = types.pop()
          msg += `one of type ${types.join(', ')}, or ${last}`
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += ' or '
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`
          break
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`
          break
        default: {
          const last = instances.pop()
          msg += `an instance of ${instances.join(', ')}, or ${last}`
        }
      }
      if (other.length > 0) {
        msg += ' or '
      }
    }
    switch (other.length) {
      case 0:
        break
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += 'an '
        }
        msg += `${other[0]}`
        break
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`
        break
      default: {
        const last = other.pop()
        msg += `one of ${other.join(', ')}, or ${last}`
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`
    } else if (typeof actual === 'function' && actual.name) {
      msg += `. Received function ${actual.name}`
    } else if (typeof actual === 'object') {
      var _actual$constructor
      if (
        (_actual$constructor = actual.constructor) !== null &&
        _actual$constructor !== undefined &&
        _actual$constructor.name
      ) {
        msg += `. Received an instance of ${actual.constructor.name}`
      } else {
        const inspected = inspect(actual, {
          depth: -1
        })
        msg += `. Received ${inspected}`
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      })
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`
      }
      msg += `. Received type ${typeof actual} (${inspected})`
    }
    return msg
  },
  TypeError
)
E(
  'ERR_INVALID_ARG_VALUE',
  (name, value, reason = 'is invalid') => {
    let inspected = inspect(value)
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + '...'
    }
    const type = name.includes('.') ? 'property' : 'argument'
    return `The ${type} '${name}' ${reason}. Received ${inspected}`
  },
  TypeError
)
E(
  'ERR_INVALID_RETURN_VALUE',
  (input, name, value) => {
    var _value$constructor
    const type =
      value !== null &&
      value !== undefined &&
      (_value$constructor = value.constructor) !== null &&
      _value$constructor !== undefined &&
      _value$constructor.name
        ? `instance of ${value.constructor.name}`
        : `type ${typeof value}`
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`
  },
  TypeError
)
E(
  'ERR_MISSING_ARGS',
  (...args) => {
    assert(args.length > 0, 'At least one arg needs to be specified')
    let msg
    const len = args.length
    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(' or ')
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`
        break
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`
        break
      default:
        {
          const last = args.pop()
          msg += `The ${args.join(', ')}, and ${last} arguments`
        }
        break
    }
    return `${msg} must be specified`
  },
  TypeError
)
E(
  'ERR_OUT_OF_RANGE',
  (str, range, input) => {
    assert(range, 'Missing "range" argument')
    let received
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    } else {
      received = inspect(input)
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`
  },
  RangeError
)
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)
E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)
E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)
E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)
E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)
E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)
E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)
E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)
E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)
E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)
module.exports = {
  AbortError,
  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
  hideStackFrames,
  codes
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


/*
  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js

  Don't try to replace with the original file and keep it up to date with the upstream file.
*/
module.exports = {
  ArrayIsArray(self) {
    return Array.isArray(self)
  },
  ArrayPrototypeIncludes(self, el) {
    return self.includes(el)
  },
  ArrayPrototypeIndexOf(self, el) {
    return self.indexOf(el)
  },
  ArrayPrototypeJoin(self, sep) {
    return self.join(sep)
  },
  ArrayPrototypeMap(self, fn) {
    return self.map(fn)
  },
  ArrayPrototypePop(self, el) {
    return self.pop(el)
  },
  ArrayPrototypePush(self, el) {
    return self.push(el)
  },
  ArrayPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  Error,
  FunctionPrototypeCall(fn, thisArgs, ...args) {
    return fn.call(thisArgs, ...args)
  },
  FunctionPrototypeSymbolHasInstance(self, instance) {
    return Function.prototype[Symbol.hasInstance].call(self, instance)
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(self, props) {
    return Object.defineProperties(self, props)
  },
  ObjectDefineProperty(self, name, prop) {
    return Object.defineProperty(self, name, prop)
  },
  ObjectGetOwnPropertyDescriptor(self, name) {
    return Object.getOwnPropertyDescriptor(self, name)
  },
  ObjectKeys(obj) {
    return Object.keys(obj)
  },
  ObjectSetPrototypeOf(target, proto) {
    return Object.setPrototypeOf(target, proto)
  },
  Promise,
  PromisePrototypeCatch(self, fn) {
    return self.catch(fn)
  },
  PromisePrototypeThen(self, thenFn, catchFn) {
    return self.then(thenFn, catchFn)
  },
  PromiseReject(err) {
    return Promise.reject(err)
  },
  PromiseResolve(val) {
    return Promise.resolve(val)
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(self, value) {
    return self.test(value)
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  StringPrototypeToLowerCase(self) {
    return self.toLowerCase()
  },
  StringPrototypeToUpperCase(self) {
    return self.toUpperCase()
  },
  StringPrototypeTrim(self) {
    return self.trim()
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),
  TypedArrayPrototypeSet(self, buf, len) {
    return self.set(buf, len)
  },
  Boolean: Boolean,
  Uint8Array
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const bufferModule = __webpack_require__(/*! buffer */ "buffer")
const { kResistStopPropagation, SymbolDispose } = __webpack_require__(/*! ./primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const AbortSignal = globalThis.AbortSignal || (__webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js").AbortSignal)
const AbortController = globalThis.AbortController || (__webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js").AbortController)
const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor
const Blob = globalThis.Blob || bufferModule.Blob
/* eslint-disable indent */
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        // eslint-disable-next-line indent
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
/* eslint-enable indent */

const validateAbortSignal = (signal, name) => {
  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
}
const validateFunction = (value, name) => {
  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
}

// This is a simplified version of AggregateError
class AggregateError extends Error {
  constructor(errors) {
    if (!Array.isArray(errors)) {
      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)
    }
    let message = ''
    for (let i = 0; i < errors.length; i++) {
      message += `    ${errors[i].stack}\n`
    }
    super(message)
    this.name = 'AggregateError'
    this.errors = errors
  }
}
module.exports = {
  AggregateError,
  kEmptyObject: Object.freeze({}),
  once(callback) {
    let called = false
    return function (...args) {
      if (called) {
        return
      }
      called = true
      callback.apply(this, args)
    }
  },
  createDeferredPromise: function () {
    let resolve
    let reject

    // eslint-disable-next-line promise/param-names
    const promise = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })
    return {
      promise,
      resolve,
      reject
    }
  },
  promisify(fn) {
    return new Promise((resolve, reject) => {
      fn((err, ...args) => {
        if (err) {
          return reject(err)
        }
        return resolve(...args)
      })
    })
  },
  debuglog() {
    return function () {}
  },
  format(format, ...args) {
    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args
    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {
      const replacement = args.shift()
      if (type === 'f') {
        return replacement.toFixed(6)
      } else if (type === 'j') {
        return JSON.stringify(replacement)
      } else if (type === 's' && typeof replacement === 'object') {
        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''
        return `${ctor} {}`.trim()
      } else {
        return replacement.toString()
      }
    })
  },
  inspect(value) {
    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options
    switch (typeof value) {
      case 'string':
        if (value.includes("'")) {
          if (!value.includes('"')) {
            return `"${value}"`
          } else if (!value.includes('`') && !value.includes('${')) {
            return `\`${value}\``
          }
        }
        return `'${value}'`
      case 'number':
        if (isNaN(value)) {
          return 'NaN'
        } else if (Object.is(value, -0)) {
          return String(value)
        }
        return value
      case 'bigint':
        return `${String(value)}n`
      case 'boolean':
      case 'undefined':
        return String(value)
      case 'object':
        return '{}'
    }
  },
  types: {
    isAsyncFunction(fn) {
      return fn instanceof AsyncFunction
    },
    isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr)
    }
  },
  isBlob,
  deprecate(fn, message) {
    return fn
  },
  addAbortListener:
    (__webpack_require__(/*! events */ "events").addAbortListener) ||
    function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)
      }
      validateAbortSignal(signal, 'signal')
      validateFunction(listener, 'listener')
      let removeEventListener
      if (signal.aborted) {
        queueMicrotask(() => listener())
      } else {
        signal.addEventListener('abort', listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        })
        removeEventListener = () => {
          signal.removeEventListener('abort', listener)
        }
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener
          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined
            ? undefined
            : _removeEventListener()
        }
      }
    },
  AbortSignalAny:
    AbortSignal.any ||
    function AbortSignalAny(signals) {
      // Fast path if there is only one signal.
      if (signals.length === 1) {
        return signals[0]
      }
      const ac = new AbortController()
      const abort = () => ac.abort()
      signals.forEach((signal) => {
        validateAbortSignal(signal, 'signals')
        signal.addEventListener('abort', abort, {
          once: true
        })
      })
      ac.signal.addEventListener(
        'abort',
        () => {
          signals.forEach((signal) => signal.removeEventListener('abort', abort))
        },
        {
          once: true
        }
      )
      return ac.signal
    }
}
module.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/stream.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/stream.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* replacement start */

const { Buffer } = __webpack_require__(/*! buffer */ "buffer")

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const { ObjectDefineProperty, ObjectKeys, ReflectApply } = __webpack_require__(/*! ./ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const {
  promisify: { custom: customPromisify }
} = __webpack_require__(/*! ./ours/util */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js")
const { streamReturningOperators, promiseReturningOperators } = __webpack_require__(/*! ./internal/streams/operators */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/operators.js")
const {
  codes: { ERR_ILLEGAL_CONSTRUCTOR }
} = __webpack_require__(/*! ./ours/errors */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js")
const compose = __webpack_require__(/*! ./internal/streams/compose */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/compose.js")
const { setDefaultHighWaterMark, getDefaultHighWaterMark } = __webpack_require__(/*! ./internal/streams/state */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js")
const { pipeline } = __webpack_require__(/*! ./internal/streams/pipeline */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js")
const { destroyer } = __webpack_require__(/*! ./internal/streams/destroy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js")
const eos = __webpack_require__(/*! ./internal/streams/end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
const internalBuffer = {}
const promises = __webpack_require__(/*! ./stream/promises */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/stream/promises.js")
const utils = __webpack_require__(/*! ./internal/streams/utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const Stream = (module.exports = __webpack_require__(/*! ./internal/streams/legacy */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js").Stream)
Stream.isDestroyed = utils.isDestroyed
Stream.isDisturbed = utils.isDisturbed
Stream.isErrored = utils.isErrored
Stream.isReadable = utils.isReadable
Stream.isWritable = utils.isWritable
Stream.Readable = __webpack_require__(/*! ./internal/streams/readable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js")
for (const key of ObjectKeys(streamReturningOperators)) {
  const op = streamReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return Stream.Readable.from(ReflectApply(op, this, args))
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
for (const key of ObjectKeys(promiseReturningOperators)) {
  const op = promiseReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return ReflectApply(op, this, args)
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
Stream.Writable = __webpack_require__(/*! ./internal/streams/writable */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js")
Stream.Duplex = __webpack_require__(/*! ./internal/streams/duplex */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js")
Stream.Transform = __webpack_require__(/*! ./internal/streams/transform */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/transform.js")
Stream.PassThrough = __webpack_require__(/*! ./internal/streams/passthrough */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/passthrough.js")
Stream.pipeline = pipeline
const { addAbortSignal } = __webpack_require__(/*! ./internal/streams/add-abort-signal */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js")
Stream.addAbortSignal = addAbortSignal
Stream.finished = eos
Stream.destroy = destroyer
Stream.compose = compose
Stream.setDefaultHighWaterMark = setDefaultHighWaterMark
Stream.getDefaultHighWaterMark = getDefaultHighWaterMark
ObjectDefineProperty(Stream, 'promises', {
  __proto__: null,
  configurable: true,
  enumerable: true,
  get() {
    return promises
  }
})
ObjectDefineProperty(pipeline, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.pipeline
  }
})
ObjectDefineProperty(eos, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.finished
  }
})

// Backwards-compat with node 0.4.x
Stream.Stream = Stream
Stream._isUint8Array = function isUint8Array(value) {
  return value instanceof Uint8Array
}
Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
}


/***/ }),

/***/ "../../node_modules/winston-transport/node_modules/readable-stream/lib/stream/promises.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/winston-transport/node_modules/readable-stream/lib/stream/promises.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { ArrayPrototypePop, Promise } = __webpack_require__(/*! ../ours/primordials */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js")
const { isIterable, isNodeStream, isWebStream } = __webpack_require__(/*! ../internal/streams/utils */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js")
const { pipelineImpl: pl } = __webpack_require__(/*! ../internal/streams/pipeline */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js")
const { finished } = __webpack_require__(/*! ../internal/streams/end-of-stream */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
__webpack_require__(/*! ../../lib/stream.js */ "../../node_modules/winston-transport/node_modules/readable-stream/lib/stream.js")
function pipeline(...streams) {
  return new Promise((resolve, reject) => {
    let signal
    let end
    const lastArg = streams[streams.length - 1]
    if (
      lastArg &&
      typeof lastArg === 'object' &&
      !isNodeStream(lastArg) &&
      !isIterable(lastArg) &&
      !isWebStream(lastArg)
    ) {
      const options = ArrayPrototypePop(streams)
      signal = options.signal
      end = options.end
    }
    pl(
      streams,
      (err, value) => {
        if (err) {
          reject(err)
        } else {
          resolve(value)
        }
      },
      {
        signal,
        end
      }
    )
  })
}
module.exports = {
  finished,
  pipeline
}


/***/ }),

/***/ "../../node_modules/winston/lib/winston.js":
/*!*************************************************!*\
  !*** ../../node_modules/winston/lib/winston.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * winston.js: Top-level include defining Winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const logform = __webpack_require__(/*! logform */ "../../node_modules/logform/index.js");
const { warn } = __webpack_require__(/*! ./winston/common */ "../../node_modules/winston/lib/winston/common.js");

/**
 * Expose version. Use `require` method for `webpack` support.
 * @type {string}
 */
exports.version = __webpack_require__(/*! ../package.json */ "../../node_modules/winston/package.json").version;
/**
 * Include transports defined by default by winston
 * @type {Array}
 */
exports.transports = __webpack_require__(/*! ./winston/transports */ "../../node_modules/winston/lib/winston/transports/index.js");
/**
 * Expose utility methods
 * @type {Object}
 */
exports.config = __webpack_require__(/*! ./winston/config */ "../../node_modules/winston/lib/winston/config/index.js");
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */
exports.addColors = logform.levels;
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */
exports.format = logform.format;
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */
exports.createLogger = __webpack_require__(/*! ./winston/create-logger */ "../../node_modules/winston/lib/winston/create-logger.js");
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */
exports.Logger = __webpack_require__(/*! ./winston/logger */ "../../node_modules/winston/lib/winston/logger.js");
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.ExceptionHandler = __webpack_require__(/*! ./winston/exception-handler */ "../../node_modules/winston/lib/winston/exception-handler.js");
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.RejectionHandler = __webpack_require__(/*! ./winston/rejection-handler */ "../../node_modules/winston/lib/winston/rejection-handler.js");
/**
 * Expose core Logging-related prototypes.
 * @type {Container}
 */
exports.Container = __webpack_require__(/*! ./winston/container */ "../../node_modules/winston/lib/winston/container.js");
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */
exports.Transport = __webpack_require__(/*! winston-transport */ "../../node_modules/winston-transport/index.js");
/**
 * We create and expose a default `Container` to `winston.loggers` so that the
 * programmer may manage multiple `winston.Logger` instances without any
 * additional overhead.
 * @example
 *   // some-file1.js
 *   const logger = require('winston').loggers.get('something');
 *
 *   // some-file2.js
 *   const logger = require('winston').loggers.get('something');
 */
exports.loggers = new exports.Container();

/**
 * We create and expose a 'defaultLogger' so that the programmer may do the
 * following without the need to create an instance of winston.Logger directly:
 * @example
 *   const winston = require('winston');
 *   winston.log('info', 'some message');
 *   winston.error('some error');
 */
const defaultLogger = exports.createLogger();

// Pass through the target methods onto `winston.
Object.keys(exports.config.npm.levels)
  .concat([
    'log',
    'query',
    'stream',
    'add',
    'remove',
    'clear',
    'profile',
    'startTimer',
    'handleExceptions',
    'unhandleExceptions',
    'handleRejections',
    'unhandleRejections',
    'configure',
    'child'
  ])
  .forEach(
    method => (exports[method] = (...args) => defaultLogger[method](...args))
  );

/**
 * Define getter / setter for the default logger level which need to be exposed
 * by winston.
 * @type {string}
 */
Object.defineProperty(exports, "level", ({
  get() {
    return defaultLogger.level;
  },
  set(val) {
    defaultLogger.level = val;
  }
}));

/**
 * Define getter for `exceptions` which replaces `handleExceptions` and
 * `unhandleExceptions`.
 * @type {Object}
 */
Object.defineProperty(exports, "exceptions", ({
  get() {
    return defaultLogger.exceptions;
  }
}));

/**
 * Define getter for `rejections` which replaces `handleRejections` and
 * `unhandleRejections`.
 * @type {Object}
 */
Object.defineProperty(exports, "rejections", ({
  get() {
    return defaultLogger.rejections;
  }
}));

/**
 * Define getters / setters for appropriate properties of the default logger
 * which need to be exposed by winston.
 * @type {Logger}
 */
['exitOnError'].forEach(prop => {
  Object.defineProperty(exports, prop, {
    get() {
      return defaultLogger[prop];
    },
    set(val) {
      defaultLogger[prop] = val;
    }
  });
});

/**
 * The default transports and exceptionHandlers for the default winston logger.
 * @type {Object}
 */
Object.defineProperty(exports, "default", ({
  get() {
    return {
      exceptionHandlers: defaultLogger.exceptionHandlers,
      rejectionHandlers: defaultLogger.rejectionHandlers,
      transports: defaultLogger.transports
    };
  }
}));

// Have friendlier breakage notices for properties that were exposed by default
// on winston < 3.0.
warn.deprecated(exports, 'setLevels');
warn.forFunctions(exports, 'useFormat', ['cli']);
warn.forProperties(exports, 'useFormat', ['padLevels', 'stripColors']);
warn.forFunctions(exports, 'deprecated', [
  'addRewriter',
  'addFilter',
  'clone',
  'extend'
]);
warn.forProperties(exports, 'deprecated', ['emitErrs', 'levelLength']);



/***/ }),

/***/ "../../node_modules/winston/lib/winston/common.js":
/*!********************************************************!*\
  !*** ../../node_modules/winston/lib/winston/common.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * common.js: Internal helper and utility functions for winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { format } = __webpack_require__(/*! util */ "util");

/**
 * Set of simple deprecation notices and a way to expose them for a set of
 * properties.
 * @type {Object}
 * @private
 */
exports.warn = {
  deprecated(prop) {
    return () => {
      throw new Error(format('{ %s } was removed in winston@3.0.0.', prop));
    };
  },
  useFormat(prop) {
    return () => {
      throw new Error([
        format('{ %s } was removed in winston@3.0.0.', prop),
        'Use a custom winston.format = winston.format(function) instead.'
      ].join('\n'));
    };
  },
  forFunctions(obj, type, props) {
    props.forEach(prop => {
      obj[prop] = exports.warn[type](prop);
    });
  },
  forProperties(obj, type, props) {
    props.forEach(prop => {
      const notice = exports.warn[type](prop);
      Object.defineProperty(obj, prop, {
        get: notice,
        set: notice
      });
    });
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/config/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/config/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const logform = __webpack_require__(/*! logform */ "../../node_modules/logform/index.js");
const { configs } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");

/**
 * Export config set for the CLI.
 * @type {Object}
 */
exports.cli = logform.levels(configs.cli);

/**
 * Export config set for npm.
 * @type {Object}
 */
exports.npm = logform.levels(configs.npm);

/**
 * Export config set for the syslog.
 * @type {Object}
 */
exports.syslog = logform.levels(configs.syslog);

/**
 * Hoist addColors from logform where it was refactored into in winston@3.
 * @type {Object}
 */
exports.addColors = logform.levels;


/***/ }),

/***/ "../../node_modules/winston/lib/winston/container.js":
/*!***********************************************************!*\
  !*** ../../node_modules/winston/lib/winston/container.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * container.js: Inversion of control container for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const createLogger = __webpack_require__(/*! ./create-logger */ "../../node_modules/winston/lib/winston/create-logger.js");

/**
 * Inversion of control container for winston logger instances.
 * @type {Container}
 */
module.exports = class Container {
  /**
   * Constructor function for the Container object responsible for managing a
   * set of `winston.Logger` instances based on string ids.
   * @param {!Object} [options={}] - Default pass-thru options for Loggers.
   */
  constructor(options = {}) {
    this.loggers = new Map();
    this.options = options;
  }

  /**
   * Retrieves a `winston.Logger` instance for the specified `id`. If an
   * instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */
  add(id, options) {
    if (!this.loggers.has(id)) {
      // Remark: Simple shallow clone for configuration options in case we pass
      // in instantiated protoypal objects
      options = Object.assign({}, options || this.options);
      const existing = options.transports || this.options.transports;

      // Remark: Make sure if we have an array of transports we slice it to
      // make copies of those references.
      if (existing) {
        options.transports = Array.isArray(existing) ? existing.slice() : [existing];
      } else {
        options.transports = [];
      }

      const logger = createLogger(options);
      logger.on('close', () => this._delete(id));
      this.loggers.set(id, logger);
    }

    return this.loggers.get(id);
  }

  /**
   * Retreives a `winston.Logger` instance for the specified `id`. If
   * an instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */
  get(id, options) {
    return this.add(id, options);
  }

  /**
   * Check if the container has a logger with the id.
   * @param {?string} id - The id of the Logger instance to find.
   * @returns {boolean} - Boolean value indicating if this instance has a
   * logger with the specified `id`.
   */
  has(id) {
    return !!this.loggers.has(id);
  }

  /**
   * Closes a `Logger` instance with the specified `id` if it exists.
   * If no `id` is supplied then all Loggers are closed.
   * @param {?string} id - The id of the Logger instance to close.
   * @returns {undefined}
   */
  close(id) {
    if (id) {
      return this._removeLogger(id);
    }

    this.loggers.forEach((val, key) => this._removeLogger(key));
  }

  /**
   * Remove a logger based on the id.
   * @param {!string} id - The id of the logger to remove.
   * @returns {undefined}
   * @private
   */
  _removeLogger(id) {
    if (!this.loggers.has(id)) {
      return;
    }

    const logger = this.loggers.get(id);
    logger.close();
    this._delete(id);
  }

  /**
   * Deletes a `Logger` instance with the specified `id`.
   * @param {!string} id - The id of the Logger instance to delete from
   * container.
   * @returns {undefined}
   * @private
   */
  _delete(id) {
    this.loggers.delete(id);
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/create-logger.js":
/*!***************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/create-logger.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * create-logger.js: Logger factory for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { LEVEL } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const config = __webpack_require__(/*! ./config */ "../../node_modules/winston/lib/winston/config/index.js");
const Logger = __webpack_require__(/*! ./logger */ "../../node_modules/winston/lib/winston/logger.js");
const debug = __webpack_require__(/*! @dabh/diagnostics */ "../../node_modules/@dabh/diagnostics/node/index.js")('winston:create-logger');

function isLevelEnabledFunctionName(level) {
  return 'is' + level.charAt(0).toUpperCase() + level.slice(1) + 'Enabled';
}

/**
 * Create a new instance of a winston Logger. Creates a new
 * prototype for each instance.
 * @param {!Object} opts - Options for the created logger.
 * @returns {Logger} - A newly created logger instance.
 */
module.exports = function (opts = {}) {
  //
  // Default levels: npm
  //
  opts.levels = opts.levels || config.npm.levels;

  /**
   * DerivedLogger to attach the logs level methods.
   * @type {DerivedLogger}
   * @extends {Logger}
   */
  class DerivedLogger extends Logger {
    /**
     * Create a new class derived logger for which the levels can be attached to
     * the prototype of. This is a V8 optimization that is well know to increase
     * performance of prototype functions.
     * @param {!Object} options - Options for the created logger.
     */
    constructor(options) {
      super(options);
    }
  }

  const logger = new DerivedLogger(opts);

  //
  // Create the log level methods for the derived logger.
  //
  Object.keys(opts.levels).forEach(function (level) {
    debug('Define prototype method for "%s"', level);
    if (level === 'log') {
      // eslint-disable-next-line no-console
      console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
      return;
    }

    //
    // Define prototype methods for each log level e.g.:
    // logger.log('info', msg) implies these methods are defined:
    // - logger.info(msg)
    // - logger.isInfoEnabled()
    //
    // Remark: to support logger.child this **MUST** be a function
    // so it'll always be called on the instance instead of a fixed
    // place in the prototype chain.
    //
    DerivedLogger.prototype[level] = function (...args) {
      // Prefer any instance scope, but default to "root" logger
      const self = this || logger;

      // Optimize the hot-path which is the single object.
      if (args.length === 1) {
        const [msg] = args;
        const info = msg && msg.message && msg || { message: msg };
        info.level = info[LEVEL] = level;
        self._addDefaultMeta(info);
        self.write(info);
        return (this || logger);
      }

      // When provided nothing assume the empty string
      if (args.length === 0) {
        self.log(level, '');
        return self;
      }

      // Otherwise build argument list which could potentially conform to
      // either:
      // . v3 API: log(obj)
      // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])
      return self.log(level, ...args);
    };

    DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function () {
      return (this || logger).isLevelEnabled(level);
    };
  });

  return logger;
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/exception-handler.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/exception-handler.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __webpack_require__(/*! os */ "os");
const asyncForEach = __webpack_require__(/*! async/forEach */ "../../node_modules/winston/node_modules/async/forEach.js");
const debug = __webpack_require__(/*! @dabh/diagnostics */ "../../node_modules/@dabh/diagnostics/node/index.js")('winston:exception');
const once = __webpack_require__(/*! one-time */ "../../node_modules/one-time/index.js");
const stackTrace = __webpack_require__(/*! stack-trace */ "../../node_modules/stack-trace/lib/stack-trace.js");
const ExceptionStream = __webpack_require__(/*! ./exception-stream */ "../../node_modules/winston/lib/winston/exception-stream.js");

/**
 * Object for handling uncaughtException events.
 * @type {ExceptionHandler}
 */
module.exports = class ExceptionHandler {
  /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */
  constructor(logger) {
    if (!logger) {
      throw new Error('Logger is required to handle exceptions');
    }

    this.logger = logger;
    this.handlers = new Map();
  }

  /**
   * Handles `uncaughtException` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */
  handle(...args) {
    args.forEach(arg => {
      if (Array.isArray(arg)) {
        return arg.forEach(handler => this._addHandler(handler));
      }

      this._addHandler(arg);
    });

    if (!this.catcher) {
      this.catcher = this._uncaughtException.bind(this);
      process.on('uncaughtException', this.catcher);
    }
  }

  /**
   * Removes any handlers to `uncaughtException` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */
  unhandle() {
    if (this.catcher) {
      process.removeListener('uncaughtException', this.catcher);
      this.catcher = false;

      Array.from(this.handlers.values())
        .forEach(wrapper => this.logger.unpipe(wrapper));
    }
  }

  /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */
  getAllInfo(err) {
    let message = null;
    if (err) {
      message = typeof err === 'string' ? err : err.message;
    }

    return {
      error: err,
      // TODO (indexzero): how do we configure this?
      level: 'error',
      message: [
        `uncaughtException: ${(message || '(no error message)')}`,
        err && err.stack || '  No stack trace'
      ].join('\n'),
      stack: err && err.stack,
      exception: true,
      date: new Date().toString(),
      process: this.getProcessInfo(),
      os: this.getOsInfo(),
      trace: this.getTrace(err)
    };
  }

  /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getProcessInfo() {
    return {
      pid: process.pid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      cwd: process.cwd(),
      execPath: process.execPath,
      version: process.version,
      argv: process.argv,
      memoryUsage: process.memoryUsage()
    };
  }

  /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getOsInfo() {
    return {
      loadavg: os.loadavg(),
      uptime: os.uptime()
    };
  }

  /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  getTrace(err) {
    const trace = err ? stackTrace.parse(err) : stackTrace.get();
    return trace.map(site => {
      return {
        column: site.getColumnNumber(),
        file: site.getFileName(),
        function: site.getFunctionName(),
        line: site.getLineNumber(),
        method: site.getMethodName(),
        native: site.isNative()
      };
    });
  }

  /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */
  _addHandler(handler) {
    if (!this.handlers.has(handler)) {
      handler.handleExceptions = true;
      const wrapper = new ExceptionStream(handler);
      this.handlers.set(handler, wrapper);
      this.logger.pipe(wrapper);
    }
  }

  /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _uncaughtException(err) {
    const info = this.getAllInfo(err);
    const handlers = this._getExceptionHandlers();
    // Calculate if we should exit on this error
    let doExit = typeof this.logger.exitOnError === 'function'
      ? this.logger.exitOnError(err)
      : this.logger.exitOnError;
    let timeout;

    if (!handlers.length && doExit) {
      // eslint-disable-next-line no-console
      console.warn('winston: exitOnError cannot be true with no exception handlers.');
      // eslint-disable-next-line no-console
      console.warn('winston: not exiting process.');
      doExit = false;
    }

    function gracefulExit() {
      debug('doExit', doExit);
      debug('process._exiting', process._exiting);

      if (doExit && !process._exiting) {
        // Remark: Currently ignoring any exceptions from transports when
        // catching uncaught exceptions.
        if (timeout) {
          clearTimeout(timeout);
        }
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
    }

    if (!handlers || handlers.length === 0) {
      return process.nextTick(gracefulExit);
    }

    // Log to all transports attempting to listen for when they are completed.
    asyncForEach(handlers, (handler, next) => {
      const done = once(next);
      const transport = handler.transport || handler;

      // Debug wrapping so that we can inspect what's going on under the covers.
      function onDone(event) {
        return () => {
          debug(event);
          done();
        };
      }

      transport._ending = true;
      transport.once('finish', onDone('finished'));
      transport.once('error', onDone('error'));
    }, () => doExit && gracefulExit());

    this.logger.log(info);

    // If exitOnError is true, then only allow the logging of exceptions to
    // take up to `3000ms`.
    if (doExit) {
      timeout = setTimeout(gracefulExit, 3000);
    }
  }

  /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */
  _getExceptionHandlers() {
    // Remark (indexzero): since `logger.transports` returns all of the pipes
    // from the _readableState of the stream we actually get the join of the
    // explicit handlers and the implicit transports with
    // `handleExceptions: true`
    return this.logger.transports.filter(wrap => {
      const transport = wrap.transport || wrap;
      return transport.handleExceptions;
    });
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/exception-stream.js":
/*!******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/exception-stream.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Writable } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");

/**
 * TODO: add class description.
 * @type {ExceptionStream}
 * @extends {Writable}
 */
module.exports = class ExceptionStream extends Writable {
  /**
   * Constructor function for the ExceptionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.exception` set to true.
   * @param {!TransportStream} transport - Stream to filter to exceptions
   */
  constructor(transport) {
    super({ objectMode: true });

    if (!transport) {
      throw new Error('ExceptionStream requires a TransportStream instance.');
    }

    // Remark (indexzero): we set `handleExceptions` here because it's the
    // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers
    this.handleExceptions = true;
    this.transport = transport;
  }

  /**
   * Writes the info object to our transport instance if (and only if) the
   * `exception` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _write(info, enc, callback) {
    if (info.exception) {
      return this.transport.log(info, callback);
    }

    callback();
    return true;
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/logger.js":
/*!********************************************************!*\
  !*** ../../node_modules/winston/lib/winston/logger.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * logger.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Stream, Transform } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");
const asyncForEach = __webpack_require__(/*! async/forEach */ "../../node_modules/winston/node_modules/async/forEach.js");
const { LEVEL, SPLAT } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const isStream = __webpack_require__(/*! is-stream */ "../../node_modules/winston/node_modules/is-stream/index.js");
const ExceptionHandler = __webpack_require__(/*! ./exception-handler */ "../../node_modules/winston/lib/winston/exception-handler.js");
const RejectionHandler = __webpack_require__(/*! ./rejection-handler */ "../../node_modules/winston/lib/winston/rejection-handler.js");
const LegacyTransportStream = __webpack_require__(/*! winston-transport/legacy */ "../../node_modules/winston-transport/legacy.js");
const Profiler = __webpack_require__(/*! ./profiler */ "../../node_modules/winston/lib/winston/profiler.js");
const { warn } = __webpack_require__(/*! ./common */ "../../node_modules/winston/lib/winston/common.js");
const config = __webpack_require__(/*! ./config */ "../../node_modules/winston/lib/winston/config/index.js");

/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */
const formatRegExp = /%[scdjifoO%]/g;

/**
 * TODO: add class description.
 * @type {Logger}
 * @extends {Transform}
 */
class Logger extends Transform {
  /**
   * Constructor function for the Logger object responsible for persisting log
   * messages and metadata to one or more transports.
   * @param {!Object} options - foo
   */
  constructor(options) {
    super({ objectMode: true });
    this.configure(options);
  }

  child(defaultRequestMetadata) {
    const logger = this;
    return Object.create(logger, {
      write: {
        value: function (info) {
          const infoClone = Object.assign(
            {},
            defaultRequestMetadata,
            info
          );

          // Object.assign doesn't copy inherited Error
          // properties so we have to do that explicitly
          //
          // Remark (indexzero): we should remove this
          // since the errors format will handle this case.
          //
          if (info instanceof Error) {
            infoClone.stack = info.stack;
            infoClone.message = info.message;
          }

          logger.write(infoClone);
        }
      }
    });
  }

  /**
   * This will wholesale reconfigure this instance by:
   * 1. Resetting all transports. Older transports will be removed implicitly.
   * 2. Set all other options including levels, colors, rewriters, filters,
   *    exceptionHandlers, etc.
   * @param {!Object} options - TODO: add param description.
   * @returns {undefined}
   */
  configure({
    silent,
    format,
    defaultMeta,
    levels,
    level = 'info',
    exitOnError = true,
    transports,
    colors,
    emitErrs,
    formatters,
    padLevels,
    rewriters,
    stripColors,
    exceptionHandlers,
    rejectionHandlers
  } = {}) {
    // Reset transports if we already have them
    if (this.transports.length) {
      this.clear();
    }

    this.silent = silent;
    this.format = format || this.format || __webpack_require__(/*! logform/json */ "../../node_modules/logform/json.js")();

    this.defaultMeta = defaultMeta || null;
    // Hoist other options onto this instance.
    this.levels = levels || this.levels || config.npm.levels;
    this.level = level;
    if (this.exceptions) {
      this.exceptions.unhandle();
    }
    if (this.rejections) {
      this.rejections.unhandle();
    }
    this.exceptions = new ExceptionHandler(this);
    this.rejections = new RejectionHandler(this);
    this.profilers = {};
    this.exitOnError = exitOnError;

    // Add all transports we have been provided.
    if (transports) {
      transports = Array.isArray(transports) ? transports : [transports];
      transports.forEach(transport => this.add(transport));
    }

    if (
      colors ||
      emitErrs ||
      formatters ||
      padLevels ||
      rewriters ||
      stripColors
    ) {
      throw new Error(
        [
          '{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.',
          'Use a custom winston.format(function) instead.',
          'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'
        ].join('\n')
      );
    }

    if (exceptionHandlers) {
      this.exceptions.handle(exceptionHandlers);
    }
    if (rejectionHandlers) {
      this.rejections.handle(rejectionHandlers);
    }
  }

  isLevelEnabled(level) {
    const givenLevelValue = getLevelValue(this.levels, level);
    if (givenLevelValue === null) {
      return false;
    }

    const configuredLevelValue = getLevelValue(this.levels, this.level);
    if (configuredLevelValue === null) {
      return false;
    }

    if (!this.transports || this.transports.length === 0) {
      return configuredLevelValue >= givenLevelValue;
    }

    const index = this.transports.findIndex(transport => {
      let transportLevelValue = getLevelValue(this.levels, transport.level);
      if (transportLevelValue === null) {
        transportLevelValue = configuredLevelValue;
      }
      return transportLevelValue >= givenLevelValue;
    });
    return index !== -1;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * Ensure backwards compatibility with a `log` method
   * @param {mixed} level - Level the log message is written at.
   * @param {mixed} msg - TODO: add param description.
   * @param {mixed} meta - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   *
   * @example
   *    // Supports the existing API:
   *    logger.log('info', 'Hello world', { custom: true });
   *    logger.log('info', new Error('Yo, it\'s on fire'));
   *
   *    // Requires winston.format.splat()
   *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
   *
   *    // And the new API with a single JSON literal:
   *    logger.log({ level: 'info', message: 'Hello world', custom: true });
   *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
   *
   *    // Also requires winston.format.splat()
   *    logger.log({
   *      level: 'info',
   *      message: '%s %d%%',
   *      [SPLAT]: ['A string', 50],
   *      meta: { thisIsMeta: true }
   *    });
   *
   */
  /* eslint-enable valid-jsdoc */
  log(level, msg, ...splat) {
    // eslint-disable-line max-params
    // Optimize for the hotpath of logging JSON literals
    if (arguments.length === 1) {
      // Yo dawg, I heard you like levels ... seriously ...
      // In this context the LHS `level` here is actually the `info` so read
      // this as: info[LEVEL] = info.level;
      level[LEVEL] = level.level;
      this._addDefaultMeta(level);
      this.write(level);
      return this;
    }

    // Slightly less hotpath, but worth optimizing for.
    if (arguments.length === 2) {
      if (msg && typeof msg === 'object') {
        msg[LEVEL] = msg.level = level;
        this._addDefaultMeta(msg);
        this.write(msg);
        return this;
      }

      msg = { [LEVEL]: level, level, message: msg };
      this._addDefaultMeta(msg);
      this.write(msg);
      return this;
    }

    const [meta] = splat;
    if (typeof meta === 'object' && meta !== null) {
      // Extract tokens, if none available default to empty array to
      // ensure consistancy in expected results
      const tokens = msg && msg.match && msg.match(formatRegExp);

      if (!tokens) {
        const info = Object.assign({}, this.defaultMeta, meta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        });

        if (meta.message) info.message = `${info.message} ${meta.message}`;
        if (meta.stack) info.stack = meta.stack;

        this.write(info);
        return this;
      }
    }

    this.write(Object.assign({}, this.defaultMeta, {
      [LEVEL]: level,
      [SPLAT]: splat,
      level,
      message: msg
    }));

    return this;
  }

  /**
   * Pushes data so that it can be picked up by all of our pipe targets.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - Continues stream processing.
   * @returns {undefined}
   * @private
   */
  _transform(info, enc, callback) {
    if (this.silent) {
      return callback();
    }

    // [LEVEL] is only soft guaranteed to be set here since we are a proper
    // stream. It is likely that `info` came in through `.log(info)` or
    // `.info(info)`. If it is not defined, however, define it.
    // This LEVEL symbol is provided by `triple-beam` and also used in:
    // - logform
    // - winston-transport
    // - abstract-winston-transport
    if (!info[LEVEL]) {
      info[LEVEL] = info.level;
    }

    // Remark: really not sure what to do here, but this has been reported as
    // very confusing by pre winston@2.0.0 users as quite confusing when using
    // custom levels.
    if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
      // eslint-disable-next-line no-console
      console.error('[winston] Unknown logger level: %s', info[LEVEL]);
    }

    // Remark: not sure if we should simply error here.
    if (!this._readableState.pipes) {
      // eslint-disable-next-line no-console
      console.error(
        '[winston] Attempt to write logs with no transports, which can increase memory usage: %j',
        info
      );
    }

    // Here we write to the `format` pipe-chain, which on `readable` above will
    // push the formatted `info` Object onto the buffer for this instance. We trap
    // (and re-throw) any errors generated by the user-provided format, but also
    // guarantee that the streams callback is invoked so that we can continue flowing.
    try {
      this.push(this.format.transform(info, this.format.options));
    } finally {
      this._writableState.sync = false;
      // eslint-disable-next-line callback-return
      callback();
    }
  }

  /**
   * Delays the 'finish' event until all transport pipe targets have
   * also emitted 'finish' or are already finished.
   * @param {mixed} callback - Continues stream processing.
   */
  _final(callback) {
    const transports = this.transports.slice();
    asyncForEach(
      transports,
      (transport, next) => {
        if (!transport || transport.finished) return setImmediate(next);
        transport.once('finish', next);
        transport.end();
      },
      callback
    );
  }

  /**
   * Adds the transport to this logger instance by piping to it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */
  add(transport) {
    // Support backwards compatibility with all existing `winston < 3.x.x`
    // transports which meet one of two criteria:
    // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.
    // 2. They expose a log method which has a length greater than 2 (i.e. more then
    //    just `log(info, callback)`.
    const target =
      !isStream(transport) || transport.log.length > 2
        ? new LegacyTransportStream({ transport })
        : transport;

    if (!target._writableState || !target._writableState.objectMode) {
      throw new Error(
        'Transports must WritableStreams in objectMode. Set { objectMode: true }.'
      );
    }

    // Listen for the `error` event and the `warn` event on the new Transport.
    this._onEvent('error', target);
    this._onEvent('warn', target);
    this.pipe(target);

    if (transport.handleExceptions) {
      this.exceptions.handle();
    }

    if (transport.handleRejections) {
      this.rejections.handle();
    }

    return this;
  }

  /**
   * Removes the transport from this logger instance by unpiping from it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */
  remove(transport) {
    if (!transport) return this;
    let target = transport;
    if (!isStream(transport) || transport.log.length > 2) {
      target = this.transports.filter(
        match => match.transport === transport
      )[0];
    }

    if (target) {
      this.unpipe(target);
    }
    return this;
  }

  /**
   * Removes all transports from this logger instance.
   * @returns {Logger} - TODO: add return description.
   */
  clear() {
    this.unpipe();
    return this;
  }

  /**
   * Cleans up resources (streams, event listeners) for all transports
   * associated with this instance (if necessary).
   * @returns {Logger} - TODO: add return description.
   */
  close() {
    this.exceptions.unhandle();
    this.rejections.unhandle();
    this.clear();
    this.emit('close');
    return this;
  }

  /**
   * Sets the `target` levels specified on this instance.
   * @param {Object} Target levels to use on this instance.
   */
  setLevels() {
    warn.deprecated('setLevels');
  }

  /**
   * Queries the all transports for this instance with the specified `options`.
   * This will aggregate each transport's results into one object containing
   * a property per transport.
   * @param {Object} options - Query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = options || {};
    const results = {};
    const queryObject = Object.assign({}, options.query || {});

    // Helper function to query a single transport
    function queryTransport(transport, next) {
      if (options.query && typeof transport.formatQuery === 'function') {
        options.query = transport.formatQuery(queryObject);
      }

      transport.query(options, (err, res) => {
        if (err) {
          return next(err);
        }

        if (typeof transport.formatResults === 'function') {
          res = transport.formatResults(res, options.format);
        }

        next(null, res);
      });
    }

    // Helper function to accumulate the results from `queryTransport` into
    // the `results`.
    function addResults(transport, next) {
      queryTransport(transport, (err, result) => {
        // queryTransport could potentially invoke the callback multiple times
        // since Transport code can be unpredictable.
        if (next) {
          result = err || result;
          if (result) {
            results[transport.name] = result;
          }

          // eslint-disable-next-line callback-return
          next();
        }

        next = null;
      });
    }

    // Iterate over the transports in parallel setting the appropriate key in
    // the `results`.
    asyncForEach(
      this.transports.filter(transport => !!transport.query),
      addResults,
      () => callback(null, results)
    );
  }

  /**
   * Returns a log stream for all transports. Options object is optional.
   * @param{Object} options={} - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   */
  stream(options = {}) {
    const out = new Stream();
    const streams = [];

    out._streams = streams;
    out.destroy = () => {
      let i = streams.length;
      while (i--) {
        streams[i].destroy();
      }
    };

    // Create a list of all transports for this instance.
    this.transports
      .filter(transport => !!transport.stream)
      .forEach(transport => {
        const str = transport.stream(options);
        if (!str) {
          return;
        }

        streams.push(str);

        str.on('log', log => {
          log.transport = log.transport || [];
          log.transport.push(transport.name);
          out.emit('log', log);
        });

        str.on('error', err => {
          err.transport = err.transport || [];
          err.transport.push(transport.name);
          out.emit('error', err);
        });
      });

    return out;
  }

  /**
   * Returns an object corresponding to a specific timing. When done is called
   * the timer will finish and log the duration. e.g.:
   * @returns {Profile} - TODO: add return description.
   * @example
   *    const timer = winston.startTimer()
   *    setTimeout(() => {
   *      timer.done({
   *        message: 'Logging message'
   *      });
   *    }, 1000);
   */
  startTimer() {
    return new Profiler(this);
  }

  /**
   * Tracks the time inbetween subsequent calls to this method with the same
   * `id` parameter. The second call to this method will log the difference in
   * milliseconds along with the message.
   * @param {string} id Unique id of the profiler
   * @returns {Logger} - TODO: add return description.
   */
  profile(id, ...args) {
    const time = Date.now();
    if (this.profilers[id]) {
      const timeEnd = this.profilers[id];
      delete this.profilers[id];

      // Attempt to be kind to users if they are still using older APIs.
      if (typeof args[args.length - 2] === 'function') {
        // eslint-disable-next-line no-console
        console.warn(
          'Callback function no longer supported as of winston@3.0.0'
        );
        args.pop();
      }

      // Set the duration property of the metadata
      const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};
      info.level = info.level || 'info';
      info.durationMs = time - timeEnd;
      info.message = info.message || id;
      return this.write(info);
    }

    this.profilers[id] = time;
    return this;
  }

  /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */
  handleExceptions(...args) {
    // eslint-disable-next-line no-console
    console.warn(
      'Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()'
    );
    this.exceptions.handle(...args);
  }

  /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */
  unhandleExceptions(...args) {
    // eslint-disable-next-line no-console
    console.warn(
      'Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()'
    );
    this.exceptions.unhandle(...args);
  }

  /**
   * Throw a more meaningful deprecation notice
   * @throws {Error} - TODO: add throws description.
   */
  cli() {
    throw new Error(
      [
        'Logger.cli() was removed in winston@3.0.0',
        'Use a custom winston.formats.cli() instead.',
        'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'
      ].join('\n')
    );
  }

  /**
   * Bubbles the `event` that occured on the specified `transport` up
   * from this instance.
   * @param {string} event - The event that occured
   * @param {Object} transport - Transport on which the event occured
   * @private
   */
  _onEvent(event, transport) {
    function transportEvent(err) {
      // https://github.com/winstonjs/winston/issues/1364
      if (event === 'error' && !this.transports.includes(transport)) {
        this.add(transport);
      }
      this.emit(event, err, transport);
    }

    if (!transport['__winston' + event]) {
      transport['__winston' + event] = transportEvent.bind(this);
      transport.on(event, transport['__winston' + event]);
    }
  }

  _addDefaultMeta(msg) {
    if (this.defaultMeta) {
      Object.assign(msg, this.defaultMeta);
    }
  }
}

function getLevelValue(levels, level) {
  const value = levels[level];
  if (!value && value !== 0) {
    return null;
  }
  return value;
}

/**
 * Represents the current readableState pipe targets for this Logger instance.
 * @type {Array|Object}
 */
Object.defineProperty(Logger.prototype, 'transports', {
  configurable: false,
  enumerable: true,
  get() {
    const { pipes } = this._readableState;
    return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
  }
});

module.exports = Logger;


/***/ }),

/***/ "../../node_modules/winston/lib/winston/profiler.js":
/*!**********************************************************!*\
  !*** ../../node_modules/winston/lib/winston/profiler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * profiler.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */


/**
 * TODO: add class description.
 * @type {Profiler}
 * @private
 */
class Profiler {
  /**
   * Constructor function for the Profiler instance used by
   * `Logger.prototype.startTimer`. When done is called the timer will finish
   * and log the duration.
   * @param {!Logger} logger - TODO: add param description.
   * @private
   */
  constructor(logger) {
    const Logger = __webpack_require__(/*! ./logger */ "../../node_modules/winston/lib/winston/logger.js");
    if (typeof logger !== 'object' || Array.isArray(logger) || !(logger instanceof Logger)) {
      throw new Error('Logger is required for profiling');
    } else {
      this.logger = logger;
      this.start = Date.now();
    }
  }

  /**
   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
   * with the duration since creation.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  done(...args) {
    if (typeof args[args.length - 1] === 'function') {
      // eslint-disable-next-line no-console
      console.warn('Callback function no longer supported as of winston@3.0.0');
      args.pop();
    }

    const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};
    info.level = info.level || 'info';
    info.durationMs = (Date.now()) - this.start;

    return this.logger.write(info);
  }
};

module.exports = Profiler;


/***/ }),

/***/ "../../node_modules/winston/lib/winston/rejection-handler.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/rejection-handler.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __webpack_require__(/*! os */ "os");
const asyncForEach = __webpack_require__(/*! async/forEach */ "../../node_modules/winston/node_modules/async/forEach.js");
const debug = __webpack_require__(/*! @dabh/diagnostics */ "../../node_modules/@dabh/diagnostics/node/index.js")('winston:rejection');
const once = __webpack_require__(/*! one-time */ "../../node_modules/one-time/index.js");
const stackTrace = __webpack_require__(/*! stack-trace */ "../../node_modules/stack-trace/lib/stack-trace.js");
const RejectionStream = __webpack_require__(/*! ./rejection-stream */ "../../node_modules/winston/lib/winston/rejection-stream.js");

/**
 * Object for handling unhandledRejection events.
 * @type {RejectionHandler}
 */
module.exports = class RejectionHandler {
  /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */
  constructor(logger) {
    if (!logger) {
      throw new Error('Logger is required to handle rejections');
    }

    this.logger = logger;
    this.handlers = new Map();
  }

  /**
   * Handles `unhandledRejection` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */
  handle(...args) {
    args.forEach(arg => {
      if (Array.isArray(arg)) {
        return arg.forEach(handler => this._addHandler(handler));
      }

      this._addHandler(arg);
    });

    if (!this.catcher) {
      this.catcher = this._unhandledRejection.bind(this);
      process.on('unhandledRejection', this.catcher);
    }
  }

  /**
   * Removes any handlers to `unhandledRejection` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */
  unhandle() {
    if (this.catcher) {
      process.removeListener('unhandledRejection', this.catcher);
      this.catcher = false;

      Array.from(this.handlers.values()).forEach(wrapper =>
        this.logger.unpipe(wrapper)
      );
    }
  }

  /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */
  getAllInfo(err) {
    let message = null;
    if (err) {
      message = typeof err === 'string' ? err : err.message;
    }

    return {
      error: err,
      // TODO (indexzero): how do we configure this?
      level: 'error',
      message: [
        `unhandledRejection: ${message || '(no error message)'}`,
        err && err.stack || '  No stack trace'
      ].join('\n'),
      stack: err && err.stack,
      rejection: true,
      date: new Date().toString(),
      process: this.getProcessInfo(),
      os: this.getOsInfo(),
      trace: this.getTrace(err)
    };
  }

  /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getProcessInfo() {
    return {
      pid: process.pid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      cwd: process.cwd(),
      execPath: process.execPath,
      version: process.version,
      argv: process.argv,
      memoryUsage: process.memoryUsage()
    };
  }

  /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */
  getOsInfo() {
    return {
      loadavg: os.loadavg(),
      uptime: os.uptime()
    };
  }

  /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  getTrace(err) {
    const trace = err ? stackTrace.parse(err) : stackTrace.get();
    return trace.map(site => {
      return {
        column: site.getColumnNumber(),
        file: site.getFileName(),
        function: site.getFunctionName(),
        line: site.getLineNumber(),
        method: site.getMethodName(),
        native: site.isNative()
      };
    });
  }

  /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */
  _addHandler(handler) {
    if (!this.handlers.has(handler)) {
      handler.handleRejections = true;
      const wrapper = new RejectionStream(handler);
      this.handlers.set(handler, wrapper);
      this.logger.pipe(wrapper);
    }
  }

  /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _unhandledRejection(err) {
    const info = this.getAllInfo(err);
    const handlers = this._getRejectionHandlers();
    // Calculate if we should exit on this error
    let doExit =
      typeof this.logger.exitOnError === 'function'
        ? this.logger.exitOnError(err)
        : this.logger.exitOnError;
    let timeout;

    if (!handlers.length && doExit) {
      // eslint-disable-next-line no-console
      console.warn('winston: exitOnError cannot be true with no rejection handlers.');
      // eslint-disable-next-line no-console
      console.warn('winston: not exiting process.');
      doExit = false;
    }

    function gracefulExit() {
      debug('doExit', doExit);
      debug('process._exiting', process._exiting);

      if (doExit && !process._exiting) {
        // Remark: Currently ignoring any rejections from transports when
        // catching unhandled rejections.
        if (timeout) {
          clearTimeout(timeout);
        }
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
    }

    if (!handlers || handlers.length === 0) {
      return process.nextTick(gracefulExit);
    }

    // Log to all transports attempting to listen for when they are completed.
    asyncForEach(
      handlers,
      (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;

        // Debug wrapping so that we can inspect what's going on under the covers.
        function onDone(event) {
          return () => {
            debug(event);
            done();
          };
        }

        transport._ending = true;
        transport.once('finish', onDone('finished'));
        transport.once('error', onDone('error'));
      },
      () => doExit && gracefulExit()
    );

    this.logger.log(info);

    // If exitOnError is true, then only allow the logging of exceptions to
    // take up to `3000ms`.
    if (doExit) {
      timeout = setTimeout(gracefulExit, 3000);
    }
  }

  /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */
  _getRejectionHandlers() {
    // Remark (indexzero): since `logger.transports` returns all of the pipes
    // from the _readableState of the stream we actually get the join of the
    // explicit handlers and the implicit transports with
    // `handleRejections: true`
    return this.logger.transports.filter(wrap => {
      const transport = wrap.transport || wrap;
      return transport.handleRejections;
    });
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/rejection-stream.js":
/*!******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/rejection-stream.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * rejection-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const { Writable } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");

/**
 * TODO: add class description.
 * @type {RejectionStream}
 * @extends {Writable}
 */
module.exports = class RejectionStream extends Writable {
  /**
   * Constructor function for the RejectionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.rejection` set to true.
   * @param {!TransportStream} transport - Stream to filter to rejections
   */
  constructor(transport) {
    super({ objectMode: true });

    if (!transport) {
      throw new Error('RejectionStream requires a TransportStream instance.');
    }

    this.handleRejections = true;
    this.transport = transport;
  }

  /**
   * Writes the info object to our transport instance if (and only if) the
   * `rejection` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */
  _write(info, enc, callback) {
    if (info.rejection) {
      return this.transport.log(info, callback);
    }

    callback();
    return true;
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/tail-file.js":
/*!***********************************************************!*\
  !*** ../../node_modules/winston/lib/winston/tail-file.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * tail-file.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const fs = __webpack_require__(/*! fs */ "fs");
const { StringDecoder } = __webpack_require__(/*! string_decoder */ "string_decoder");
const { Stream } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");

/**
 * Simple no-op function.
 * @returns {undefined}
 */
function noop() {}

/**
 * TODO: add function description.
 * @param {Object} options - Options for tail.
 * @param {function} iter - Iterator function to execute on every line.
* `tail -f` a file. Options must include file.
 * @returns {mixed} - TODO: add return description.
 */
module.exports = (options, iter) => {
  const buffer = Buffer.alloc(64 * 1024);
  const decode = new StringDecoder('utf8');
  const stream = new Stream();
  let buff = '';
  let pos = 0;
  let row = 0;

  if (options.start === -1) {
    delete options.start;
  }

  stream.readable = true;
  stream.destroy = () => {
    stream.destroyed = true;
    stream.emit('end');
    stream.emit('close');
  };

  fs.open(options.file, 'a+', '0644', (err, fd) => {
    if (err) {
      if (!iter) {
        stream.emit('error', err);
      } else {
        iter(err);
      }
      stream.destroy();
      return;
    }

    (function read() {
      if (stream.destroyed) {
        fs.close(fd, noop);
        return;
      }

      return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
        if (error) {
          if (!iter) {
            stream.emit('error', error);
          } else {
            iter(error);
          }
          stream.destroy();
          return;
        }

        if (!bytes) {
          if (buff) {
            // eslint-disable-next-line eqeqeq
            if (options.start == null || row > options.start) {
              if (!iter) {
                stream.emit('line', buff);
              } else {
                iter(null, buff);
              }
            }
            row++;
            buff = '';
          }
          return setTimeout(read, 1000);
        }

        let data = decode.write(buffer.slice(0, bytes));
        if (!iter) {
          stream.emit('data', data);
        }

        data = (buff + data).split(/\n+/);

        const l = data.length - 1;
        let i = 0;

        for (; i < l; i++) {
          // eslint-disable-next-line eqeqeq
          if (options.start == null || row > options.start) {
            if (!iter) {
              stream.emit('line', data[i]);
            } else {
              iter(null, data[i]);
            }
          }
          row++;
        }

        buff = data[l];
        pos += bytes;
        return read();
      });
    }());
  });

  if (!iter) {
    return stream;
  }

  return stream.destroy;
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/transports/console.js":
/*!********************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/transports/console.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable no-console */
/*
 * console.js: Transport for outputting to the console.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const os = __webpack_require__(/*! os */ "os");
const { LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const TransportStream = __webpack_require__(/*! winston-transport */ "../../node_modules/winston-transport/index.js");

/**
 * Transport for outputting to the console.
 * @type {Console}
 * @extends {TransportStream}
 */
module.exports = class Console extends TransportStream {
  /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    // Expose the name of this Transport on the prototype
    this.name = options.name || 'console';
    this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
    this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
    this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;
    this.forceConsole = options.forceConsole || false;

    // Keep a reference to the log, warn, and error console methods
    // in case they get redirected to this transport after the logger is
    // instantiated. This prevents a circular reference issue.
    this._consoleLog = console.log.bind(console);
    this._consoleWarn = console.warn.bind(console);
    this._consoleError = console.error.bind(console);

    this.setMaxListeners(30);
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    setImmediate(() => this.emit('logged', info));

    // Remark: what if there is no raw...?
    if (this.stderrLevels[info[LEVEL]]) {
      if (console._stderr && !this.forceConsole) {
        // Node.js maps `process.stderr` to `console._stderr`.
        console._stderr.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        // console.error adds a newline
        this._consoleError(info[MESSAGE]);
      }

      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    } else if (this.consoleWarnLevels[info[LEVEL]]) {
      if (console._stderr && !this.forceConsole) {
        // Node.js maps `process.stderr` to `console._stderr`.
        // in Node.js console.warn is an alias for console.error
        console._stderr.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        // console.warn adds a newline
        this._consoleWarn(info[MESSAGE]);
      }

      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    }

    if (console._stdout && !this.forceConsole) {
      // Node.js maps `process.stdout` to `console._stdout`.
      console._stdout.write(`${info[MESSAGE]}${this.eol}`);
    } else {
      // console.log adds a newline.
      this._consoleLog(info[MESSAGE]);
    }

    if (callback) {
      callback(); // eslint-disable-line callback-return
    }
  }

  /**
   * Returns a Set-like object with strArray's elements as keys (each with the
   * value true).
   * @param {Array} strArray - Array of Set-elements as strings.
   * @param {?string} [errMsg] - Custom error message thrown on invalid input.
   * @returns {Object} - TODO: add return description.
   * @private
   */
  _stringArrayToSet(strArray, errMsg) {
    if (!strArray) return {};

    errMsg =
      errMsg || 'Cannot make set from type other than Array of string elements';

    if (!Array.isArray(strArray)) {
      throw new Error(errMsg);
    }

    return strArray.reduce((set, el) => {
      if (typeof el !== 'string') {
        throw new Error(errMsg);
      }
      set[el] = true;

      return set;
    }, {});
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/transports/file.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/transports/file.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable complexity,max-statements */
/**
 * file.js: Transport for outputting to a local log file.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const asyncSeries = __webpack_require__(/*! async/series */ "../../node_modules/winston/node_modules/async/series.js");
const zlib = __webpack_require__(/*! zlib */ "zlib");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const { Stream, PassThrough } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");
const TransportStream = __webpack_require__(/*! winston-transport */ "../../node_modules/winston-transport/index.js");
const debug = __webpack_require__(/*! @dabh/diagnostics */ "../../node_modules/@dabh/diagnostics/node/index.js")('winston:file');
const os = __webpack_require__(/*! os */ "os");
const tailFile = __webpack_require__(/*! ../tail-file */ "../../node_modules/winston/lib/winston/tail-file.js");

/**
 * Transport for outputting to a local log file.
 * @type {File}
 * @extends {TransportStream}
 */
module.exports = class File extends TransportStream {
  /**
   * Constructor function for the File transport object responsible for
   * persisting log messages and metadata to one or more files.
   * @param {Object} options - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    // Expose the name of this Transport on the prototype.
    this.name = options.name || 'file';

    // Helper function which throws an `Error` in the event that any of the
    // rest of the arguments is present in `options`.
    function throwIf(target, ...args) {
      args.slice(1).forEach(name => {
        if (options[name]) {
          throw new Error(`Cannot set ${name} and ${target} together`);
        }
      });
    }

    // Setup the base stream that always gets piped to to handle buffering.
    this._stream = new PassThrough();
    this._stream.setMaxListeners(30);

    // Bind this context for listener methods.
    this._onError = this._onError.bind(this);

    if (options.filename || options.dirname) {
      throwIf('filename or dirname', 'stream');
      this._basename = this.filename = options.filename
        ? path.basename(options.filename)
        : 'winston.log';

      this.dirname = options.dirname || path.dirname(options.filename);
      this.options = options.options || { flags: 'a' };
    } else if (options.stream) {
      // eslint-disable-next-line no-console
      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');
      throwIf('stream', 'filename', 'maxsize');
      this._dest = this._stream.pipe(this._setupStream(options.stream));
      this.dirname = path.dirname(this._dest.path);
      // We need to listen for drain events when write() returns false. This
      // can make node mad at times.
    } else {
      throw new Error('Cannot log to file without filename or stream.');
    }

    this.maxsize = options.maxsize || null;
    this.rotationFormat = options.rotationFormat || false;
    this.zippedArchive = options.zippedArchive || false;
    this.maxFiles = options.maxFiles || null;
    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;
    this.tailable = options.tailable || false;
    this.lazy = options.lazy || false;

    // Internal state variables representing the number of files this instance
    // has created and the current size (in bytes) of the current logfile.
    this._size = 0;
    this._pendingSize = 0;
    this._created = 0;
    this._drain = false;
    this._opening = false;
    this._ending = false;
    this._fileExist = false;

    if (this.dirname) this._createLogDirIfNotExist(this.dirname);
    if (!this.lazy) this.open();
  }

  finishIfEnding() {
    if (this._ending) {
      if (this._opening) {
        this.once('open', () => {
          this._stream.once('finish', () => this.emit('finish'));
          setImmediate(() => this._stream.end());
        });
      } else {
        this._stream.once('finish', () => this.emit('finish'));
        setImmediate(() => this._stream.end());
      }
    }
  }

  /**
   * Core logging method exposed to Winston. Metadata is optional.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback = () => { }) {
    // Remark: (jcrugzz) What is necessary about this callback(null, true) now
    // when thinking about 3.x? Should silent be handled in the base
    // TransportStream _write method?
    if (this.silent) {
      callback();
      return true;
    }


    // Output stream buffer is full and has asked us to wait for the drain event
    if (this._drain) {
      this._stream.once('drain', () => {
        this._drain = false;
        this.log(info, callback);
      });
      return;
    }
    if (this._rotate) {
      this._stream.once('rotate', () => {
        this._rotate = false;
        this.log(info, callback);
      });
      return;
    }
    if (this.lazy) {
      if (!this._fileExist) {
        if (!this._opening) {
          this.open();
        }
        this.once('open', () => {
          this._fileExist = true;
          this.log(info, callback);
          return;
        });
        return;
      }
      if (this._needsNewFile(this._pendingSize)) {
        this._dest.once('close', () => {
          if (!this._opening) {
            this.open();
          }
          this.once('open', () => {
            this.log(info, callback);
            return;
          });
          return;
        });
        return;
      }
    }

    // Grab the raw string and append the expected EOL.
    const output = `${info[MESSAGE]}${this.eol}`;
    const bytes = Buffer.byteLength(output);

    // After we have written to the PassThrough check to see if we need
    // to rotate to the next file.
    //
    // Remark: This gets called too early and does not depict when data
    // has been actually flushed to disk.
    function logged() {
      this._size += bytes;
      this._pendingSize -= bytes;

      debug('logged %s %s', this._size, output);
      this.emit('logged', info);

      // Do not attempt to rotate files while rotating
      if (this._rotate) {
        return;
      }

      // Do not attempt to rotate files while opening
      if (this._opening) {
        return;
      }

      // Check to see if we need to end the stream and create a new one.
      if (!this._needsNewFile()) {
        return;
      }
      if (this.lazy) {
        this._endStream(() => {this.emit('fileclosed');});
        return;
      }

      // End the current stream, ensure it flushes and create a new one.
      // This could potentially be optimized to not run a stat call but its
      // the safest way since we are supporting `maxFiles`.
      this._rotate = true;
      this._endStream(() => this._rotateFile());
    }

    // Keep track of the pending bytes being written while files are opening
    // in order to properly rotate the PassThrough this._stream when the file
    // eventually does open.
    this._pendingSize += bytes;
    if (this._opening
      && !this.rotatedWhileOpening
      && this._needsNewFile(this._size + this._pendingSize)) {
      this.rotatedWhileOpening = true;
    }

    const written = this._stream.write(output, logged.bind(this));
    if (!written) {
      this._drain = true;
      this._stream.once('drain', () => {
        this._drain = false;
        callback();
      });
    } else {
      callback(); // eslint-disable-line callback-return
    }

    debug('written', written, this._drain);

    this.finishIfEnding();

    return written;
  }

  /**
   * Query the transport. Options object is optional.
   * @param {Object} options - Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * TODO: Refactor me.
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = normalizeQuery(options);
    const file = path.join(this.dirname, this.filename);
    let buff = '';
    let results = [];
    let row = 0;

    const stream = fs.createReadStream(file, {
      encoding: 'utf8'
    });

    stream.on('error', err => {
      if (stream.readable) {
        stream.destroy();
      }
      if (!callback) {
        return;
      }

      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);
    });

    stream.on('data', data => {
      data = (buff + data).split(/\n+/);
      const l = data.length - 1;
      let i = 0;

      for (; i < l; i++) {
        if (!options.start || row >= options.start) {
          add(data[i]);
        }
        row++;
      }

      buff = data[l];
    });

    stream.on('close', () => {
      if (buff) {
        add(buff, true);
      }
      if (options.order === 'desc') {
        results = results.reverse();
      }

      // eslint-disable-next-line callback-return
      if (callback) callback(null, results);
    });

    function add(buff, attempt) {
      try {
        const log = JSON.parse(buff);
        if (check(log)) {
          push(log);
        }
      } catch (e) {
        if (!attempt) {
          stream.emit('error', e);
        }
      }
    }

    function push(log) {
      if (
        options.rows &&
        results.length >= options.rows &&
        options.order !== 'desc'
      ) {
        if (stream.readable) {
          stream.destroy();
        }
        return;
      }

      if (options.fields) {
        log = options.fields.reduce((obj, key) => {
          obj[key] = log[key];
          return obj;
        }, {});
      }

      if (options.order === 'desc') {
        if (results.length >= options.rows) {
          results.shift();
        }
      }
      results.push(log);
    }

    function check(log) {
      if (!log) {
        return;
      }

      if (typeof log !== 'object') {
        return;
      }

      const time = new Date(log.timestamp);
      if (
        (options.from && time < options.from) ||
        (options.until && time > options.until) ||
        (options.level && options.level !== log.level)
      ) {
        return;
      }

      return true;
    }

    function normalizeQuery(options) {
      options = options || {};

      // limit
      options.rows = options.rows || options.limit || 10;

      // starting row offset
      options.start = options.start || 0;

      // now
      options.until = options.until || new Date();
      if (typeof options.until !== 'object') {
        options.until = new Date(options.until);
      }

      // now - 24
      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));
      if (typeof options.from !== 'object') {
        options.from = new Date(options.from);
      }

      // 'asc' or 'desc'
      options.order = options.order || 'desc';

      return options;
    }
  }

  /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   * TODO: Refactor me.
   */
  stream(options = {}) {
    const file = path.join(this.dirname, this.filename);
    const stream = new Stream();
    const tail = {
      file,
      start: options.start
    };

    stream.destroy = tailFile(tail, (err, line) => {
      if (err) {
        return stream.emit('error', err);
      }

      try {
        stream.emit('data', line);
        line = JSON.parse(line);
        stream.emit('log', line);
      } catch (e) {
        stream.emit('error', e);
      }
    });

    return stream;
  }

  /**
   * Checks to see the filesize of.
   * @returns {undefined}
   */
  open() {
    // If we do not have a filename then we were passed a stream and
    // don't need to keep track of size.
    if (!this.filename) return;
    if (this._opening) return;

    this._opening = true;

    // Stat the target file to get the size and create the stream.
    this.stat((err, size) => {
      if (err) {
        return this.emit('error', err);
      }
      debug('stat done: %s { size: %s }', this.filename, size);
      this._size = size;
      this._dest = this._createStream(this._stream);
      this._opening = false;
      this.once('open', () => {
        if (!this._stream.emit('rotate')) {
          this._rotate = false;
        }
      });
    });
  }

  /**
   * Stat the file and assess information in order to create the proper stream.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  stat(callback) {
    const target = this._getFile();
    const fullpath = path.join(this.dirname, target);

    fs.stat(fullpath, (err, stat) => {
      if (err && err.code === 'ENOENT') {
        debug('ENOENT ok', fullpath);
        // Update internally tracked filename with the new target name.
        this.filename = target;
        return callback(null, 0);
      }

      if (err) {
        debug(`err ${err.code} ${fullpath}`);
        return callback(err);
      }

      if (!stat || this._needsNewFile(stat.size)) {
        // If `stats.size` is greater than the `maxsize` for this
        // instance then try again.
        return this._incFile(() => this.stat(callback));
      }

      // Once we have figured out what the filename is, set it
      // and return the size.
      this.filename = target;
      callback(null, stat.size);
    });
  }

  /**
   * Closes the stream associated with this instance.
   * @param {function} cb - TODO: add param description.
   * @returns {undefined}
   */
  close(cb) {
    if (!this._stream) {
      return;
    }

    this._stream.end(() => {
      if (cb) {
        cb(); // eslint-disable-line callback-return
      }
      this.emit('flush');
      this.emit('closed');
    });
  }

  /**
   * TODO: add method description.
   * @param {number} size - TODO: add param description.
   * @returns {undefined}
   */
  _needsNewFile(size) {
    size = size || this._size;
    return this.maxsize && size >= this.maxsize;
  }

  /**
   * TODO: add method description.
   * @param {Error} err - TODO: add param description.
   * @returns {undefined}
   */
  _onError(err) {
    this.emit('error', err);
  }

  /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  _setupStream(stream) {
    stream.on('error', this._onError);

    return stream;
  }

  /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */
  _cleanupStream(stream) {
    stream.removeListener('error', this._onError);
    stream.destroy();
    return stream;
  }

  /**
   * TODO: add method description.
   */
  _rotateFile() {
    this._incFile(() => this.open());
  }

  /**
   * Unpipe from the stream that has been marked as full and end it so it
   * flushes to disk.
   *
   * @param {function} callback - Callback for when the current file has closed.
   * @private
   */
  _endStream(callback = () => { }) {
    if (this._dest) {
      this._stream.unpipe(this._dest);
      this._dest.end(() => {
        this._cleanupStream(this._dest);
        callback();
      });
    } else {
      callback(); // eslint-disable-line callback-return
    }
  }

  /**
   * Returns the WritableStream for the active file on this instance. If we
   * should gzip the file then a zlib stream is returned.
   *
   * @param {ReadableStream} source –PassThrough to pipe to the file when open.
   * @returns {WritableStream} Stream that writes to disk for the active file.
   */
  _createStream(source) {
    const fullpath = path.join(this.dirname, this.filename);

    debug('create stream start', fullpath, this.options);
    const dest = fs.createWriteStream(fullpath, this.options)
      // TODO: What should we do with errors here?
      .on('error', err => debug(err))
      .on('close', () => debug('close', dest.path, dest.bytesWritten))
      .on('open', () => {
        debug('file open ok', fullpath);
        this.emit('open', fullpath);
        source.pipe(dest);

        // If rotation occured during the open operation then we immediately
        // start writing to a new PassThrough, begin opening the next file
        // and cleanup the previous source and dest once the source has drained.
        if (this.rotatedWhileOpening) {
          this._stream = new PassThrough();
          this._stream.setMaxListeners(30);
          this._rotateFile();
          this.rotatedWhileOpening = false;
          this._cleanupStream(dest);
          source.end();
        }
      });

    debug('create stream ok', fullpath);
    return dest;
  }

  /**
   * TODO: add method description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  _incFile(callback) {
    debug('_incFile', this.filename);
    const ext = path.extname(this._basename);
    const basename = path.basename(this._basename, ext);
    const tasks = [];

    if (this.zippedArchive) {
      tasks.push(
        function (cb) {
          const num = this._created > 0 && !this.tailable ? this._created : '';
          this._compressFile(
            path.join(this.dirname, `${basename}${num}${ext}`),
            path.join(this.dirname, `${basename}${num}${ext}.gz`),
            cb
          );
        }.bind(this)
      );
    }

    tasks.push(
      function (cb) {
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, cb);
        } else {
          this._checkMaxFilesTailable(ext, basename, cb);
        }
      }.bind(this)
    );

    asyncSeries(tasks, callback);
  }

  /**
   * Gets the next filename to use for this instance in the case that log
   * filesizes are being capped.
   * @returns {string} - TODO: add return description.
   * @private
   */
  _getFile() {
    const ext = path.extname(this._basename);
    const basename = path.basename(this._basename, ext);
    const isRotation = this.rotationFormat
      ? this.rotationFormat()
      : this._created;

    // Caveat emptor (indexzero): rotationFormat() was broken by design When
    // combined with max files because the set of files to unlink is never
    // stored.
    return !this.tailable && this._created
      ? `${basename}${isRotation}${ext}`
      : `${basename}${ext}`;
  }

  /**
   * Increment the number of files created or checked by this instance.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */
  _checkMaxFilesIncrementing(ext, basename, callback) {
    // Check for maxFiles option and delete file.
    if (!this.maxFiles || this._created < this.maxFiles) {
      return setImmediate(callback);
    }

    const oldest = this._created - this.maxFiles;
    const isOldest = oldest !== 0 ? oldest : '';
    const isZipped = this.zippedArchive ? '.gz' : '';
    const filePath = `${basename}${isOldest}${ext}${isZipped}`;
    const target = path.join(this.dirname, filePath);

    fs.unlink(target, callback);
  }

  /**
   * Roll files forward based on integer, up to maxFiles. e.g. if base if
   * file.log and it becomes oversized, roll to file1.log, and allow file.log
   * to be re-used. If file is oversized again, roll file1.log to file2.log,
   * roll file.log to file1.log, and so on.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */
  _checkMaxFilesTailable(ext, basename, callback) {
    const tasks = [];
    if (!this.maxFiles) {
      return;
    }

    // const isZipped = this.zippedArchive ? '.gz' : '';
    const isZipped = this.zippedArchive ? '.gz' : '';
    for (let x = this.maxFiles - 1; x > 1; x--) {
      tasks.push(function (i, cb) {
        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;
        const tmppath = path.join(this.dirname, fileName);

        fs.exists(tmppath, exists => {
          if (!exists) {
            return cb(null);
          }

          fileName = `${basename}${i}${ext}${isZipped}`;
          fs.rename(tmppath, path.join(this.dirname, fileName), cb);
        });
      }.bind(this, x));
    }

    asyncSeries(tasks, () => {
      fs.rename(
        path.join(this.dirname, `${basename}${ext}${isZipped}`),
        path.join(this.dirname, `${basename}1${ext}${isZipped}`),
        callback
      );
    });
  }

  /**
   * Compresses src to dest with gzip and unlinks src
   * @param {string} src - path to source file.
   * @param {string} dest - path to zipped destination file.
   * @param {Function} callback - callback called after file has been compressed.
   * @returns {undefined}
   * @private
   */
  _compressFile(src, dest, callback) {
    fs.access(src, fs.F_OK, (err) => {
      if (err) {
        return callback();
      }
      var gzip = zlib.createGzip();
      var inp = fs.createReadStream(src);
      var out = fs.createWriteStream(dest);
      out.on('finish', () => {
        fs.unlink(src, callback);
      });
      inp.pipe(gzip).pipe(out);
    });
  }

  _createLogDirIfNotExist(dirPath) {
    /* eslint-disable no-sync */
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    /* eslint-enable no-sync */
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/transports/http.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/transports/http.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * http.js: Transport for outputting to a json-rpcserver.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const { Stream } = __webpack_require__(/*! readable-stream */ "../../node_modules/winston/node_modules/readable-stream/readable.js");
const TransportStream = __webpack_require__(/*! winston-transport */ "../../node_modules/winston-transport/index.js");
const { configure } = __webpack_require__(/*! safe-stable-stringify */ "../../node_modules/safe-stable-stringify/index.js");

/**
 * Transport for outputting to a json-rpc server.
 * @type {Stream}
 * @extends {TransportStream}
 */
module.exports = class Http extends TransportStream {
  /**
   * Constructor function for the Http transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  // eslint-disable-next-line max-statements
  constructor(options = {}) {
    super(options);

    this.options = options;
    this.name = options.name || 'http';
    this.ssl = !!options.ssl;
    this.host = options.host || 'localhost';
    this.port = options.port;
    this.auth = options.auth;
    this.path = options.path || '';
    this.maximumDepth = options.maximumDepth;
    this.agent = options.agent;
    this.headers = options.headers || {};
    this.headers['content-type'] = 'application/json';
    this.batch = options.batch || false;
    this.batchInterval = options.batchInterval || 5000;
    this.batchCount = options.batchCount || 10;
    this.batchOptions = [];
    this.batchTimeoutID = -1;
    this.batchCallback = {};

    if (!this.port) {
      this.port = this.ssl ? 443 : 80;
    }
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    this._request(info, null, null, (err, res) => {
      if (res && res.statusCode !== 200) {
        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
      }

      if (err) {
        this.emit('warn', err);
      } else {
        this.emit('logged', info);
      }
    });

    // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering
    // and block more requests from happening?
    if (callback) {
      setImmediate(callback);
    }
  }

  /**
   * Query the transport. Options object is optional.
   * @param {Object} options -  Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * @returns {undefined}
   */
  query(options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    options = {
      method: 'query',
      params: this.normalizeQuery(options)
    };

    const auth = options.params.auth || null;
    delete options.params.auth;

    const path = options.params.path || null;
    delete options.params.path;

    this._request(options, auth, path, (err, res, body) => {
      if (res && res.statusCode !== 200) {
        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
      }

      if (err) {
        return callback(err);
      }

      if (typeof body === 'string') {
        try {
          body = JSON.parse(body);
        } catch (e) {
          return callback(e);
        }
      }

      callback(null, body);
    });
  }

  /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description
   */
  stream(options = {}) {
    const stream = new Stream();
    options = {
      method: 'stream',
      params: options
    };

    const path = options.params.path || null;
    delete options.params.path;

    const auth = options.params.auth || null;
    delete options.params.auth;

    let buff = '';
    const req = this._request(options, auth, path);

    stream.destroy = () => req.destroy();
    req.on('data', data => {
      data = (buff + data).split(/\n+/);
      const l = data.length - 1;

      let i = 0;
      for (; i < l; i++) {
        try {
          stream.emit('log', JSON.parse(data[i]));
        } catch (e) {
          stream.emit('error', e);
        }
      }

      buff = data[l];
    });
    req.on('error', err => stream.emit('error', err));

    return stream;
  }

  /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   * @param {function} callback - Continuation to respond to when complete.
   */
  _request(options, auth, path, callback) {
    options = options || {};

    auth = auth || this.auth;
    path = path || this.path || '';

    if (this.batch) {
      this._doBatch(options, callback, auth, path);
    } else {
      this._doRequest(options, callback, auth, path);
    }
  }

  /**
   * Send or memorize the options according to batch configuration
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doBatch(options, callback, auth, path) {
    this.batchOptions.push(options);
    if (this.batchOptions.length === 1) {
      // First message stored, it's time to start the timeout!
      const me = this;
      this.batchCallback = callback;
      this.batchTimeoutID = setTimeout(function () {
        // timeout is reached, send all messages to endpoint
        me.batchTimeoutID = -1;
        me._doBatchRequest(me.batchCallback, auth, path);
      }, this.batchInterval);
    }
    if (this.batchOptions.length === this.batchCount) {
      // max batch count is reached, send all messages to endpoint
      this._doBatchRequest(this.batchCallback, auth, path);
    }
  }

  /**
   * Initiate a request with the memorized batch options, stop the batch timeout
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doBatchRequest(callback, auth, path) {
    if (this.batchTimeoutID > 0) {
      clearTimeout(this.batchTimeoutID);
      this.batchTimeoutID = -1;
    }
    const batchOptionsCopy = this.batchOptions.slice();
    this.batchOptions = [];
    this._doRequest(batchOptionsCopy, callback, auth, path);
  }

  /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */
  _doRequest(options, callback, auth, path) {
    // Prepare options for outgoing HTTP request
    const headers = Object.assign({}, this.headers);
    if (auth && auth.bearer) {
      headers.Authorization = `Bearer ${auth.bearer}`;
    }
    const req = (this.ssl ? https : http).request({
      ...this.options,
      method: 'POST',
      host: this.host,
      port: this.port,
      path: `/${path.replace(/^\//, '')}`,
      headers: headers,
      auth: (auth && auth.username && auth.password) ? (`${auth.username}:${auth.password}`) : '',
      agent: this.agent
    });

    req.on('error', callback);
    req.on('response', res => (
      res.on('end', () => callback(null, res)).resume()
    ));
    const jsonStringify = configure({
      ...(this.maximumDepth && { maximumDepth: this.maximumDepth })
    });
    req.end(Buffer.from(jsonStringify(options, this.options.replacer), 'utf8'));
  }
};


/***/ }),

/***/ "../../node_modules/winston/lib/winston/transports/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/transports/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * transports.js: Set of all transports Winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



/**
 * TODO: add property description.
 * @type {Console}
 */
Object.defineProperty(exports, "Console", ({
  configurable: true,
  enumerable: true,
  get() {
    return __webpack_require__(/*! ./console */ "../../node_modules/winston/lib/winston/transports/console.js");
  }
}));

/**
 * TODO: add property description.
 * @type {File}
 */
Object.defineProperty(exports, "File", ({
  configurable: true,
  enumerable: true,
  get() {
    return __webpack_require__(/*! ./file */ "../../node_modules/winston/lib/winston/transports/file.js");
  }
}));

/**
 * TODO: add property description.
 * @type {Http}
 */
Object.defineProperty(exports, "Http", ({
  configurable: true,
  enumerable: true,
  get() {
    return __webpack_require__(/*! ./http */ "../../node_modules/winston/lib/winston/transports/http.js");
  }
}));

/**
 * TODO: add property description.
 * @type {Stream}
 */
Object.defineProperty(exports, "Stream", ({
  configurable: true,
  enumerable: true,
  get() {
    return __webpack_require__(/*! ./stream */ "../../node_modules/winston/lib/winston/transports/stream.js");
  }
}));


/***/ }),

/***/ "../../node_modules/winston/lib/winston/transports/stream.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/winston/lib/winston/transports/stream.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * stream.js: Transport for outputting to any arbitrary stream.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */



const isStream = __webpack_require__(/*! is-stream */ "../../node_modules/winston/node_modules/is-stream/index.js");
const { MESSAGE } = __webpack_require__(/*! triple-beam */ "../../node_modules/triple-beam/index.js");
const os = __webpack_require__(/*! os */ "os");
const TransportStream = __webpack_require__(/*! winston-transport */ "../../node_modules/winston-transport/index.js");

/**
 * Transport for outputting to any arbitrary stream.
 * @type {Stream}
 * @extends {TransportStream}
 */
module.exports = class Stream extends TransportStream {
  /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */
  constructor(options = {}) {
    super(options);

    if (!options.stream || !isStream(options.stream)) {
      throw new Error('options.stream is required.');
    }

    // We need to listen for drain events when write() returns false. This can
    // make node mad at times.
    this._stream = options.stream;
    this._stream.setMaxListeners(Infinity);
    this.isObjectMode = options.stream._writableState.objectMode;
    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;
  }

  /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */
  log(info, callback) {
    setImmediate(() => this.emit('logged', info));
    if (this.isObjectMode) {
      this._stream.write(info);
      if (callback) {
        callback(); // eslint-disable-line callback-return
      }
      return;
    }

    this._stream.write(`${info[MESSAGE]}${this.eol}`);
    if (callback) {
      callback(); // eslint-disable-line callback-return
    }
    return;
  }
};


/***/ }),

/***/ "../../node_modules/winston/node_modules/async/asyncify.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/asyncify.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncify;

var _initialParams = __webpack_require__(/*! ./internal/initialParams.js */ "../../node_modules/winston/node_modules/async/internal/initialParams.js");

var _initialParams2 = _interopRequireDefault(_initialParams);

var _setImmediate = __webpack_require__(/*! ./internal/setImmediate.js */ "../../node_modules/winston/node_modules/async/internal/setImmediate.js");

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _wrapAsync = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
        return function (...args /*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
        };
    }

    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback);
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0, _setImmediate2.default)(e => {
            throw e;
        }, err);
    }
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/eachOf.js":
/*!***************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/eachOf.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _isArrayLike = __webpack_require__(/*! ./internal/isArrayLike.js */ "../../node_modules/winston/node_modules/async/internal/isArrayLike.js");

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _breakLoop = __webpack_require__(/*! ./internal/breakLoop.js */ "../../node_modules/winston/node_modules/async/internal/breakLoop.js");

var _breakLoop2 = _interopRequireDefault(_breakLoop);

var _eachOfLimit = __webpack_require__(/*! ./eachOfLimit.js */ "../../node_modules/winston/node_modules/async/eachOfLimit.js");

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _once = __webpack_require__(/*! ./internal/once.js */ "../../node_modules/winston/node_modules/async/internal/once.js");

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = __webpack_require__(/*! ./internal/onlyOnce.js */ "../../node_modules/winston/node_modules/async/internal/onlyOnce.js");

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __webpack_require__(/*! ./internal/awaitify.js */ "../../node_modules/winston/node_modules/async/internal/awaitify.js");

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0,
        completed = 0,
        { length } = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return;
        if (err) {
            callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dev.json is a file containing a valid json object config for dev environment
 * // dev.json is a file containing a valid json object config for test environment
 * // prod.json is a file containing a valid json object config for prod environment
 * // invalid.json is a file with a malformed json object
 *
 * let configs = {}; //global variable
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
 *
 * // asynchronous function that reads a json file and parses the contents as json object
 * function parseFile(file, key, callback) {
 *     fs.readFile(file, "utf8", function(err, data) {
 *         if (err) return calback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }
 *
 * // Using callbacks
 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *     } else {
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *         // JSON parse error exception
 *     } else {
 *         console.log(configs);
 *     }
 * });
 *
 * // Using Promises
 * async.forEachOf(validConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 *     // configs is now a map of JSON data, e.g.
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 * }).catch( err => {
 *     console.error(err);
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 * }).catch( err => {
 *     console.error(err);
 *     // JSON parse error exception
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * //Error handing
 * async () => {
 *     try {
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
 *         console.log(configs);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // JSON parse error exception
 *     }
 * }
 *
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports["default"] = (0, _awaitify2.default)(eachOf, 3);
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/eachOfLimit.js":
/*!********************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/eachOfLimit.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOfLimit2 = __webpack_require__(/*! ./internal/eachOfLimit.js */ "../../node_modules/winston/node_modules/async/internal/eachOfLimit.js");

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

var _wrapAsync = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __webpack_require__(/*! ./internal/awaitify.js */ "../../node_modules/winston/node_modules/async/internal/awaitify.js");

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports["default"] = (0, _awaitify2.default)(eachOfLimit, 4);
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/eachOfSeries.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/eachOfSeries.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOfLimit = __webpack_require__(/*! ./eachOfLimit.js */ "../../node_modules/winston/node_modules/async/eachOfLimit.js");

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _awaitify = __webpack_require__(/*! ./internal/awaitify.js */ "../../node_modules/winston/node_modules/async/internal/awaitify.js");

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfSeries(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
}
exports["default"] = (0, _awaitify2.default)(eachOfSeries, 3);
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/forEach.js":
/*!****************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/forEach.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _eachOf = __webpack_require__(/*! ./eachOf.js */ "../../node_modules/winston/node_modules/async/eachOf.js");

var _eachOf2 = _interopRequireDefault(_eachOf);

var _withoutIndex = __webpack_require__(/*! ./internal/withoutIndex.js */ "../../node_modules/winston/node_modules/async/internal/withoutIndex.js");

var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

var _wrapAsync = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __webpack_require__(/*! ./internal/awaitify.js */ "../../node_modules/winston/node_modules/async/internal/awaitify.js");

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
 *
 * // asynchronous function that deletes a file
 * const deleteFile = function(file, callback) {
 *     fs.unlink(file, callback);
 * };
 *
 * // Using callbacks
 * async.each(fileList, deleteFile, function(err) {
 *     if( err ) {
 *         console.log(err);
 *     } else {
 *         console.log('All files have been deleted successfully');
 *     }
 * });
 *
 * // Error Handling
 * async.each(withMissingFileList, deleteFile, function(err){
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using Promises
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         await async.each(files, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         await async.each(withMissingFileList, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4/file2.txt does not exist
 *         // dir1/file1.txt could have been deleted
 *     }
 * }
 *
 */
function eachLimit(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}

exports["default"] = (0, _awaitify2.default)(eachLimit, 3);
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/asyncEachOfLimit.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/asyncEachOfLimit.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncEachOfLimit;

var _breakLoop = __webpack_require__(/*! ./breakLoop.js */ "../../node_modules/winston/node_modules/async/internal/breakLoop.js");

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return;
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
            //console.log('got value', value)
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);

        if (err === false) {
            done = true;
            canceled = true;
            return;
        }

        if (result === _breakLoop2.default || done && running <= 0) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/awaitify.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/awaitify.js ***!
  \**************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = awaitify;
// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify(asyncFn, arity) {
    if (!arity) arity = asyncFn.length;
    if (!arity) throw new Error('arity is undefined');
    function awaitable(...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args);
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        });
    }

    return awaitable;
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/breakLoop.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/breakLoop.js ***!
  \***************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};
exports["default"] = breakLoop;
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/eachOfLimit.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/eachOfLimit.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _once = __webpack_require__(/*! ./once.js */ "../../node_modules/winston/node_modules/async/internal/once.js");

var _once2 = _interopRequireDefault(_once);

var _iterator = __webpack_require__(/*! ./iterator.js */ "../../node_modules/winston/node_modules/async/internal/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = __webpack_require__(/*! ./onlyOnce.js */ "../../node_modules/winston/node_modules/async/internal/onlyOnce.js");

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = __webpack_require__(/*! ./wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

var _asyncEachOfLimit = __webpack_require__(/*! ./asyncEachOfLimit.js */ "../../node_modules/winston/node_modules/async/internal/asyncEachOfLimit.js");

var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);

var _breakLoop = __webpack_require__(/*! ./breakLoop.js */ "../../node_modules/winston/node_modules/async/internal/breakLoop.js");

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports["default"] = limit => {
    return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1');
        }
        if (!obj) {
            return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (err === false) {
                done = true;
                canceled = true;
            } else if (value === _breakLoop2.default || done && running <= 0) {
                done = true;
                return callback(null);
            } else if (!looping) {
                replenish();
            }
        }

        function replenish() {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/getIterator.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/getIterator.js ***!
  \*****************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

exports["default"] = function (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
};

module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/initialParams.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/initialParams.js ***!
  \*******************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

exports["default"] = function (fn) {
    return function (...args /*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
};

module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/isArrayLike.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/isArrayLike.js ***!
  \*****************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = isArrayLike;
function isArrayLike(value) {
    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/iterator.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/iterator.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = createIterator;

var _isArrayLike = __webpack_require__(/*! ./isArrayLike.js */ "../../node_modules/winston/node_modules/async/internal/isArrayLike.js");

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = __webpack_require__(/*! ./getIterator.js */ "../../node_modules/winston/node_modules/async/internal/getIterator.js");

var _getIterator2 = _interopRequireDefault(_getIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === '__proto__') {
            return next();
        }
        return i < len ? { value: obj[key], key } : null;
    };
}

function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/once.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/once.js ***!
  \**********************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = once;
function once(fn) {
    function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/onlyOnce.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/onlyOnce.js ***!
  \**************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = onlyOnce;
function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/parallel.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/parallel.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));

var _isArrayLike = __webpack_require__(/*! ./isArrayLike.js */ "../../node_modules/winston/node_modules/async/internal/isArrayLike.js");

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _wrapAsync = __webpack_require__(/*! ./wrapAsync.js */ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js");

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = __webpack_require__(/*! ./awaitify.js */ "../../node_modules/winston/node_modules/async/internal/awaitify.js");

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports["default"] = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/setImmediate.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/setImmediate.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fallback = fallback;
exports.wrap = wrap;
/* istanbul ignore file */

var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasQueueMicrotask) {
    _defer = queueMicrotask;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports["default"] = wrap(_defer);

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/withoutIndex.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/withoutIndex.js ***!
  \******************************************************************************/
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = _withoutIndex;
function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/internal/wrapAsync.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/internal/wrapAsync.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;

var _asyncify = __webpack_require__(/*! ../asyncify.js */ "../../node_modules/winston/node_modules/async/asyncify.js");

var _asyncify2 = _interopRequireDefault(_asyncify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function');
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}

exports["default"] = wrapAsync;
exports.isAsync = isAsync;
exports.isAsyncGenerator = isAsyncGenerator;
exports.isAsyncIterable = isAsyncIterable;

/***/ }),

/***/ "../../node_modules/winston/node_modules/async/series.js":
/*!***************************************************************!*\
  !*** ../../node_modules/winston/node_modules/async/series.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = series;

var _parallel2 = __webpack_require__(/*! ./internal/parallel.js */ "../../node_modules/winston/node_modules/async/internal/parallel.js");

var _parallel3 = _interopRequireDefault(_parallel2);

var _eachOfSeries = __webpack_require__(/*! ./eachOfSeries.js */ "../../node_modules/winston/node_modules/async/eachOfSeries.js");

var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @return {Promise} a promise, if no callback is passed
 * @example
 *
 * //Using Callbacks
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * });
 *
 * // an example using objects instead of arrays
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.series([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */
function series(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
}
module.exports = exports.default;

/***/ }),

/***/ "../../node_modules/winston/node_modules/is-stream/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/winston/node_modules/is-stream/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function';

module.exports = isStream;


/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/errors.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/errors.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.codes = codes;


/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __webpack_require__(/*! ./_stream_readable */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js");
__webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits.js")(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __webpack_require__(/*! ./_stream_transform */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js");
__webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits.js")(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(/*! events */ "events").EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ "util");
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits.js")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "../../node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "../../node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js");
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__webpack_require__(/*! ../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(/*! ./_stream_duplex */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");
__webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits.js")(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "../../node_modules/util-deprecate/node.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js");
var _require = __webpack_require__(/*! ./internal/streams/state */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js"),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(/*! ../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits.js")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(/*! buffer */ "buffer"),
  Buffer = _require.Buffer;
var _require2 = __webpack_require__(/*! util */ "util"),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***********************************************************************************************/
/***/ ((module) => {

"use strict";


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes).ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ERR_INVALID_ARG_TYPE = (__webpack_require__(/*! ../../../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes).ERR_INVALID_ARG_TYPE;
function from(Readable, iterable, opts) {
  var iterator;
  if (iterable && typeof iterable.next === 'function') {
    iterator = iterable;
  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
  var readable = new Readable(_objectSpread({
    objectMode: true
  }, opts));
  // Reading boolean to protect against _read
  // being called before last iteration completion.
  var reading = false;
  readable._read = function () {
    if (!reading) {
      reading = true;
      next();
    }
  };
  function next() {
    return _next2.apply(this, arguments);
  }
  function _next2() {
    _next2 = _asyncToGenerator(function* () {
      try {
        var _yield$iterator$next = yield iterator.next(),
          value = _yield$iterator$next.value,
          done = _yield$iterator$next.done;
        if (done) {
          readable.push(null);
        } else if (readable.push(yield value)) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    });
    return _next2.apply(this, arguments);
  }
  return readable;
}
module.exports = from;


/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__webpack_require__(/*! ../../../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "../../node_modules/winston/node_modules/readable-stream/errors.js").codes).ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! stream */ "stream");


/***/ }),

/***/ "../../node_modules/winston/node_modules/readable-stream/readable.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/winston/node_modules/readable-stream/readable.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(/*! stream */ "stream");
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js");
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js");
  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js");
  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js");
  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "../../node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js");
  exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js");
}


/***/ }),

/***/ "./lib/app.js":
/*!********************!*\
  !*** ./lib/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.launch = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
__webpack_require__(/*! reflect-metadata */ "../../node_modules/reflect-metadata/Reflect.js");
const node_1 = __webpack_require__(/*! @eclipse-glsp/server/node */ "../../node_modules/@eclipse-glsp/server/node.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_diagram_module_1 = __webpack_require__(/*! ./diagram/tasklist-diagram-module */ "./lib/diagram/tasklist-diagram-module.js");
async function launch(argv) {
    const options = (0, node_1.createSocketCliParser)().parse(argv);
    const appContainer = new inversify_1.Container();
    appContainer.load((0, node_1.createAppModule)(options));
    const launcher = appContainer.resolve(node_1.SocketServerLauncher);
    const serverModule = new node_1.ServerModule().configureDiagramModule(new tasklist_diagram_module_1.TaskListDiagramModule());
    launcher.configure(serverModule);
    launcher.start({ port: options.port, host: options.host });
}
exports.launch = launch;
launch(process.argv).catch(error => console.error('Error in tasklist server launcher:', error));


/***/ }),

/***/ "./lib/diagram/tasklist-diagram-configuration.js":
/*!*******************************************************!*\
  !*** ./lib/diagram/tasklist-diagram-configuration.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListDiagramConfiguration = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
let TaskListDiagramConfiguration = class TaskListDiagramConfiguration {
    constructor() {
        this.layoutKind = server_1.ServerLayoutKind.MANUAL;
        this.needsClientLayout = true;
        this.animatedUpdate = true;
    }
    get typeMapping() {
        return (0, server_1.getDefaultMapping)();
    }
    get shapeTypeHints() {
        return [
            {
                elementTypeId: server_1.DefaultTypes.NODE,
                deletable: true,
                reparentable: false,
                repositionable: true,
                resizable: true
            }
        ];
    }
    get edgeTypeHints() {
        return [
            {
                elementTypeId: server_1.DefaultTypes.EDGE,
                deletable: true,
                repositionable: false,
                routable: false,
                sourceElementTypeIds: [server_1.DefaultTypes.NODE],
                targetElementTypeIds: [server_1.DefaultTypes.NODE]
            }
        ];
    }
};
exports.TaskListDiagramConfiguration = TaskListDiagramConfiguration;
exports.TaskListDiagramConfiguration = TaskListDiagramConfiguration = __decorate([
    (0, inversify_1.injectable)()
], TaskListDiagramConfiguration);


/***/ }),

/***/ "./lib/diagram/tasklist-diagram-module.js":
/*!************************************************!*\
  !*** ./lib/diagram/tasklist-diagram-module.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListDiagramModule = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const create_task_node_handler_1 = __webpack_require__(/*! ../handler/create-task-node-handler */ "./lib/handler/create-task-node-handler.js");
const create_transition_handler_1 = __webpack_require__(/*! ../handler/create-transition-handler */ "./lib/handler/create-transition-handler.js");
const delete_element_handler_1 = __webpack_require__(/*! ../handler/delete-element-handler */ "./lib/handler/delete-element-handler.js");
const tasklist_apply_label_edit_handler_1 = __webpack_require__(/*! ../handler/tasklist-apply-label-edit-handler */ "./lib/handler/tasklist-apply-label-edit-handler.js");
const tasklist_change_bounds_handler_1 = __webpack_require__(/*! ../handler/tasklist-change-bounds-handler */ "./lib/handler/tasklist-change-bounds-handler.js");
const tasklist_label_edit_validator_1 = __webpack_require__(/*! ../handler/tasklist-label-edit-validator */ "./lib/handler/tasklist-label-edit-validator.js");
const tasklist_gmodel_factory_1 = __webpack_require__(/*! ../model/tasklist-gmodel-factory */ "./lib/model/tasklist-gmodel-factory.js");
const tasklist_model_index_1 = __webpack_require__(/*! ../model/tasklist-model-index */ "./lib/model/tasklist-model-index.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
const tasklist_storage_1 = __webpack_require__(/*! ../model/tasklist-storage */ "./lib/model/tasklist-storage.js");
const tasklist_diagram_configuration_1 = __webpack_require__(/*! ./tasklist-diagram-configuration */ "./lib/diagram/tasklist-diagram-configuration.js");
let TaskListDiagramModule = class TaskListDiagramModule extends server_1.DiagramModule {
    constructor() {
        super(...arguments);
        this.diagramType = 'tasklist-diagram';
    }
    bindDiagramConfiguration() {
        return tasklist_diagram_configuration_1.TaskListDiagramConfiguration;
    }
    bindSourceModelStorage() {
        return tasklist_storage_1.TaskListStorage;
    }
    bindModelState() {
        return { service: tasklist_model_state_1.TaskListModelState };
    }
    bindGModelFactory() {
        return tasklist_gmodel_factory_1.TaskListGModelFactory;
    }
    configureActionHandlers(binding) {
        super.configureActionHandlers(binding);
        binding.add(server_1.ComputedBoundsActionHandler);
    }
    configureOperationHandlers(binding) {
        super.configureOperationHandlers(binding);
        binding.add(create_task_node_handler_1.CreateTaskHandler);
        binding.add(create_transition_handler_1.CreateTransitionHandler);
        binding.add(tasklist_change_bounds_handler_1.TaskListChangeBoundsHandler);
        binding.add(tasklist_apply_label_edit_handler_1.TaskListApplyLabelEditHandler);
        binding.add(delete_element_handler_1.DeleteElementHandler);
    }
    bindGModelIndex() {
        this.context.bind(tasklist_model_index_1.TaskListModelIndex).toSelf().inSingletonScope();
        return { service: tasklist_model_index_1.TaskListModelIndex };
    }
    bindLabelEditValidator() {
        return tasklist_label_edit_validator_1.TaskListLabelEditValidator;
    }
};
exports.TaskListDiagramModule = TaskListDiagramModule;
exports.TaskListDiagramModule = TaskListDiagramModule = __decorate([
    (0, inversify_1.injectable)()
], TaskListDiagramModule);


/***/ }),

/***/ "./lib/handler/create-task-node-handler.js":
/*!*************************************************!*\
  !*** ./lib/handler/create-task-node-handler.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTaskHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let CreateTaskHandler = class CreateTaskHandler extends server_1.JsonCreateNodeOperationHandler {
    constructor() {
        super(...arguments);
        this.elementTypeIds = [server_1.DefaultTypes.NODE];
    }
    createCommand(operation) {
        return this.commandOf(() => {
            var _a;
            const relativeLocation = (_a = this.getRelativeLocation(operation)) !== null && _a !== void 0 ? _a : server_1.Point.ORIGIN;
            const task = this.createTask(relativeLocation);
            const taskList = this.modelState.sourceModel;
            taskList.tasks.push(task);
        });
    }
    createTask(position) {
        const nodeCounter = this.modelState.index.getAllByClass(server_1.GNode).length;
        return {
            id: uuid.v4(),
            name: `NewTaskNode${nodeCounter}`,
            position
        };
    }
    get label() {
        return 'Task';
    }
};
exports.CreateTaskHandler = CreateTaskHandler;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], CreateTaskHandler.prototype, "modelState", void 0);
exports.CreateTaskHandler = CreateTaskHandler = __decorate([
    (0, inversify_1.injectable)()
], CreateTaskHandler);


/***/ }),

/***/ "./lib/handler/create-transition-handler.js":
/*!**************************************************!*\
  !*** ./lib/handler/create-transition-handler.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTransitionHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let CreateTransitionHandler = class CreateTransitionHandler extends server_1.JsonCreateEdgeOperationHandler {
    constructor() {
        super(...arguments);
        this.elementTypeIds = [server_1.DefaultTypes.EDGE];
    }
    createCommand(operation) {
        return this.commandOf(() => {
            const transition = {
                id: uuid.v4(),
                sourceTaskId: operation.sourceElementId,
                targetTaskId: operation.targetElementId
            };
            this.modelState.sourceModel.transitions.push(transition);
        });
    }
    get label() {
        return 'Transition';
    }
};
exports.CreateTransitionHandler = CreateTransitionHandler;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], CreateTransitionHandler.prototype, "modelState", void 0);
exports.CreateTransitionHandler = CreateTransitionHandler = __decorate([
    (0, inversify_1.injectable)()
], CreateTransitionHandler);


/***/ }),

/***/ "./lib/handler/delete-element-handler.js":
/*!***********************************************!*\
  !*** ./lib/handler/delete-element-handler.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteElementHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_1 = __webpack_require__(/*! ../model/tasklist-model */ "./lib/model/tasklist-model.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let DeleteElementHandler = class DeleteElementHandler extends server_1.JsonOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = server_1.DeleteElementOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => {
            operation.elementIds.forEach(elementId => this.delete(elementId));
        });
    }
    delete(elementId) {
        var _a;
        const index = this.modelState.index;
        const gModelElement = this.getGModelElementToDelete(elementId);
        const gModelElementId = (_a = gModelElement === null || gModelElement === void 0 ? void 0 : gModelElement.id) !== null && _a !== void 0 ? _a : elementId;
        const gEdgeIds = this.getIncomingAndOutgoingEdgeIds(gModelElement);
        [...gEdgeIds, gModelElementId]
            .map(id => index.findTaskOrTransition(id))
            .forEach(modelElement => this.deleteModelElement(modelElement));
    }
    getGModelElementToDelete(elementId) {
        var _a;
        const index = this.modelState.index;
        const element = index.get(elementId);
        if (element instanceof server_1.GNode || element instanceof server_1.GEdge) {
            return element;
        }
        return (_a = index.findParentElement(elementId, (0, server_1.toTypeGuard)(server_1.GNode))) !== null && _a !== void 0 ? _a : index.findParentElement(elementId, (0, server_1.toTypeGuard)(server_1.GEdge));
    }
    getIncomingAndOutgoingEdgeIds(node) {
        return this.getIncomingAndOutgoingEdges(node).map(edge => edge.id);
    }
    getIncomingAndOutgoingEdges(node) {
        if (node instanceof server_1.GNode) {
            return [...this.modelState.index.getIncomingEdges(node), ...this.modelState.index.getOutgoingEdges(node)];
        }
        return [];
    }
    deleteModelElement(modelElement) {
        if (tasklist_model_1.Task.is(modelElement)) {
            (0, server_1.remove)(this.modelState.sourceModel.tasks, modelElement);
        }
        else if (tasklist_model_1.Transition.is(modelElement)) {
            (0, server_1.remove)(this.modelState.sourceModel.transitions, modelElement);
        }
    }
};
exports.DeleteElementHandler = DeleteElementHandler;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], DeleteElementHandler.prototype, "modelState", void 0);
exports.DeleteElementHandler = DeleteElementHandler = __decorate([
    (0, inversify_1.injectable)()
], DeleteElementHandler);


/***/ }),

/***/ "./lib/handler/tasklist-apply-label-edit-handler.js":
/*!**********************************************************!*\
  !*** ./lib/handler/tasklist-apply-label-edit-handler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListApplyLabelEditHandler = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const protocol_1 = __webpack_require__(/*! @eclipse-glsp/protocol */ "../../node_modules/@eclipse-glsp/protocol/lib/index.js");
const node_1 = __webpack_require__(/*! @eclipse-glsp/server/node */ "../../node_modules/@eclipse-glsp/server/node.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let TaskListApplyLabelEditHandler = class TaskListApplyLabelEditHandler extends node_1.JsonOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = protocol_1.ApplyLabelEditOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => {
            const index = this.modelState.index;
            // Retrieve the parent node of the label that should be edited
            const taskNode = index.findParentElement(operation.labelId, (0, node_1.toTypeGuard)(node_1.GNode));
            if (taskNode) {
                const task = index.findTask(taskNode.id);
                if (!task) {
                    throw new node_1.GLSPServerError(`Could not retrieve the parent task for the label with id ${operation.labelId}`);
                }
                task.name = operation.text;
            }
        });
    }
};
exports.TaskListApplyLabelEditHandler = TaskListApplyLabelEditHandler;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], TaskListApplyLabelEditHandler.prototype, "modelState", void 0);
exports.TaskListApplyLabelEditHandler = TaskListApplyLabelEditHandler = __decorate([
    (0, inversify_1.injectable)()
], TaskListApplyLabelEditHandler);


/***/ }),

/***/ "./lib/handler/tasklist-change-bounds-handler.js":
/*!*******************************************************!*\
  !*** ./lib/handler/tasklist-change-bounds-handler.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListChangeBoundsHandler = void 0;
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let TaskListChangeBoundsHandler = class TaskListChangeBoundsHandler extends server_1.JsonOperationHandler {
    constructor() {
        super(...arguments);
        this.operationType = server_1.ChangeBoundsOperation.KIND;
    }
    createCommand(operation) {
        return this.commandOf(() => {
            operation.newBounds.forEach(element => this.changeElementBounds(element.elementId, element.newSize, element.newPosition));
        });
    }
    changeElementBounds(elementId, newSize, newPosition) {
        const index = this.modelState.index;
        const taskNode = index.findByClass(elementId, server_1.GNode);
        const task = taskNode ? index.findTask(taskNode.id) : undefined;
        if (task) {
            task.size = newSize;
            if (newPosition) {
                task.position = newPosition;
            }
        }
    }
};
exports.TaskListChangeBoundsHandler = TaskListChangeBoundsHandler;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], TaskListChangeBoundsHandler.prototype, "modelState", void 0);
exports.TaskListChangeBoundsHandler = TaskListChangeBoundsHandler = __decorate([
    (0, inversify_1.injectable)()
], TaskListChangeBoundsHandler);


/***/ }),

/***/ "./lib/handler/tasklist-label-edit-validator.js":
/*!******************************************************!*\
  !*** ./lib/handler/tasklist-label-edit-validator.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListLabelEditValidator = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_state_1 = __webpack_require__(/*! ../model/tasklist-model-state */ "./lib/model/tasklist-model-state.js");
/**
 * A simple edit label validator that verifies that the given name label is not empty.
 */
let TaskListLabelEditValidator = class TaskListLabelEditValidator {
    validate(label, element) {
        if (label.length < 1) {
            return { severity: server_1.ValidationStatus.Severity.ERROR, message: 'Name must not be empty' };
        }
        return { severity: server_1.ValidationStatus.Severity.OK };
    }
};
exports.TaskListLabelEditValidator = TaskListLabelEditValidator;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], TaskListLabelEditValidator.prototype, "modelState", void 0);
exports.TaskListLabelEditValidator = TaskListLabelEditValidator = __decorate([
    (0, inversify_1.injectable)()
], TaskListLabelEditValidator);


/***/ }),

/***/ "./lib/model/tasklist-gmodel-factory.js":
/*!**********************************************!*\
  !*** ./lib/model/tasklist-gmodel-factory.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListGModelFactory = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_state_1 = __webpack_require__(/*! ./tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let TaskListGModelFactory = class TaskListGModelFactory {
    createModel() {
        const taskList = this.modelState.sourceModel;
        this.modelState.index.indexTaskList(taskList);
        const childNodes = taskList.tasks.map(task => this.createTaskNode(task));
        const childEdges = taskList.transitions.map(transition => this.createTransitionEdge(transition));
        const newRoot = server_1.GGraph.builder() //
            .id(taskList.id)
            .addChildren(childNodes)
            .addChildren(childEdges)
            .build();
        this.modelState.updateRoot(newRoot);
    }
    createTaskNode(task) {
        const builder = server_1.GNode.builder()
            .id(task.id)
            .addCssClass('tasklist-node')
            .add(server_1.GLabel.builder().text(task.name).id(`${task.id}_label`).build())
            .layout('hbox')
            .addLayoutOption('paddingLeft', 5)
            .position(task.position);
        if (task.size) {
            builder.addLayoutOptions({ prefWidth: task.size.width, prefHeight: task.size.height });
        }
        return builder.build();
    }
    createTransitionEdge(transition) {
        return server_1.GEdge.builder() //
            .id(transition.id)
            .addCssClass('tasklist-transition')
            .sourceId(transition.sourceTaskId)
            .targetId(transition.targetTaskId)
            .build();
    }
};
exports.TaskListGModelFactory = TaskListGModelFactory;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], TaskListGModelFactory.prototype, "modelState", void 0);
exports.TaskListGModelFactory = TaskListGModelFactory = __decorate([
    (0, inversify_1.injectable)()
], TaskListGModelFactory);


/***/ }),

/***/ "./lib/model/tasklist-model-index.js":
/*!*******************************************!*\
  !*** ./lib/model/tasklist-model-index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListModelIndex = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_1 = __webpack_require__(/*! ./tasklist-model */ "./lib/model/tasklist-model.js");
let TaskListModelIndex = class TaskListModelIndex extends server_1.GModelIndex {
    constructor() {
        super(...arguments);
        this.idToTaskListElements = new Map();
    }
    indexTaskList(taskList) {
        this.idToTaskListElements.clear();
        for (const element of [...taskList.tasks, ...taskList.transitions]) {
            this.idToTaskListElements.set(element.id, element);
        }
    }
    findTask(id) {
        const element = this.findTaskOrTransition(id);
        return tasklist_model_1.Task.is(element) ? element : undefined;
    }
    findTransition(id) {
        const element = this.findTaskOrTransition(id);
        return tasklist_model_1.Transition.is(element) ? element : undefined;
    }
    findTaskOrTransition(id) {
        return this.idToTaskListElements.get(id);
    }
};
exports.TaskListModelIndex = TaskListModelIndex;
exports.TaskListModelIndex = TaskListModelIndex = __decorate([
    (0, inversify_1.injectable)()
], TaskListModelIndex);


/***/ }),

/***/ "./lib/model/tasklist-model-state.js":
/*!*******************************************!*\
  !*** ./lib/model/tasklist-model-state.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListModelState = void 0;
/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const tasklist_model_index_1 = __webpack_require__(/*! ./tasklist-model-index */ "./lib/model/tasklist-model-index.js");
let TaskListModelState = class TaskListModelState extends server_1.DefaultModelState {
    get sourceModel() {
        return this._taskList;
    }
    updateSourceModel(taskList) {
        this._taskList = taskList;
        this.index.indexTaskList(taskList);
    }
};
exports.TaskListModelState = TaskListModelState;
__decorate([
    (0, inversify_1.inject)(tasklist_model_index_1.TaskListModelIndex),
    __metadata("design:type", tasklist_model_index_1.TaskListModelIndex)
], TaskListModelState.prototype, "index", void 0);
exports.TaskListModelState = TaskListModelState = __decorate([
    (0, inversify_1.injectable)()
], TaskListModelState);


/***/ }),

/***/ "./lib/model/tasklist-model.js":
/*!*************************************!*\
  !*** ./lib/model/tasklist-model.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transition = exports.Task = exports.TaskList = void 0;
const server_1 = __webpack_require__(/*! @eclipse-glsp/server */ "../../node_modules/@eclipse-glsp/server/lib/node/index.js");
var TaskList;
(function (TaskList) {
    function is(object) {
        return server_1.AnyObject.is(object) && (0, server_1.hasStringProp)(object, 'id') && (0, server_1.hasArrayProp)(object, 'tasks');
    }
    TaskList.is = is;
})(TaskList || (exports.TaskList = TaskList = {}));
var Task;
(function (Task) {
    function is(object) {
        return server_1.AnyObject.is(object) && (0, server_1.hasStringProp)(object, 'id') && (0, server_1.hasStringProp)(object, 'name') && (0, server_1.hasObjectProp)(object, 'position');
    }
    Task.is = is;
})(Task || (exports.Task = Task = {}));
var Transition;
(function (Transition) {
    function is(object) {
        return (server_1.AnyObject.is(object) &&
            (0, server_1.hasStringProp)(object, 'id') &&
            (0, server_1.hasStringProp)(object, 'sourceTaskId') &&
            (0, server_1.hasStringProp)(object, 'targetTaskId'));
    }
    Transition.is = is;
})(Transition || (exports.Transition = Transition = {}));


/***/ }),

/***/ "./lib/model/tasklist-storage.js":
/*!***************************************!*\
  !*** ./lib/model/tasklist-storage.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (c) 2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied:
 * -- GNU General Public License, version 2 with the GNU Classpath Exception
 * which is available at https://www.gnu.org/software/classpath/license.html
 * -- MIT License which is available at https://opensource.org/license/mit.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR MIT
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskListStorage = void 0;
const node_1 = __webpack_require__(/*! @eclipse-glsp/server/node */ "../../node_modules/@eclipse-glsp/server/node.js");
const inversify_1 = __webpack_require__(/*! inversify */ "../../node_modules/inversify/es/inversify.js");
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const tasklist_model_1 = __webpack_require__(/*! ./tasklist-model */ "./lib/model/tasklist-model.js");
const tasklist_model_state_1 = __webpack_require__(/*! ./tasklist-model-state */ "./lib/model/tasklist-model-state.js");
let TaskListStorage = class TaskListStorage extends node_1.AbstractJsonModelStorage {
    loadSourceModel(action) {
        const sourceUri = this.getSourceUri(action);
        const taskList = this.loadFromFile(sourceUri, tasklist_model_1.TaskList.is);
        this.modelState.updateSourceModel(taskList);
    }
    saveSourceModel(action) {
        const sourceUri = this.getFileUri(action);
        this.writeFile(sourceUri, this.modelState.sourceModel);
    }
    createModelForEmptyFile(path) {
        return {
            id: uuid.v4(),
            tasks: [],
            transitions: []
        };
    }
};
exports.TaskListStorage = TaskListStorage;
__decorate([
    (0, inversify_1.inject)(tasklist_model_state_1.TaskListModelState),
    __metadata("design:type", tasklist_model_state_1.TaskListModelState)
], TaskListStorage.prototype, "modelState", void 0);
exports.TaskListStorage = TaskListStorage = __decorate([
    (0, inversify_1.injectable)()
], TaskListStorage);


/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/index.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

const { Argument } = __webpack_require__(/*! ./lib/argument.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/argument.js");
const { Command } = __webpack_require__(/*! ./lib/command.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/command.js");
const { CommanderError, InvalidArgumentError } = __webpack_require__(/*! ./lib/error.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js");
const { Help } = __webpack_require__(/*! ./lib/help.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/help.js");
const { Option } = __webpack_require__(/*! ./lib/option.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/option.js");

// @ts-check

/**
 * Expose the root command.
 */

exports = module.exports = new Command();
exports.program = exports; // More explicit access to global command.
// Implicit export of createArgument, createCommand, and createOption.

/**
 * Expose classes
 */

exports.Argument = Argument;
exports.Command = Command;
exports.CommanderError = CommanderError;
exports.Help = Help;
exports.InvalidArgumentError = InvalidArgumentError;
exports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated
exports.Option = Option;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/argument.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/argument.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__(/*! ./error.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js");

// @ts-check

class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  };

  /**
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  };

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  };

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values;
    this.parseArg = (arg, previous) => {
      if (!values.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  };

  /**
   * Make option-argument required.
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make option-argument optional.
   */
  argOptional() {
    this.required = false;
    return this;
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @api private
 */

function humanReadableArgName(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']';
}

exports.Argument = Argument;
exports.humanReadableArgName = humanReadableArgName;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/command.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/command.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
const childProcess = __webpack_require__(/*! child_process */ "child_process");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");

const { Argument, humanReadableArgName } = __webpack_require__(/*! ./argument.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/argument.js");
const { CommanderError } = __webpack_require__(/*! ./error.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js");
const { Help } = __webpack_require__(/*! ./help.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/help.js");
const { Option, splitOptionFlags } = __webpack_require__(/*! ./option.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/option.js");
const { suggestSimilar } = __webpack_require__(/*! ./suggestSimilar */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/suggestSimilar.js");

// @ts-check

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this._args = [];
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default < config < env < cli
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {boolean | string} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = false;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    };

    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} returns `this` for executable command
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  };

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  };

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  };

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {Object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');

    // To keep things simple, block automatic name generation for deeply nested executables.
    // Fail fast and detect when adding rather than later when parsing.
    function checkExplicitNames(commandArray) {
      commandArray.forEach((cmd) => {
        if (cmd._executableHandler && !cmd._executableFile) {
          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);
        }
        checkExplicitNames(cmd.commands);
      });
    }
    checkExplicitNames(cmd.commands);

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this.commands.push(cmd);
    cmd.parent = this;
    return this;
  };

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  };

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {Function|*} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names.split(/ +/).forEach((detail) => {
      this.argument(detail);
    });
    return this;
  };

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this._args.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
    }
    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
    }
    this._args.push(argument);
    return this;
  }

  /**
   * Override default decision whether to add implicit help command.
   *
   *    addHelpCommand() // force on
   *    addHelpCommand(false); // force off
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command} `this` command for chaining
   */

  addHelpCommand(enableOrNameAndArgs, description) {
    if (enableOrNameAndArgs === false) {
      this._addImplicitHelpCommand = false;
    } else {
      this._addImplicitHelpCommand = true;
      if (typeof enableOrNameAndArgs === 'string') {
        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
        this._helpCommandnameAndArgs = enableOrNameAndArgs;
      }
      this._helpCommandDescription = description || this._helpCommandDescription;
    }
    return this;
  };

  /**
   * @return {boolean}
   * @api private
   */

  _hasImplicitHelpCommand() {
    if (this._addImplicitHelpCommand === undefined) {
      return this.commands.length && !this._actionHandler && !this._findCommand('help');
    }
    return this._addImplicitHelpCommand;
  };

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
          // Async callback from spawn events, not useful to throw.
        }
      };
    }
    return this;
  };

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process.exit(exitCode);
  };

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this._args.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  };

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  };

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    const oname = option.name();
    const name = option.attributeName();

    let defaultValue = option.defaultValue;

    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value
    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {
      // when --no-foo we make sure default is true, unless a --foo option is already defined
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, '--');
        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
      }
      // preassign only if we have a default
      if (defaultValue !== undefined) {
        this.setOptionValueWithSource(name, defaultValue, 'default');
      }
    }

    // register the option
    this.options.push(option);

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // Note: using closure to access lots of lexical scoped variables.
      const oldValue = this.getOptionValue(name);

      // custom processing
      if (val !== null && option.parseArg) {
        try {
          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidValueMessage} ${err.message}`;
            this._displayError(err.exitCode, err.code, message);
          }
          throw err;
        }
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // unassigned or boolean value
      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {
        // if no value, negate false, and we have a default, then use it!
        if (val == null) {
          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
        } else {
          this.setOptionValueWithSource(name, val, valueSource);
        }
      } else if (val !== null) {
        // reassign
        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
      }
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string contains the short and/or long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   *     "-p, --pepper"
   *     "-p|--pepper"
   *     "-p --pepper"
   *
   * @example
   * // simple boolean defaulting to undefined
   * program.option('-p, --pepper', 'add pepper');
   *
   * program.pepper
   * // => undefined
   *
   * --pepper
   * program.pepper
   * // => true
   *
   * // simple boolean defaulting to true (unless non-negated option is also defined)
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [fn] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, fn, defaultValue) {
    return this._optionEx({}, flags, description, fn, defaultValue);
  };

  /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string} flags
  * @param {string} [description]
  * @param {Function|*} [fn] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */

  requiredOption(flags, description, fn, defaultValue) {
    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
  };

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  };

  /**
   * Allow unknown options on the command line.
   *
   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
   * for unknown options.
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  };

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
   * for excess arguments.
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  };

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {Boolean} [positional=true]
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  };

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true]
   * for unknown options.
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
    }
    return this;
  };

  /**
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean} [storeAsProperties=true]
    * @return {Command} `this` command for chaining
    */

  storeOptionsAsProperties(storeAsProperties = true) {
    this._storeOptionsAsProperties = !!storeAsProperties;
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    return this;
  };

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {Object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  };

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {Object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    return this;
  };

  /**
   * Store option value and where the value came from.
    *
    * @param {string} key
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli
    * @return {Command} `this` command for chaining
    */

  setOptionValueWithSource(key, value, source) {
    this.setOptionValue(key, value);
    this._optionValueSources[key] = source;
    return this;
  }

  /**
    * Get source of option value.
    * Expected values are default | config | env | cli
    *
    * @param {string} key
    * @return {string}
    */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  };

  /**
   * Get user arguments implied or explicit arguments.
   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.
   *
   * @api private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // Default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      }
    }
    this.rawArgs = argv.slice();

    // make it a little easier for callers by supporting various argv conventions
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      default:
        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
    }
    if (!this._scriptPath && __webpack_require__.c[__webpack_require__.s]) {
      this._scriptPath = __webpack_require__.c[__webpack_require__.s].filename;
    }

    // Guess name, used in usage in help.
    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  };

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  };

  /**
   * Execute a sub-command executable.
   *
   * @api private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();

    // Want the entry script as the reference for command name and directory for searching for other files.
    let scriptPath = this._scriptPath;
    // Fallback in case not set, due to how Command created or called.
    if (!scriptPath && __webpack_require__.c[__webpack_require__.s]) {
      scriptPath = __webpack_require__.c[__webpack_require__.s].filename;
    }

    let baseDir;
    try {
      const resolvedLink = fs.realpathSync(scriptPath);
      baseDir = path.dirname(resolvedLink);
    } catch (e) {
      baseDir = '.'; // dummy, probably not going to find executable!
    }

    // name of the subcommand, like `pm-install`
    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;
    if (subcommand._executableFile) {
      bin = subcommand._executableFile;
    }

    const localBin = path.join(baseDir, bin);
    if (fs.existsSync(localBin)) {
      // prefer local `./<bin>` to bin in the $PATH
      bin = localBin;
    } else {
      // Look for source files.
      sourceExt.forEach((ext) => {
        if (fs.existsSync(`${localBin}${ext}`)) {
          bin = `${localBin}${ext}`;
        }
      });
    }
    launchWithNode = sourceExt.includes(path.extname(bin));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(bin);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(bin);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
    }

    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
    signals.forEach((signal) => {
      // @ts-ignore
      process.on(signal, () => {
        if (proc.killed === false && proc.exitCode === null) {
          proc.kill(signal);
        }
      });
    });

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    } else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      });
    }
    proc.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
        throw new Error(executableMissing);
      // @ts-ignore
      } else if (err.code === 'EACCES') {
        throw new Error(`'${bin}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  };

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    if (subCommand._executableHandler) {
      this._executeSubCommand(subCommand, operands.concat(unknown));
    } else {
      return subCommand._parseCommand(operands, unknown);
    }
  };

  /**
   * Check this.args against expected this._args.
   *
   * @api private
   */

  _checkNumberOfArguments() {
    // too few
    this._args.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
      return;
    }
    if (this.args.length > this._args.length) {
      this._excessArguments(this.args);
    }
  };

  /**
   * Process this.args using this._args and save as this.processedArgs!
   *
   * @api private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        try {
          parsedValue = argument.parseArg(value, previous);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
            this._displayError(err.exitCode, err.code, message);
          }
          throw err;
        }
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this._args.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    getCommandAndParents(this)
      .reverse()
      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
      .forEach(hookedCommand => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
      if (operands.length === 1) {
        this.help();
      }
      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
    }
    if (this._defaultCommandName) {
      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    }
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    outputHelpIfRequested(this, parsed.unknown);
    this._checkForMissingMandatoryOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let actionResult;
      actionResult = this._chainOrCallHooks(actionResult, 'preAction');
      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy
      actionResult = this._chainOrCallHooks(actionResult, 'postAction');
      return actionResult;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) { // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  };

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  };

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  };

  /**
   * Display an error message if a mandatory option does not have a value.
   * Lazy calling after checking for help flags from leaf subcommand.
   *
   * @api private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    for (let cmd = this; cmd; cmd = cmd.parent) {
      cmd.options.forEach((anOption) => {
        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    }
  };

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {String[]} argv
   * @return {{operands: String[], unknown: String[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else { // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  };

  /**
   * Return an object containing options as key-value pairs
   *
   * @return {Object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  };

  /**
   * Internal bottleneck for handling of parsing errors.
   *
   * @api private
   */
  _displayError(exitCode, code, message) {
    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) { // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else { // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this._displayError(1, 'commander.missingArgument', message);
  };

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this._displayError(1, 'commander.optionMissingArgument', message);
  };

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this._displayError(1, 'commander.missingMandatoryOptionValue', message);
  };

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @api private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command)
          .filter(option => option.long)
          .map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this._displayError(1, 'commander.unknownOption', message);
  };

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @api private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this._args.length;
    const s = (expected === 1) ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this._displayError(1, 'commander.excessArguments', message);
  };

  /**
   * Unknown command.
   *
   * @api private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach((command) => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this._displayError(1, 'commander.unknownCommand', message);
  };

  /**
   * Set the program version to `str`.
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * You can optionally supply the  flags and description to override the defaults.
   *
   * @param {string} str
   * @param {string} [flags]
   * @param {string} [description]
   * @return {this | string} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  };

  /**
   * Set the description to `str`.
   *
   * @param {string} [str]
   * @param {Object} [argsDescription]
   * @return {string|Command}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  };

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {string|Command}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

    command._aliases.push(alias);
    return this;
  };

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {string[]|Command}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  };

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {String|Command}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this._args.map((arg) => {
        return humanReadableArgName(arg);
      });
      return [].concat(
        (this.options.length || this._hasHelpOption ? '[options]' : []),
        (this.commands.length ? '[command]' : []),
        (this._args.length ? args : [])
      ).join(' ');
    }

    this._usage = str;
    return this;
  };

  /**
   * Get or set the name of the command
   *
   * @param {string} [str]
   * @return {string|Command}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  };

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  };

  /**
   * @api private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    this.emit(this._helpLongFlag); // deprecated
    this.emit('afterHelp', context);
    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));
  };

  /**
   * You can pass in flags and a description to override the help
   * flags and help description for your command. Pass in false to
   * disable the built-in help option.
   *
   * @param {string | boolean} [flags]
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    }
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;

    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;

    return this;
  };

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  };

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {string | Function} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }
};

/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */

function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

/**
 * @param {Command} startCommand
 * @returns {Command[]}
 * @api private
 */

function getCommandAndParents(startCommand) {
  const result = [];
  for (let command = startCommand; command; command = command.parent) {
    result.push(command);
  }
  return result;
}

exports.Command = Command;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// @ts-check

/**
 * CommanderError class
 * @class
 */
class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @constructor
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
}

/**
 * InvalidArgumentError class
 * @class
 */
class InvalidArgumentError extends CommanderError {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   * @constructor
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
}

exports.CommanderError = CommanderError;
exports.InvalidArgumentError = InvalidArgumentError;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/help.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/help.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { humanReadableArgName } = __webpack_require__(/*! ./argument.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/argument.js");

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// @ts-check

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
    if (cmd._hasImplicitHelpCommand()) {
      // Create a command matching the implicit help command.
      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
      const helpCommand = cmd.createCommand(helpName)
        .helpOption(false);
      helpCommand.description(cmd._helpCommandDescription);
      if (helpArgs) helpCommand.arguments(helpArgs);
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Implicit help
    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
    if (showShortHelpFlag || showLongHelpFlag) {
      let helpOption;
      if (!showShortHelpFlag) {
        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
      } else if (!showLongHelpFlag) {
        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
      } else {
        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
      }
      visibleOptions.push(helpOption);
    }
    if (this.sortOptions) {
      const getSortKey = (option) => {
        // WYSIWYG for order displayed in help with short before long, no special handling for negated.
        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
      };
      visibleOptions.sort((a, b) => {
        return getSortKey(a).localeCompare(getSortKey(b));
      });
    }
    return visibleOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd._args.forEach(argument => {
        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd._args.find(argument => argument.description)) {
      return cmd._args;
    };
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');
    return cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '');
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
  };

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  };

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    }, 0);
  };

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let parentCmdNames = '';
    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
    }
    return parentCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  }

  /**
   * Get the command description to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];
    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.

    if (option.argChoices && !option.negate) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
    }
    if (option.defaultValue !== undefined && !option.negate) {
      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  };

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
    }
    return argument.description;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
      }
      return term;
    };
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([commandDescription, '']);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper)
    );
  };

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Detect manually wrapped and indented strings by searching for line breaks
    // followed by multiple spaces/tabs.
    if (str.match(/[\n]\s+/)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.substr(0, indent);
    const columnText = str.substr(indent);

    const indentString = ' '.repeat(indent);
    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)', 'g');
    const lines = columnText.match(regex) || [];
    return leadingStr + lines.map((line, i) => {
      if (line.slice(-1) === '\n') {
        line = line.slice(0, line.length - 1);
      }
      return ((i > 0) ? indentString : '') + line.trimRight();
    }).join('\n');
  }
}

exports.Help = Help;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/option.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/option.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { InvalidArgumentError } = __webpack_require__(/*! ./error.js */ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/error.js");

// @ts-check

class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  };

  /**
   * Set environment variable to check for option value.
   * Priority order of option values is default < env < cli
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  };

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  };

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  };

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  };

  /**
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values;
    this.parseArg = (arg, previous) => {
      if (!values.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  };

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  };

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   * @api private
   */

  attributeName() {
    return camelcase(this.name().replace(/^no-/, ''));
  };

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @api private
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  };
}

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @api private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @api private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

exports.Option = Option;
exports.splitOptionFlags = splitOptionFlags;


/***/ }),

/***/ "../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/suggestSimilar.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@eclipse-glsp/server/node_modules/commander/lib/suggestSimilar.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map(candidate => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map(candidate => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

exports.suggestSimilar = suggestSimilar;


/***/ }),

/***/ "../../node_modules/fast-json-patch/index.mjs":
/*!****************************************************!*\
  !*** ../../node_modules/fast-json-patch/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError),
/* harmony export */   _areEquals: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__._areEquals),
/* harmony export */   applyOperation: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyOperation),
/* harmony export */   applyPatch: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyPatch),
/* harmony export */   applyReducer: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyReducer),
/* harmony export */   compare: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.compare),
/* harmony export */   deepClone: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   escapePathComponent: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),
/* harmony export */   generate: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.generate),
/* harmony export */   getValueByPointer: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),
/* harmony export */   observe: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.observe),
/* harmony export */   unescapePathComponent: () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),
/* harmony export */   unobserve: () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.unobserve),
/* harmony export */   validate: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validate),
/* harmony export */   validator: () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validator)
/* harmony export */ });
/* harmony import */ var _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module/core.mjs */ "../../node_modules/fast-json-patch/module/core.mjs");
/* harmony import */ var _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./module/duplex.mjs */ "../../node_modules/fast-json-patch/module/duplex.mjs");
/* harmony import */ var _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./module/helpers.mjs */ "../../node_modules/fast-json-patch/module/helpers.mjs");





/**
 * Default export for backwards compat
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.assign({}, _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__, _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__, {
    JsonPatchError: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError,
    deepClone: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone,
    escapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,
    unescapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent
}));

/***/ }),

/***/ "../../node_modules/fast-json-patch/module/core.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/fast-json-patch/module/core.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonPatchError: () => (/* binding */ JsonPatchError),
/* harmony export */   _areEquals: () => (/* binding */ _areEquals),
/* harmony export */   applyOperation: () => (/* binding */ applyOperation),
/* harmony export */   applyPatch: () => (/* binding */ applyPatch),
/* harmony export */   applyReducer: () => (/* binding */ applyReducer),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   getValueByPointer: () => (/* binding */ getValueByPointer),
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validator: () => (/* binding */ validator)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "../../node_modules/fast-json-patch/module/helpers.mjs");

var JsonPatchError = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PatchError;
var deepClone = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: _areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (key && key.indexOf('~') != -1) {
                key = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);
            }
            if (banPrototypeModifications &&
                (key == '__proto__' ||
                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {
                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
            // If we have more keys in the path, but the next value isn't a non-null object,
            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
            if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
                throw new JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!_areEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!b.hasOwnProperty(keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!_areEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
;


/***/ }),

/***/ "../../node_modules/fast-json-patch/module/duplex.mjs":
/*!************************************************************!*\
  !*** ../../node_modules/fast-json-patch/module/duplex.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   generate: () => (/* binding */ generate),
/* harmony export */   observe: () => (/* binding */ observe),
/* harmony export */   unobserve: () => (/* binding */ unobserve)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "../../node_modules/fast-json-patch/module/helpers.mjs");
/* harmony import */ var _core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.mjs */ "../../node_modules/fast-json-patch/module/core.mjs");
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */


var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        (0,_core_mjs__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);
    var oldKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
                _generate(oldVal, newVal, patches, path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}


/***/ }),

/***/ "../../node_modules/fast-json-patch/module/helpers.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/fast-json-patch/module/helpers.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PatchError: () => (/* binding */ PatchError),
/* harmony export */   _deepClone: () => (/* binding */ _deepClone),
/* harmony export */   _getPathRecursive: () => (/* binding */ _getPathRecursive),
/* harmony export */   _objectKeys: () => (/* binding */ _objectKeys),
/* harmony export */   escapePathComponent: () => (/* binding */ escapePathComponent),
/* harmony export */   getPath: () => (/* binding */ getPath),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   hasUndefined: () => (/* binding */ hasUndefined),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   unescapePathComponent: () => (/* binding */ unescapePathComponent)
/* harmony export */ });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys_1 = new Array(obj.length);
        for (var k = 0; k < keys_1.length; k++) {
            keys_1[k] = "" + k;
        }
        return keys_1;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return "/" + path;
}
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
                if (hasUndefined(obj[i_1])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));



/***/ }),

/***/ "../../node_modules/winston/package.json":
/*!***********************************************!*\
  !*** ../../node_modules/winston/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"winston","description":"A logger for just about everything.","version":"3.14.2","author":"Charlie Robbins <charlie.robbins@gmail.com>","maintainers":["David Hyde <dabh@alumni.stanford.edu>"],"repository":{"type":"git","url":"https://github.com/winstonjs/winston.git"},"keywords":["winston","logger","logging","logs","sysadmin","bunyan","pino","loglevel","tools","json","stream"],"dependencies":{"@dabh/diagnostics":"^2.0.2","@colors/colors":"^1.6.0","async":"^3.2.3","is-stream":"^2.0.0","logform":"^2.6.0","one-time":"^1.0.0","readable-stream":"^3.4.0","safe-stable-stringify":"^2.3.1","stack-trace":"0.0.x","triple-beam":"^1.3.0","winston-transport":"^4.7.0"},"devDependencies":{"@babel/cli":"^7.23.9","@babel/core":"^7.24.0","@babel/preset-env":"^7.24.0","@dabh/eslint-config-populist":"^4.4.0","@types/node":"^20.11.24","abstract-winston-transport":"^0.5.1","assume":"^2.2.0","cross-spawn-async":"^2.2.5","eslint":"^8.57.0","hock":"^1.4.1","mocha":"^10.3.0","nyc":"^15.1.0","rimraf":"5.0.1","split2":"^4.1.0","std-mocks":"^2.0.0","through2":"^4.0.2","winston-compat":"^0.1.5"},"main":"./lib/winston.js","browser":"./dist/winston","types":"./index.d.ts","scripts":{"lint":"eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist","test":"rimraf test/fixtures/logs/* && mocha","test:coverage":"nyc npm run test:unit","test:unit":"mocha test/unit","test:integration":"mocha test/integration","build":"rimraf dist && babel lib -d dist","prepublishOnly":"npm run build"},"engines":{"node":">= 12.0.0"},"license":"MIT"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./lib/app.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=tasklist-glsp-server.js.map